class UnitTestTagger

  def create_tags
    @escaped_tag = Tag.find_by(shortname: 'escaped')
    if not @escaped_tag
      @escaped_tag = Tag.create!(
          name: 'Lesson: Escaped Test',
          shortname: 'escaped',
          color: '#99ccff',
          description: <<~EOS
        This tag is applied to all vulnerabilities that had existing unit tests covering the vulnerable code.
      EOS
      )
    end

    @lacked_tag = Tag.find_by(shortname: 'lacked')
    if not @lacked_tag
      @lacked_tag = Tag.create!(
          name: 'Lesson: Lacked Test',
          shortname: 'lacked',
          color: '#ff8080',
          description: <<~EOS
        This tag is applied to all vulnerabilities that lacked unit tests covering the vulnerable code.
      EOS
      )
    end

    @untested_tag = Tag.find_by(shortname: 'untested')
    if not @untested_tag
      @untested_tag = Tag.create!(
          name: 'Lesson: Fix Untested',
          shortname: 'untested',
          color: '#cccccc',
          description: <<~EOS
        This tag is applied to all vulnerabilities where the fix for the vulnerability involves adding or improving an automated test to ensure it is not repeated.
      EOS
      )
    end
  end

  def apply_tags
    Vulnerability.all.each do |v|
      findTags(v)
      @tags.each do |t|
        VulnerabilityTag.create!(
                            vulnerability: v,
                            tag: t,
                            note: <<~EOS
                              #{v.notes.dig('unit_tested', 'answer').to_s.sub!("\n", ' ')}
                            EOS
        )
      end
    end
  end

  def findTags(v)
    @tags = []
    if v.notes.dig('unit_tested', 'code') == true
      @tags << @escaped_tag
    end
    if v.notes.dig('unit_tested', 'code') == false
      @tags << @lacked_tag
    end
    if v.notes.dig('unit_tested', 'fix') == true
      @tags << @untested_tag
    end
  end

end
