class CWETagger

  def create_tags
    @tagged_cwes.each { |cwe_id, entry| Tag.find_or_create_by!(entry) }
  end

  def apply_tags
    vuln_tags = []
    untagged = []
    Vulnerability.all.each do |v|
      if @tagged_cwes.key? normalized_cwe_string(v.notes['CWE'])
        vuln_tags << VulnerabilityTag.new(
          vulnerability: v,
          tag: find_tag(v.notes['CWE']),
          note: ''
        )
      else
        puts "Un-tagged CWE: #{v.notes['CWE']}" unless v.notes['CWE'].to_s.blank?
        untagged << normalized_cwe_string(v.notes['CWE'])
      end
    end
    VulnerabilityTag.import vuln_tags
    puts "Untagged, normalized: #{untagged.uniq}"
  end

  # If people entered in text here, just take the number
  # e.g. CWE-122 ==> 122
  def normalized_cwe_string(cwe)
    cwe.to_s.gsub(/[^0-9]/,'').to_i
  end

  def find_tag(cwe_str)
    shortname = @tagged_cwes[normalized_cwe_string(cwe_str)][:shortname]
    Tag.find_by(shortname: shortname)
  end

  # TODO When we do Issue #332, this should not be hardcoded anymore
  def initialize
    @tagged_cwes = {
      122 => {
        name: 'CWE-122: Heap-based Buffer Overflow',
        shortname: 'cwe-122',
        color: '#99ccff',
        description: <<~EOS
          Heap-based buffer overflows are memory corruption problems that often result in crashes, but can result in aribtrary code execution.

          From the cwe.mitre.org

          > A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().

          For more information, see [CWE 122](http://cwe.mitre.org/data/definitions/122.html)
        EOS
      }
      
    }
  end

end
