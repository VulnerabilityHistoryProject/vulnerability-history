require 'oj'
require_relative '../nicknames/namer'
require_relative '../../app/helpers/application_helper'
require_relative '../yml_helper'
require 'timing_logger'

class GitLoader
  include Nicknamer
  include ApplicationHelper
  include VHP::YMLHelper

  def load_data(repo_path, project)
    @log = TimingLogger.new(STDOUT, "data:#{project.subdomain}:gitloader")
    @files = {} # maps filepath string to a Filepath model
    @devs  = {} # maps emails to Developer model
    @commits = [] # List of Commit objects with associated stuff
    @commit_filepaths = [] # List of Commit objects with associated stuff
    project_yml = load_yml_the_vhp_way("#{repo_path}/project.yml")
    @code_exts = project_yml[:source_code_extensions] || []

    @log.info 'Processing git log data'
    File.open("#{repo_path}/commits/gitlog.json") do |f|
      get_commits(f, project)
    end
    @log.info 'Importing developers...'
    Developer.import @devs.values, validate: false

    @log.info 'Importing filepaths...'
    Filepath.import @files.values, validate: false

    @log.info 'Importing commits...'
    Commit.import @commits, validate: false

    @log.info 'Importing commit filepaths...'
    CommitFilepath.import @commit_filepaths, validate: false
  end

  private

  def get_commits(file, project)
    @log.info 'Parsing gitlog.json'
    data_hash = Oj.load(File.read(file))
    @log.info 'Building git log models'
    data_hash.each do |sha, hash|
      start = Time.now
      add_to_db(sha, hash, project) unless hash.empty?
      @log.warn("Possible mega commit? #{sha}") if(Time.now - start > 1.seconds)
    end
  end

  def add_to_db(sha, hash, project)
    dev = Developer.new
    email = Developer.sanitize_validate_email hash["email"]
    dev.email = email
    dev.nickname = nickname_for(email)
    dev.notes = {}
    @devs[email] ||= dev #automatically de-dedups this way
    dev = @devs[email]   # maybe it's what we just set, maybe it's an old one

    commit = Commit.new(
      commit_hash: sha,
      developer: dev,
      project_id: project.id,
      message: hash["message"][0..2999], # truncated, see schema.rb limit
      date_created: hash["date"],
      notes: hash
    )
    @commits << commit
    this_commit_filepaths = {} # map slug to commit_filepath to keep uniqueness

    (hash["filepaths"] || {}).each do |path, churn|
      slug = Filepath.make_slug(project.subdomain, path)
      @files[slug] ||= Filepath.new( # add if we don't already have it
        filepath: path,
        slug: slug,
        project_id: project.id,
        dir: Filepath.compute_dir(path),
        is_code: is_code?(path),
        note: ''
      )
      fp = @files[slug]
      this_commit_filepaths[slug] ||= CommitFilepath.new(
        commit: commit,
        filepath: fp,
        total_churn: churn['insertions'].to_i + churn['deletions'].to_i,
        insertions: churn['insertions'].to_i,
        deletions: churn['deletions'].to_i
      )
    end
    @commit_filepaths += this_commit_filepaths.values
  end

  def is_code?(filepath_str)
    @code_exts.each do |ext|
      return true if filepath_str.end_with? ext
    end
    return false
  end

end
