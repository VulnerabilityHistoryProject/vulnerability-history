require 'oj'
require_relative '../nicknames/namer'
require_relative '../../app/helpers/application_helper'
require_relative '../yml_helper'
require_relative '../project_constants'
require 'timing_logger'

class GitLoader
  include Nicknamer
  include ApplicationHelper
  include VHP::YMLHelper

  def initialize(mining_git_dir, vuln_git_dir)
    @mining_git_dir = mining_git_dir
    @vuln_git_dir = vuln_git_dir
  end

  def load_data
    PROJECT_SHORTNAMES.each do |p|
      @log = TimingLogger.new(STDOUT, "data::git_loader:#{p}")
      @files = {} # maps filepath string to a Filepath model
      @devs  = {} # maps emails to Developer model
      @commits = [] # List of Commit objects with associated stuff
      @commit_filepaths = [] # List of Commit objects with associated stuff

      project_yml = load_yml_the_vhp_way("#{@vuln_git_dir}/projects/#{p}.yml")
      @code_exts = project_yml[:source_code_extensions] || []
      project = Project.find_by(subdomain: p)

      @log.info 'Processing git log data'
      File.open("#{@mining_git_dir}/gitlogs/#{p}.json") do |f|
        get_commits(f, project)
      end
      @log.info 'Importing developers...'
      Developer.import @devs.values, validate: false

      @log.info 'Importing filepaths...'
      Filepath.import @files.values, validate: false

      @log.info 'Importing commits...'
      Commit.import @commits, validate: false

      @log.info 'Importing commit filepaths...'
      CommitFilepath.import @commit_filepaths, validate: false

      GC.start
    end
  end

  private

  def get_commits(file, project)
    @log.info "Parsing #{project.subdomain} json"
    data_hash = Oj.load(File.read(file))
    @log.info 'Building git log models'
    data_hash.each do |sha, hash|
      start = Time.now
      add_to_db(sha, hash, project) unless hash.empty?
      @log.warn("Possible mega commit? #{sha}") if(Time.now - start > 1.seconds)
    end
  end

  def add_to_db(sha, hash, project)
    dev = Developer.new
    if hash["email"].nil?
      @log.warn "#{sha} has null email"
      return
    else
      email = Developer.sanitize_validate_email hash["email"]
    end
    dev.email = email
    dev.nickname = nickname_for(email)
    dev.notes = {}
    @devs[email] ||= dev #automatically de-dedups this way
    dev = @devs[email]   # maybe it's what we just set, maybe it's an old one

    commit = Commit.new(
      commit_hash: sha,
      developer: dev,
      project_id: project.id,
      message: hash["message"][0..2999], # truncated, see schema.rb limit
      date_created: hash["date"],
      notes: hash
    )
    @commits << commit
    this_commit_filepaths = {} # map slug to commit_filepath to keep uniqueness

    (hash["filepaths"] || {}).each do |path, churn|
      slug = Filepath.make_slug(project.subdomain, path)
      @files[slug] ||= Filepath.new( # add if we don't already have it
        filepath: path,
        slug: slug,
        project_id: project.id,
        dir: Filepath.compute_dir(path),
        is_code: is_code?(path),
        note: ''
      )
      fp = @files[slug]
      this_commit_filepaths[slug] ||= CommitFilepath.new(
        commit: commit,
        filepath: fp,
        total_churn: churn['insertions'].to_i + churn['deletions'].to_i,
        insertions: churn['insertions'].to_i,
        deletions: churn['deletions'].to_i
      )
    end
    @commit_filepaths += this_commit_filepaths.values
  end

  def is_code?(filepath_str)
    @code_exts.each do |ext|
      return true if filepath_str.end_with? ext
    end
    return false
  end

end
