require 'json'
require_relative '../nicknames/namer'

class GitLoader
  include Nicknamer

  def load_data(repo_path, project)
    logger = Logger.new(STDOUT, progname: "data:#{project.subdomain}:gitloader")
    @files = {} # maps filepath string to a Filepath model
    @devs  = {} # maps emails to Developer model
    @commits = [] # List of Commit objects with associated stuff

    logger.info 'Loading gitlog.json'
    File.open("#{repo_path}/commits/gitlog.json") do |f|
      get_commits(f, project)
    end
    logger.info 'Importing developers...'
    Developer.import @devs.values, validate: false

    logger.info 'Importing filepaths...'
    Filepath.import @files.values, validate: false

    logger.info 'Importing commits...'
    Commit.import @commits, recursive: true, validate: false
  end

  private

  def get_commits(file, project)
    data_hash = JSON.parse(File.read(file))
    data_hash.each do |key, hash|
      add_to_db(hash, project) unless hash.empty?
    end
  end

  def add_to_db(hash, project)
    dev = Developer.new
    email = Developer.sanitize_validate_email hash["email"]
    dev.email = email
    dev.nickname = nickname_for(email)
    dev.notes = {}
    @devs[email] ||= dev #automatically de-dedups this way
    dev = @devs[email]   # maybe it's what we just set, maybe it's an old one
    # dev.save

    commit = Commit.new(
      commit_hash: hash["commit"],
      developer: dev,
      message: hash["message"][0..2999], # truncated, see schema.rb limit
      date_created: hash["date"],
      notes: hash
    )
    @commits << commit

    (hash["filepaths"] || {}).each do |path, churn|
      fp = Filepath.new
      fp.filepath = path
      fp.project_id = project.id
      fp.note = ""
      @files[path] ||= fp
      fp = @files[path]

      commit.commit_filepaths << CommitFilepath.new(
        filepath: fp,
        total_churn: churn['insertions'].to_i + churn['deletions'].to_i
      )
    end
  end
end
