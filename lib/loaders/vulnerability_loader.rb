require 'timing_logger'
require 'yml_helper'
require 'date'

class VulnerabilityLoader

  include VHP::YMLHelper

  def initialize(vuln_git_dir)
    @log = TimingLogger.new(STDOUT, 'data:load:vulns')
    @repo_path = vuln_git_dir
  end

  # Doing a DB search on every single iteration here is costly.
  # Instead, we're making a massive hash table of commit hashes to database IDs
  def init_commit_ids
    @commit_ids = {}
    Commit.select(:commit_hash, :id, :notes).each do |commit|
      @commit_ids[commit.commit_hash] = commit
    end
  end

  def load_data
    vulnerabilities = []
    fixes = []
    vccs = []
    @log.info 'Initializing commit cache'
    init_commit_ids
    @log.info 'Parsing YMLs and making models'
    batch_size = 100
    batch_i = 0
    Dir["#{@repo_path}/cves/**/*.yml"].each do |file|
      begin
        start = Time.now
        yml = load_yml_the_vhp_way(file)
        project = Project.find_by(subdomain: subdomain_from_filepath(file))
        v = create_vulnerability(yml, project)
        unless v.nil?
          fixes += create_fixes(v, yml, project)
          vccs += create_vccs(v, yml, project)
          vulnerabilities << v
        end
        @log.warn "Slow load on #{file}" if Time.now - start > 1.second
      rescue => e
        @log.error "Error loading vuln file #{file}. Cause: #{e.full_message}"
        @log.warn "Continuing after previous error..."
        # byebug
      end
      batch_i += 1
      if batch_i % batch_size == 0
        Vulnerability.import vulnerabilities
        Fix.import fixes
        Vcc.import vccs
        vulnerabilities.clear
        fixes.clear
        vccs.clear
      end
    end
    Vulnerability.import vulnerabilities
    Fix.import fixes
    Vcc.import vccs
  end

  def create_vulnerability(yml, project)
    if (yml[:announced].nil? &&
        yml[:announced_date].nil? &&
        yml[:published_date].nil?)
      @log.warn "ANNOUNCED DATE MISSING for #{yml[:CVE]} in #{project.name}"
      return nil
    else
      vulndate = yml[:announced] || yml[:announced_date] || yml[:published_date]
      vulndate = Date.parse(vulndate).rfc2822 unless vulndate.is_a?(Date)
      Vulnerability.new(
        cve: yml[:CVE],
        announced: vulndate,
        description: yml[:description].to_s,
        short_desc: first_sentence(yml[:description].to_s),
        upvotes: yml[:upvotes].to_i,
        nickname: yml[:nickname].to_s,
        project_id: project.id,
        notes: yml,
      )
    end
  end

  def create_fixes(v, yml, project)
    fixes = []
    yml[:fixes]&.each do | entry |
      hash = entry[:commit]
      unless hash.to_s.strip.empty?
        commit_id = @commit_ids[hash]
        if commit_id.nil?
          @log.warn "WARNING: Missing commit data for #{hash}. Fix not created for #{yml[:CVE]} in #{project.subdomain}."
        else
          fixes << Fix.new(
            vulnerability: v,
            commit_id: commit_id.id,
            notes: @commit_ids[hash].notes,
          )
        end
      end
    end
    if fixes.empty?
      # @log.warn "WARNING: There are no fix commits for #{project.subdomain} #{yml[:CVE]}"
    end
    return fixes
  end

  def create_vccs(v, yml, project)
    vccs = []
    yml[:vccs]&.each do | entry |
      hash = entry[:commit]
      unless hash.to_s.strip.empty?
        commit_id = @commit_ids[hash]
        if commit_id.nil?
          @log.warn "WARNING: Missing commit data for #{hash}. VCC not created for #{yml[:CVE]} in #{project.subdomain}."
        else
          vccs << Vcc.new(
            vulnerability: v,
            commit_id: commit_id.id,
            notes: @commit_ids[hash].notes,
          )
        end
      end
    end
    return vccs
  end

  # Remove some of our super-verbose instructions to shrink network footprint
  # Any key that ends in "instructions" or "question" is rejected.
  #
  # Turns out this might not speed things up as we thought. It might though.
  # So I'm keeping it because I'm proud of it. Call me a code packrat.
  #
  # def clean_yml(yml)
  #   reject_regex = /instructions$|question$/
  #   case yml
  #   when Hash
  #     yml = yml.inject({}) do |m, (k, v)|
  #       m[k] = clean_yml(v) unless reject_regex === k.to_s # recursive?!? gasp.
  #       m
  #     end
  #   end
  #   yml
  # end
  #
  # recursive remove keys. Adapted from: https://stackoverflow.com/questions/10676608/ruby-deleting-all-instances-of-a-particular-key-from-hash-of-hashes
  # def deep_simplify_record(hash, keep)
  #   hash.keep_if do |key, value|
  #     if keep.include?(key)
  #       deep_simplify_record(value, keep) if value.is_a?(Hash)
  #       true
  #     end
  #   end
  # end

  # helper class to generate short_desc
  def first_sentence(description)
    description.split('. ')[0].to_s
  end

  # Extract the project from the filepath of the yml file
  def subdomain_from_filepath(str)
    str[%r{/cves/(?<project>.*)/.*yml},:project]
  end

end
