require 'timing_logger'
require 'yml_helper'

class VulnerabilityLoader

  include VHP::YMLHelper

  def initialize
    @log = TimingLogger.new(STDOUT, 'data:load:vulns')
    init_commit_ids
  end

  # Doing a DB search on every single iteration here is costly.
  # Instead, we're making a massive hash table of commit hashes to database IDs
  def init_commit_ids
    @commit_ids = {}
    Commit.select(:commit_hash, :id).each do |commit|
      @commit_ids[commit.commit_hash] = commit.id
    end
  end

  def load_data(repo_path, project)
    vulnerabilities = []
    fixes = []
    vccs = []
    @log.info 'Parsing YMLs and making models'
    Dir["#{repo_path}/cves/*.yml"].each do |file|
      begin
        start = Time.now
        yml = load_yml_the_vhp_way(file)
        v   = create_vulnerability(yml, project)
        unless v.nil?
          fixes += create_fixes(v, yml)
          vccs += create_vccs(v, yml)
          vulnerabilities << v
        end
        @log.warn "Slow load on #{file}" if Time.now - start > 1.second
      rescue => e
        @log.error "Error loading vuln file #{file}. Cause: #{e.full_message}"
        # byebug
      end
    end
    @log.info 'Importing vulnerabilities...'
    Vulnerability.import vulnerabilities
    @log.info 'Importing fixes...'
    Fix.import fixes
    @log.info 'Importing vccs...'
    Vcc.import vccs
  end

  def create_vulnerability(yml, project)
    if yml[:announced].nil?
      @log.warn "ANNOUNCED DATE MISSING for #{yml[:CVE]} in #{project.name}"
      return nil
    else
      Vulnerability.new(
        cve: yml[:CVE],
        announced: yml[:announced],
        description: yml[:description].to_s,
        short_desc: first_sentence(yml[:description].to_s),
        upvotes: yml[:upvotes].to_i,
        nickname: yml[:nickname].to_s,
        project_id: project.id,
        notes: yml,
      )
    end
  end

  def create_fixes(v, yml)
    fixes = []
    yml[:fixes]&.each do | entry |
      hash = entry[:commit]
      unless hash.to_s.strip.empty?
        commit_id = @commit_ids[hash]
        if commit_id.nil?
          @log.warn "WARNING: Missing commit data for #{hash}. Fix not created."
        else
          fixes << Fix.new(
            vulnerability: v,
            commit_id: commit_id,
          )
        end
      end
    end
    return fixes
  end

  def create_vccs(v, yml)
    vccs = []
    yml[:vccs]&.each do | entry |
      hash = entry[:commit]
      unless hash.to_s.strip.empty?
        commit_id = @commit_ids[hash]
        if commit_id.nil?
          @log.warn "WARNING: Missing commit data for #{hash}. VCC not created."
        else
          vccs << Vcc.new(
            vulnerability: v,
            commit_id: commit_id,
          )
        end
      end
    end
    return vccs
  end

  # helper class to generate short_desc
  def first_sentence(description)
    description.split('. ')[0].to_s
  end

end
