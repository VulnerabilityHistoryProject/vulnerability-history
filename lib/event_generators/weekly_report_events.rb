require_relative '../../app/helpers/application_helper'
require 'json'
require 'date'
require 'writing'
require 'timing_logger'

class WeeklyReportEvents
  include ApplicationHelper

  def initialize(project)
    @project = project
    @report_desc = Writing.event_article('weekly-overall')
    @newdev_desc = Writing.event_article('weekly-newdevs')
    @revert_desc = Writing.event_article('weekly-reverts')
    @owner_desc = Writing.event_article('weekly-ownership')
    @refactors_desc = Writing.event_article('weekly-refactors')
    @cooks_tag = Tag.find_by(shortname: 'cooks') || Tag.create!(
      name: 'Lesson: Too Many Cooks',
      shortname: 'cooks',
      color: '#009696',
      icon: 'people',
      description: Writing.tag_article('cooks')
    )
  end

  def cve_from_filename(f)
    f.match(/.*(?<cve>CVE-.+-.+)-weekly.json/)[:cve]
  end

  def generate(repo_path)
    logger = TimingLogger.new(STDOUT, 'data:events:weeklies')
    v_cache = build_vuln_cache()
    events = []
    tags =   []
    vuln_events = []
    logger.info "Parsing & prepping weeklies"
    Dir["#{repo_path}/commits/weeklies/*.json"].each do |file|
      json = File.open(file) { |f| JSON.load(f) }
      cve = cve_from_filename(file)
      vuln_id = v_cache[cve]
      if vuln_id.nil?
        logger.warn "WARNING: weekly report for #{cve}, but vuln not found"
      else
        num_devs = 0
        new_events = []
        json.each do |_week, report|
          new_events << overall_report_event(report)
          new_events << new_developers_event(report)
          new_events << ownership_change(report)
          new_events << revert(report)
          new_events << refactor(report)
          num_devs += report['new_developers'].size
        end
        tags << too_many_cooks(vuln_id, num_devs) if num_devs >= 10
        vuln_events += new_events.compact.map do |e|
          VulnerabilityEvent.new(event: e, vulnerability_id: vuln_id)
        end
        events += new_events.compact
      end
    end
    events.compact!
    logger.info "Inserting events"
    Event.import events, validate: false
    logger.info "Inserting vuln_event linkages"
    VulnerabilityEvent.import vuln_events, validate: false
    logger.info "Inserting tag data"
    VulnerabilityTag.import tags, validate: false
    logger.info "Done with weeklies"
  end

  # Always create an event for a week with commits
  def overall_report_event(report)
    churn = report['insertions'].to_i + report['deletions'].to_i
    num_devs = report['developers'].size.to_s
    drive_bys = report['drive_bys'] || []
    file_list = report['files'].map { |f| " * `#{f}`" }.join("\n")
    desc = @report_desc.gsub /:[\w_]+:/, {
      ':num_devs:' => num_devs,
      ':nice_date:' => nice_date(report),
      ':num_commits:' => report['commits'].to_s,
      ':num_insertions:' => report['insertions'].to_s,
      ':num_deletions:' => report['deletions'].to_s,
      ':num_files:' => report['files'].size.to_s,
      ':num_drive_bys:' => drive_bys.size.to_s,
      ':file_list:' => file_list,
    }
    # For performance reasons, we're not providing details on each file
    # files = Array.new
    # report['files'].each do | file, index |
    #   path = Filepath.find_by(filepath: file)
    #   files.push({ file: file, slug: (path.nil? ? "" : path.slug) })
    # end

    # For performance reasons, we're not providing details on who each person was during the week.
    # devs = Array.new
    # report['developers'].each do | email |
    #   dev = Developer.find_by(email: email)
    #   devs.push(dev.nil? ? nil : dev.nickname)
    # end

    Event.new(
      date: report['date'],
      event_type: 'changes',
      title: <<~EOS,
        #{report['commits']} commits by #{num_devs} developers, #{churn} lines changed
      EOS
      description: desc,
      icon: 'assignment',
      color: '#bbbbbb',
      start_hidden: true
    )
  end

  def new_developers_event(report)
    return nil unless report['new_developers'].any?
    num_new_devs = report['new_developers'].size
    desc = @newdev_desc.gsub(':nice_date:', nice_date(report))
                       .gsub(':new_devs:', num_new_devs.to_s)

    # For performance reasons, we're not loading who the developer actually is here.
    devs = Array.new
    # report['new_developers'].each do | email |
    #   dev = Developer.find_by(email: email)
    #   devs.push(dev.nil? ? nil : dev.nickname)
    # end

    Event.new(
      date: report['date'],
      event_type: 'new developer',
      title: "#{num_new_devs} new developer(s)",
      description: desc,
      icon: 'person',
      color: '#B7AADE',
      start_hidden: true
    )
  end

  def ownership_change(report)
    return nil unless report['ownership_change']
    desc = @owner_desc.gsub(':nice_date:', nice_date(report))
    Event.new(
      date: report['date'],
      title: "Code ownership changed",
      event_type: 'owner change',
      description: desc,
      icon: 'face',
      color: '#BB5093',
      start_hidden: false
    )
  end

  def revert(report)
    return nil unless report['reverts'].size > 0
    desc = @revert_desc.gsub(':num_reverts:', report['reverts'].size.to_s)
                       .gsub(':nice_date:', nice_date(report))

    Event.new(
      date: report['date'],
      title: "#{report['reverts'].size.to_s} revert commit(s)",
      event_type: 'reverts',
      description: desc,
      icon: 'compare_arrows',
      color: '#FF953D',
      start_hidden: false
    )
  end

  def refactor(report)
    return nil unless report['refactors'].size > 0
    desc = @refactors_desc.gsub(':num_refactors:', report['refactors'].size.to_s)
                          .gsub(':nice_date:', nice_date(report))
    Event.new(
      date: report['date'],
      title: "#{report['refactors'].size.to_s} refactor commit(s)",
      event_type: 'refactors',
      description: desc,
      icon: 'healing',
      color: '#F4DC0C',
      start_hidden: false
    )
  end

  def too_many_cooks(vuln_id, num_devs)
    VulnerabilityTag.new(
      tag: @cooks_tag,
      vulnerability_id: vuln_id,
      note: "#{num_devs} different developers have made commits to the files fixed for this vulnerability."
    )
  end

  def nice_date(report)
    DateTime.parse(report['date']).strftime('%A, %B %d, %Y')
  end

  # Map every CVE to its ID - save us a DB call over and over
  def build_vuln_cache()
    r = Vulnerability.select(:id,:cve).where(project: @project).pluck(:id, :cve)
    return r.inject({}) { |map, (id, cve)| map[cve] = id; map }
  end

end
