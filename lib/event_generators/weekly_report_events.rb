require_relative '../../app/helpers/application_helper'
require 'json'
require 'date'
require 'writing'
require 'timing_logger'

class WeeklyReportEvents
  include ApplicationHelper

  def initialize(project, log = TimingLogger.new(STDOUT, 'data:events:weeklies'))
    @logger = log
    @project = project
    @report_desc = Writing.event_article('weekly-overall')
    @newdev_desc = Writing.event_article('weekly-newdevs')
    @revert_desc = Writing.event_article('weekly-reverts')
    @owner_desc = Writing.event_article('weekly-ownership')
    @refactors_desc = Writing.event_article('weekly-refactors')

    @cooks_tag = Tag.find_by(shortname: 'cooks') || Tag.create!(
      name: 'Lesson: Too Many Cooks',
      shortname: 'cooks',
      color: '#009696',
      icon: 'people',
      description: Writing.tag_article('cooks')
    )
  end

  def cve_from_filename(f)
    f.match(/.*(?<cve>CVE-.+-.+)-weekly.json/)[:cve]
  end

  def generate(repo_path)
    v_cache = build_vuln_cache()
    events = []
    tags =   []
    vuln_events = []
    @logger.info "Parsing & prepping weeklies"
    Dir["#{repo_path}/commits/weeklies/*.json"].each do |file|
      json = File.open(file) { |f| JSON.load(f) }
      cve = cve_from_filename(file)
      vuln_id = v_cache[cve]
      if vuln_id.nil?
        @logger.warn "WARNING: weekly report for #{cve}, but vuln not found"
      else
        num_devs = 0
        new_events = []
        json.each do |_week, report|
          report['nice_date'] = nice_date(report['date'])
          new_events << overall_report_event(vuln_id, report)
          new_events << new_developers_event(vuln_id, report)
          new_events << ownership_change(vuln_id, report)
          new_events << revert(vuln_id, report)
          new_events << refactor(vuln_id, report)
          num_devs += report['new_developers'].size
        end
        tags << too_many_cooks(vuln_id, num_devs) if num_devs >= 10
        events += new_events.compact
      end
    end
    events.compact!
    @logger.info "Inserting events"
    columns = [ :date, :event_type, :title, :description, :icon, :color,
                :vulnerability_id, :start_hidden, ]
    Event.import columns, events, validate: false
    @logger.info "Inserting tag data"
    VulnerabilityTag.import tags, validate: false
    @logger.info "Done with weeklies"
  end

  # Always create an event for a week with commits
  def overall_report_event(vuln_id, report)
    churn = report['insertions'].to_i + report['deletions'].to_i
    num_devs = report['developers'].size.to_s
    drive_bys = report['drive_bys'] || []
    desc = @report_desc.gsub /:[\w]+:/, {
      ':num_devs:' => num_devs,
      ':nice_date:' => report['nice_date'],
      ':num_commits:' => report['commits'].to_s,
      ':num_insertions:' => report['insertions'].to_s,
      ':num_deletions:' => report['deletions'].to_s,
      ':num_files:' => report['files'].size.to_s,
      ':num_drive_bys:' => drive_bys.size.to_s,
    }

    return { # Constructing 100k event objects is slow - use hashes instead
        date: report['date'],
        event_type: 'changes',
        title: <<~EOS,
          #{report['commits']} #{'commit'.pluralize(report['commits'])} by #{num_devs} #{'developers'.pluralize(num_devs.to_i)}, #{churn} #{'line'.pluralize(churn)} changed
        EOS
        description: desc,
        icon: 'assignment',
        color: compute_color(churn),
        vulnerability_id: vuln_id,
        start_hidden: true
      }
  end

  def new_developers_event(vuln_id, report)
    return nil unless report['new_developers'].any?
    num_new_devs = report['new_developers'].size
    desc = @newdev_desc.gsub(':nice_date:', report['nice_date'])
                       .gsub(':new_devs:', num_new_devs.to_s)
    return {
      date: report['date'],
      event_type: 'new developer',
      title: "#{num_new_devs} new developer(s)",
      description: desc,
      icon: 'person',
      color: '#B7AADE',
      vulnerability_id: vuln_id,
      start_hidden: true
    }
  end

  def ownership_change(vuln_id, report)
    return nil unless report['ownership_change']
    desc = @owner_desc.gsub(':nice_date:', report['nice_date'])
    return {
      date: report['date'],
      title: "Code ownership changed",
      event_type: 'owner change',
      description: desc,
      icon: 'face',
      color: '#BB5093',
      vulnerability_id: vuln_id,
      start_hidden: false
    }
  end

  def revert(vuln_id, report)
    return nil unless report['reverts'].to_i > 0
    desc = @revert_desc.gsub(':num_reverts:', report['reverts'].to_s)
                       .gsub(':nice_date:', report['nice_date'])

    return {
      date: report['date'],
      title: "#{report['reverts'].to_s} revert commit(s)",
      event_type: 'reverts',
      description: desc,
      icon: 'compare_arrows',
      color: '#FF953D',
      vulnerability_id: vuln_id,
      start_hidden: false
    }
  end

  def refactor(vuln_id, report)
    return nil unless report['refactors'].to_i > 0
    desc = @refactors_desc.gsub(':num_refactors:', report['refactors'].to_s)
                          .gsub(':nice_date:', report['nice_date'])
    return {
      date: report['date'],
      title: "#{report['refactors']} refactor commit(s)",
      event_type: 'refactors',
      description: desc,
      icon: 'healing',
      color: '#F4DC0C',
      vulnerability_id: vuln_id,
      start_hidden: false
    }
  end

  def too_many_cooks(vuln_id, num_devs)
    VulnerabilityTag.new(
      tag: @cooks_tag,
      vulnerability_id: vuln_id,
      note: "#{num_devs} different developers have made commits to the files fixed for this vulnerability."
    )
  end

  def nice_date(date_str)
    DateTime.parse(date_str).strftime('%A, %B %d, %Y')
  end

  # Map every CVE to its ID - save us a DB call over and over
  def build_vuln_cache()
    r = Vulnerability.select(:id,:cve).where(project: @project).pluck(:id, :cve)
    return r.inject({}) { |map, (id, cve)| map[cve] = id; map }
  end

  def compute_color(churn)
    big_week = 1_000.0 # >1k SLOC changed? That's a big week.
    churn = churn.clamp(0, big_week)
    # this didn't work but I like the idea of a linear gradient here.
    # perc = (churn / big_week).clamp(0.1, 0.9) * 100 # don't want pure white or black
    # "hsl(0,0,#{perc}%)"
    return case churn.to_i
           when 0..250
             '#ddd'
           when 251..500
             '#aaa'
           when 501..750
             '#777'
           when 751..1_000
             '#333'
           end
  end

end
