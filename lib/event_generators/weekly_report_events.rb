require 'json'
require 'date'

class WeeklyReportEvents

  def cve_from_filename(f)
    f.match(/.*(?<cve>CVE-.+-.+)-weekly.json/)[:cve]
  end

  def generate(repo_path)
    logger = Logger.new(STDOUT, progname: 'data:chromium:events:weeklies')
    events = []
    tags =   []
    cooks_tag = add_cooks_tag
    logger.info "Parsing JSON weeklies"
    Dir["#{repo_path}/commits/weeklies/*.json"].each do |file|
      json = File.open(file) { |f| JSON.load(f) }
      v = Vulnerability.find_by(cve: cve_from_filename(file))
      if v.nil?
        puts "WARNING: weekly report for #{file}, but vuln not found"
      else
        num_devs = 0
        json.each do |_week, report|
          events << overall_report_event(v, report)
          events << new_developers_event(v, report)
          num_devs += report['new_developers'].size
        end
        tags << too_many_cooks(v, cooks_tag, num_devs) if num_devs > 5
        v.notes['num_devs'] = num_devs
        v.save
      end
    end
    logger.info "Inserting event and tag data"
    events.compact!
    vuln_events = events.map do |e|
      VulnerabilityEvent.new(event: e, vulnerability: e.detail)
    end
    Event.import events
    VulnerabilityEvent.import vuln_events
    VulnerabilityTag.import tags
  end

  # Always create an event for a week with commits
  def overall_report_event(v, report)
    churn = report['insertions'].to_i + report['deletions'].to_i
    num_devs = report['developers'].size
    Event.new(
      detail: v,
      style: style,
      title_template: "#{report['commits']} commits by #{num_devs} developers, " +
                      "#{churn} lines changed",
      description_template: <<~EOS ,
        During the 7-day period starting on #{nice_date(report)}, the code that was
        impacted by this vulnerability had #{report['commits']} commits by
        #{num_devs} different developers.

        Those changes involved #{report['insertions']} line(s) inserted
        and #{report['deletions']} line(s) deleted, impacting a total of
        #{report['files'].size} source code file(s). The impacted files were:

        #{report['files'].map { |f| " * `" + f + '`'  }.join("\n") }
      EOS
      date_template: report['date']
    )
  end

  def new_developers_event(v, report)
    return nil unless report['new_developers'].any?
    num_new_devs = report['new_developers'].size
    Event.new(
      detail: v,
      style: style,
      date_template: report['date'],
      title_template: "#{num_new_devs} new developers",
      description_template: <<~EOS
        On the week of #{nice_date(report)},
        #{num_new_devs} developer(s) committed to this code, and they have
        never committed to this code before.

        Familiarity is difficult to gain with code. Even for the best
        developers, contributing to a piece of source code for the first time
        means that they must understand the design decisions from previous
        developers, any issues the code has had historically, and the coding
        style. Thus, the first commit any developer makes is risky.

        Furthermore, research has shown a strong correlation between code that
        had many developers and code with vulnerabilities. Learn more about
        that effect in the tag "Lesson: Too Many Cooks".
      EOS
    )
  end

  def too_many_cooks(v, cooks_tag, num_devs)
    VulnerabilityTag.new(
      tag: cooks_tag,
      vulnerability: v,
      note: "#{num_devs} different developers have made commits to the files fixed for this vulnerability."
    )
  end

  def style
    @style ||= Style.find_or_create_by!(
      name: 'vulnerability',
      icon: 'bug_report',
      color: '#F07866',
    )
  end

  def nice_date(report)
    DateTime.parse(report['date']).strftime('%A, %B %d, %Y')
  end

  def add_cooks_tag
    Tag.find_by(shortname: 'cooks') || Tag.create!(
      name: 'Lesson: Too Many Cooks',
      shortname: 'cooks',
      color: '#009696',
      description: <<~EOS
        To be written.

        Provide a few paragraphs and references about how having multiple
        developers work on a piece of code increases its liklihood of having a
        vulnerability.

        Note that we used 5 as an arbitrary threshold, but it's really more of
        a spectrum.
      EOS
    )
  end

end
