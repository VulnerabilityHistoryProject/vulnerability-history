require_relative '../../app/helpers/application_helper'
require 'json'
require 'date'
require 'writing'
require 'timing_logger'

class WeeklyReportEvents
  include ApplicationHelper

  def initialize(log = TimingLogger.new(STDOUT, 'data:events:weeklies'))
    @logger = log
    @report_desc = Writing.event_article('weekly-overall')
    @newdev_desc = Writing.event_article('weekly-newdevs')
    @revert_desc = Writing.event_article('weekly-reverts')
    @owner_desc = Writing.event_article('weekly-ownership')
    @refactors_desc = Writing.event_article('weekly-refactors')
    lessons_group = TagGrouping.find_by(slug: 'lessons')

    @owners_tag = Tag.find_by(shortname: 'owners') || Tag.create!(
      name: 'Lesson: Changing Owners',
      shortname: 'owners',
      color: '#009696',
      icon: 'identity',
      description: Writing.tag_article('owners'),
      tag_grouping: lessons_group
    )

    @cooks_tag = Tag.find_by(shortname: 'cooks') || Tag.create!(
      name: 'Lesson: Too Many Cooks',
      shortname: 'cooks',
      color: '#009696',
      icon: 'people',
      description: Writing.tag_article('cooks'),
      tag_grouping: lessons_group
    )

    @refactors_tag = Tag.find_by(shortname: 'refactors') || Tag.create!(
      name: 'Lesson: Code Refactors',
      shortname: 'refactors',
      color: '#009696',
      icon: 'branch',
      description: Writing.tag_article('refactors'),
      tag_grouping: lessons_group
    )

    @reverts_tag = Tag.find_by(shortname: 'reverts') || Tag.create!(
      name: 'Lesson: Reverting Codebase',
      shortname: 'reverts',
      color: '#009696',
      icon: 'rewind',
      description: Writing.tag_article('reverts'),
      tag_grouping: lessons_group
    )
  end

  def cve_from_filename(f)
    f.match(/.*(?<cve>CVE-.+-.+)-weekly.json/)[:cve]
  end

  def check_missing_reports(vuln_git_dir, mining_git_dir)
    @logger.info "Checking for missing weeklies"
    Dir["#{vuln_git_dir}/cves/**/*.yml"].each do |f|
      cve = f.match(/(?<cve>CVE\-\d+\-\d+)\.yml/)[:cve]
      project = f.match(%r{cves/(?<project>\w+)/CVE})[:project]
      weekly_json = "#{mining_git_dir}/weeklies/#{project}/#{cve}-weekly.json"
      if (!File.exist?(weekly_json) &&
          Vulnerability.find_by(cve: cve)&.fixes&.count.to_i > 0)
        @logger.warn "Missing weekly report on #{project} #{cve}"
      end
    end
  end

  def generate(vuln_git_dir, mining_git_dir)
    v_cache = build_vuln_cache()
    events = []
    tags =   []
    vuln_events = []
    check_missing_reports(vuln_git_dir, mining_git_dir)
    @logger.info "Parsing & prepping weeklies"
    batch_size = 100
    batch_i = 1
    Dir["#{mining_git_dir}/weeklies/**/*.json"].each do |file|
      json = File.open(file) { |f| JSON.load(f) }
      cve = cve_from_filename(file)
      vuln_id = v_cache[cve]
      if vuln_id.nil?
        @logger.warn "WARNING: weekly report for #{cve}, but vuln not found"
      else
        num_owners = 0
        num_devs = 0
        num_refactors = 0
        num_reverts = 0
        new_events = []
        json.each do |_week, report|
          report['nice_date'] = nice_date(report['date'])
          new_events << overall_report_event(vuln_id, report)
          new_events << new_developers_event(vuln_id, report)
          new_events << ownership_change(vuln_id, report)
          new_events << revert(vuln_id, report)
          new_events << refactor(vuln_id, report)
          num_owners += 1 if report['ownership_change']
          num_devs += report['new_developers'].size
          num_refactors += report['refactors']
          num_reverts += report['reverts']
        end
        tags << tag_many_cooks(vuln_id, num_devs) if num_devs >= 10
        tags << tag_many_owners(vuln_id, num_owners) if num_owners >= 10
        tags << tag_many_refactors(vuln_id, num_refactors) if num_refactors >= 10
        tags << tag_many_reverts(vuln_id, num_reverts) if num_reverts >= 10
        events += new_events.compact
      end
      events.compact!
      batch_i += 1
      if batch_i % batch_size == 0
        columns = [ :date, :event_type, :title, :description, :icon, :color,
          :vulnerability_id, :start_hidden, ]
        Event.import columns, events, validate: false, batch_size: 10_000
        events.clear
        json = {}
        GC.start
      end
    end
    columns = [ :date, :event_type, :title, :description, :icon, :color,
                :vulnerability_id, :start_hidden, ]
    Event.import columns, events, validate: false, batch_size: 10_000

    # @logger.info "Inserting events"
    @logger.info "Inserting tag data"
    VulnerabilityTag.import tags, validate: false
    @logger.info "Done with weeklies"
  end

  # Always create an event for a week with commits
  def overall_report_event(vuln_id, report)
    churn = report['insertions'].to_i + report['deletions'].to_i
    num_devs = report['developers'].size.to_s
    drive_bys = report['drive_bys'] || []
    desc = @report_desc.gsub /:[\w]+:/, {
      ':num_devs:' => num_devs,
      ':nice_date:' => report['nice_date'],
      ':commits:' => report['commits'].to_s,
      ':insertions:' => report['insertions'].to_s,
      ':deletions:' => report['deletions'].to_s,
      ':num_files:' => report['files'].size.to_s,
      ':num_drive_bys:' => drive_bys.size.to_s,
    }

    return { # Constructing 100k event objects is slow - use hashes instead
        date: report['date'],
        event_type: 'changes',
        title: <<~EOS,
          #{report['commits']} #{'commit'.pluralize(report['commits'])} by #{num_devs} #{'developers'.pluralize(num_devs.to_i)}, #{churn} #{'line'.pluralize(churn)} changed
        EOS
        description: desc,
        icon: 'assignment',
        color: compute_color(churn),
        vulnerability_id: vuln_id,
        start_hidden: true
      }
  end

  def new_developers_event(vuln_id, report)
    return nil unless report['new_developers'].any?
    num_new_devs = report['new_developers'].size
    desc = @newdev_desc.gsub(':nice_date:', report['nice_date'])
                       .gsub(':new_devs:', num_new_devs.to_s)
    return {
      date: report['date'],
      event_type: 'new developer',
      title: "#{num_new_devs} new developer(s)",
      description: desc,
      icon: 'person',
      color: '#d0daf8',
      vulnerability_id: vuln_id,
      start_hidden: true
    }
  end

  def ownership_change(vuln_id, report)
    return nil unless report['ownership_change']
    desc = @owner_desc.gsub(':nice_date:', report['nice_date'])
    return {
      date: report['date'],
      title: "Code ownership changed",
      event_type: 'owner change',
      description: desc,
      icon: 'face',
      color: '#c485d7',
      vulnerability_id: vuln_id,
      start_hidden: false
    }
  end

  def revert(vuln_id, report)
    return nil unless report['reverts'].to_i > 0
    desc = @revert_desc.gsub(':num_reverts:', report['reverts'].to_s)
                       .gsub(':nice_date:', report['nice_date'])

    return {
      date: report['date'],
      title: "#{report['reverts'].to_s} revert commit(s)",
      event_type: 'reverts',
      description: desc,
      icon: 'compare_arrows',
      color: '#f98371',
      vulnerability_id: vuln_id,
      start_hidden: false
    }
  end

  def refactor(vuln_id, report)
    return nil unless report['refactors'].to_i > 0
    desc = @refactors_desc.gsub(':num_refactors:', report['refactors'].to_s)
                          .gsub(':nice_date:', report['nice_date'])
    return {
      date: report['date'],
      title: "#{report['refactors']} refactor commit(s)",
      event_type: 'refactors',
      description: desc,
      icon: 'healing',
      color: '#9fe69f',
      vulnerability_id: vuln_id,
      start_hidden: false
    }
  end

  def tag_many_owners(vuln_id, num_owners)
    VulnerabilityTag.new(
      tag: @owners_tag,
      vulnerability_id: vuln_id,
      note: "The owner of the code with the vulnerability changed #{num_owners} times."
    )
  end

  def tag_many_cooks(vuln_id, num_devs)
    VulnerabilityTag.new(
      tag: @cooks_tag,
      vulnerability_id: vuln_id,
      note: "#{num_devs} different developers made commits to the files fixed for this vulnerability."
    )
  end

  def tag_many_refactors(vuln_id, num_refactors)
    VulnerabilityTag.new(
      tag: @refactors_tag,
      vulnerability_id: vuln_id,
      note: "#{num_refactors} refactors took place during the vulnerability."
    )
  end

  def tag_many_reverts(vuln_id, num_reverts)
    VulnerabilityTag.new(
      tag: @reverts_tag,
      vulnerability_id: vuln_id,
      note: "#{num_reverts} reverts took place during the vulnerability."
    )
  end

  def nice_date(date_str)
    DateTime.parse(date_str).strftime('%A, %B %d, %Y')
  end

  # Map every CVE to its ID - save us a DB call over and over
  def build_vuln_cache()
    r = Vulnerability.select(:id,:cve).pluck(:id, :cve)
    return r.inject({}) { |map, (id, cve)| map[cve] = id; map }
  end

  def compute_color(churn)
    big_week = 1_000.0 # >1k SLOC changed? That's a big week.
    churn = churn.clamp(0, big_week)
    # this didn't work but I like the idea of a linear gradient here.
    # perc = (churn / big_week).clamp(0.1, 0.9) * 100 # don't want pure white or black
    # "hsl(0,0,#{perc}%)"
    return case churn.to_i
           when 0..250
             '#dae2ed'
           when 251..500
             '#5f606d'
           when 501..750
             '#32333c'
           when 751..1_000
             '#1a1a20'
           end
  end

end
