require 'json'
require 'date'

class WeeklyReportEvents

  def cve_from_filename(f)
    f.match(/.*(?<cve>CVE-.+-.+)-weekly.json/)[:cve]
  end

  def generate(repo_path)
    logger = Logger.new(STDOUT, progname: 'data:events:weeklies')
    events = []
    tags =   []
    vuln_events = []
    cooks_tag = add_cooks_tag
    logger.info "Parsing JSON weeklies"
    Dir["#{repo_path}/commits/weeklies/*.json"].each do |file|
      json = File.open(file) { |f| JSON.load(f) }
      v = Vulnerability.find_by(cve: cve_from_filename(file))
      if v.nil?
        logger.warn "WARNING: weekly report for #{cve_from_filename(file)}, but vuln not found"
      else
        num_devs = 0
        new_events = []
        json.each do |_week, report|
          new_events << overall_report_event(v, report)
          new_events << new_developers_event(v, report)
          new_events << ownership_change(v, report)
          new_events << revert(v, report)
          new_events << refactor(v, report)
          num_devs += report['new_developers'].size
        end
        tags << too_many_cooks(v, cooks_tag, num_devs) if num_devs >= 10
        v.notes['num_devs'] = num_devs
        v.save
        vuln_events += new_events.compact.map do |e|
          VulnerabilityEvent.new(event: e, vulnerability: v)
        end
        events += new_events.compact
      end
    end
    logger.info "Inserting event and tag data"
    events.compact!
    Event.import events
    VulnerabilityEvent.import vuln_events
    VulnerabilityTag.import tags
  end

  # Always create an event for a week with commits
  def overall_report_event(v, report)
    churn = report['insertions'].to_i + report['deletions'].to_i
    num_devs = report['developers'].size
    Event.new(
      style: overall_report_style,
      event_type: 'changes',
      title: "#{report['commits']} commits by #{num_devs} developers, " +
                      "#{churn} lines changed",
      description: <<~EOS ,
        During the 7-day period starting on #{nice_date(report)}, the code that was
        impacted by this vulnerability had #{report['commits']} commits by
        #{num_devs} different developers.

        Those changes involved #{report['insertions']} line(s) inserted
        and #{report['deletions']} line(s) deleted, impacting a total of
        #{report['files'].size} source code file(s). The impacted files were:

        #{report['files'].map { |f| " * `" + f + '`'  }.join("\n") }
      EOS
      date: report['date']
    )
  end

  def new_developers_event(v, report)
    return nil unless report['new_developers'].any?
    num_new_devs = report['new_developers'].size
    Event.new(
      style: new_dev_style,
      date: report['date'],
      event_type: 'new developer',
      title: "#{num_new_devs} new developers",
      description: <<~EOS
        On the week of #{nice_date(report)},
        #{num_new_devs} developer(s) committed to this code, and they have
        never committed to this code before.

        Familiarity is difficult to gain with code. Even for the best
        developers, contributing to a piece of source code for the first time
        means that they must understand the design decisions from previous
        developers, any issues the code has had historically, and the coding
        style. Thus, the first commit any developer makes is risky.

        Furthermore, research has shown a strong correlation between code that
        had many developers and code with vulnerabilities. Learn more about
        that effect in the tag "Lesson: Too Many Cooks".
      EOS
    )
  end

  def ownership_change(v, report)
    return nil unless report['ownership_change']
    Event.new(
      style: ownership_style,
      date: report['date'],
      title: "Code ownership changed",
      event_type: 'owner change',
      description: <<~EOS
        On the week of #{nice_date(report)}, changes were made to a Chromium
        OWNERS file related to the vulnerable code.

        In Chromium, an OWNER is someone who has the power to approve commits
        in the code review system. They wield significant influence on the
        project. Changes in code ownership can indicate team restructuring by
        adopting new members or removing members.
      EOS
    )
  end

  def revert(v, report)
    return nil unless report['reverts'].to_i > 0
    Event.new(
      style: revert_style,
      date: report['date'],
      title: "#{report['reverts']} revert commits",
      event_type: 'reverts',
      description: <<~EOS
        On the week of #{nice_date(report)}, #{report['reverts']} commits
        mention the word "Revert". A revert is when a commit is reversed,
        indicating that developers have decided to roll back changes that were
        originally approved and integrated into the system.

        A single revert may not be an issue, but a long history of many reverts
        could mean a breakdown in communication or a lack of agreement on design
        or requirements.
      EOS
    )
  end

  def refactor(v, report)
    return nil unless report['refactors'].to_i > 0
    Event.new(
      style: refactor_style,
      date: report['date'],
      title: "#{report['refactor']} refactor commits",
      event_type: 'refactors',
      description: <<~EOS
        On the week of #{nice_date(report)}, #{report['refactors']} commits
        mention the word "Refactor". Refactoring is the practice of improving
        the maintainability of the code without changing its functionality.
        Code is easier to secure when it is easier to maintain.

        Problems can occur when refactoring is ignored for long periods of time.
        Also, a lack of well-maintained unit tests can lead to refactoring
        introducing unintended functionality changes.
      EOS
    )
  end

  def too_many_cooks(v, cooks_tag, num_devs)
    VulnerabilityTag.new(
      tag: cooks_tag,
      vulnerability: v,
      note: "#{num_devs} different developers have made commits to the files fixed for this vulnerability."
    )
  end

  def ownership_style
    @ownership_style ||= Style.find_or_create_by!(
      name: 'ownership style',
      icon: 'face',
      color: '#BB5093',
    )
  end

  def new_dev_style
    @new_dev_style ||= Style.find_or_create_by!(
      name: 'new_dev_style',
      icon: 'person',
      color: '#B7AADE',
    )
  end

  def overall_report_style
    @overall_report_style ||= Style.find_or_create_by!(
      name: 'overall_report_style',
      icon: 'assignment',
      color: '#bbbbbb',
    )
  end

  def revert_style
    @revert_style ||= Style.find_or_create_by!(
      name: 'revert_style',
      icon: 'compare_arrow',
      color: '#FF953D',
    )
  end

  def refactor_style
    @refactor_style ||= Style.find_or_create_by!(
      name: 'refactor_style',
      icon: 'healing',
      color: '#F4DC0C',
    )
  end

  def nice_date(report)
    DateTime.parse(report['date']).strftime('%A, %B %d, %Y')
  end

  def add_cooks_tag
    Tag.find_by(shortname: 'cooks') || Tag.create!(
      name: 'Lesson: Too Many Cooks',
      shortname: 'cooks',
      color: '#009696',
      icon: 'people',
      description: <<~EOS
        To be written.

        Provide a few paragraphs and references about how having multiple
        developers work on a piece of code increases its liklihood of having a
        vulnerability.

        Note that we used 10 as an arbitrary threshold, but it's really more of
        a spectrum.
      EOS
    )
  end

end
