require "application_system_test_case"

class Article6Test < ApplicationSystemTestCase
  setup do
    Capybara.app_host = "https://alpha.vulnerabilityhistory.org"
    Capybara.run_server = false

    @start = root_path

    @a6_title = 'What is a VCC?'
    @a6_slug = 'vccs'
    @a6_art = 'vhp-art-ice-cream-spill'
    @a6_blurb = 
    "A Vulnerability-Contributing Commit is the change to source code that is " +
    "likely the origin of a vulnerability." +
    "Finding a VCC is our attempt at finding the original mistake that was made… " +
    "and missed… that led to a vulnerability."
    @a6_tag = nil
    @a6_author = 'Andy Meneely'
    @a6_fulltext =
    "When did this first start?\n" +
    "What was the original mistake made that led to this problem?\n" +
    "These are key questions in any post-mortem discussion. To find " +
    "some answers, we look to version control systems such as Git. " +
    "Since every minute change to the system is tracked in a large " +
    "project, we can know when a chunk of code was introduced. The " +
    "feature that uses these is typically called a blame or an " +
    "annotate (e.g. git blame).\n" +
    "Software engineering researchers have long used an adapted version " +
    "of the blame algorithm called the SZZ algorithm to identify what commits " +
    "contributed to the problem. Given a commit that we accept as being the fix " +
    "for a bug, the SZZ algorithm identifies the commit(s) that first introduced those lines of code.\n" +
    "Other methods exist for this, however, the SZZ algorithm has gained popularity " +
    "because it's easy to execute. For vulnerabilities, we coined the term " +
    "\"Vulnerability-Contributing Commit\" (VCC) in our earlier work, which " +
    "since been adopted by other researchers. Some researchers call them " +
    "\"bug-inducing commits\" or \"fix-inducing changes\" or the like, although " +
    "we prefer the word \"contribute\" over \"induce\".\n" +
    "Automatically identifying a VCC is not without its faults. Here are three issues with it:\n" +
    "It's just text. The blame feature has no awareness of the programming language - " +
    "it is merely comparing text. This means that if the fix or VCC involves correcting " +
    "comments, or other refactorings, then we may get a false positive.\n" +
    "Checking code statically, not verifying behavior. Identifying the algorithm is " +
    "not attempting to confirm.\n" +
    "Where to fix something is subjective. When you fix a bug in code, you often " +
    "have many choices on how to fix it. Do you fix in the presentation layer, or " +
    "in the database schema? Do you simply filter the bad output, or redesign the module? " +
    "Or just rip out the feature entirely? For us, we assume that if the development " +
    "team has a commit that they identify as a fix, then the code they correct is assumed " +
    "to be \"wrong\", even though the notion of \"wrong\" is a subjective one. (Does your brain hurt yet?)\n" +
    "In this project, we use a combination of the SZZ algorithm and its variants to " +
    "identify VCCs, then ask our curators to confirm. By having a human look at a VCC " +
    "and fix, they can see refactorings that can be disregarded or any other potential " +
    "issues. This helps mitigate some of the the above issues to some extent, and this " +
    "approach goes much farther than the current academic literature (that we know of)."
  end

  test 'article 6 can be accessed' do
    visit @start
    gc = find '.grid-container'
    articles = gc.find(id: 'article-listing')

    # verifies image
    article = articles.all('.vhp-articles')[2]
    wrapper = article.find('.grid-x')
    article_image = wrapper.find('.blurb-art')
    assert_equal @a6_art, article_image.find('div')[:class]

    # verifies title
    header_and_text = wrapper.find('.blurb-text')
    article_title = header_and_text.find('h3')
    assert_equal @a6_title, article_title.text
    
    # verifies blurb
    article_blurb = header_and_text.all('p')
    article_blurb_text = ""
    tagged = false
    article_blurb.each do |e|
      article_blurb_text += e.text
    end
    assert_equal @a6_blurb, article_blurb_text.split(".")[0...-1].join(".") + "."

    # tests tag link works correctly
    if header_and_text.all('a').length > 1
      tag_a = header_and_text.all('a')[-2]    # assuming there is no link between the tag and full article inside the blurb
      tag_a_href = tag_a[:href]
      assert_equal @a6_tag, tag_a_href.split("/")[-1]
      tag_a.click
      assert_equal tag_a_href, current_url
      visit @start
    end

    # verifies slug
    full_article_a = header_and_text.all('a')[-1]
    full_article_a_href = full_article_a[:href]
    assert_equal @a6_slug, full_article_a_href.split("/")[-1]

    # verifies follows correct url
    full_article_a.click
    assert_equal full_article_a_href, current_url

    # verifies consistent article title
    gc = find '.grid-container'
    grid_x_title = gc.all('.grid-x')[0]
    cell_title = grid_x_title.find('.cell')
    title = cell_title.find('.centered-title')
    assert_equal @a6_title, title.text

    # verifies author
    grid_x_author = gc.all('.grid-x')[1]
    cell_author = grid_x_author.find('.cell')
    byline = cell_author.find('.title-byline')
    assert_equal @a6_author, byline.text

    # verifies consistent image
    grid_x_image = gc.all('.grid-x')[2]
    cell_image = grid_x_image.find('.cell')
    image = cell_image.find('div')
    assert_equal @a6_art, image[:class]

    # verifies correct fulltext
    grid_x_fulltext = gc.all('.grid-x')[3]
    cell_fulltext = grid_x_fulltext.find('.cell')
    assert_equal(@a6_fulltext, cell_fulltext.text)

    # if there are links in the article, follow them and make sure they work
    links = []
    cell_fulltext.all('a').each do |a|
      links << a[:href]
    end
    # if we were to do this from one loop, the 'a' elements would become "stale" - need to put them in memory first
    links.each do |link|
      puts "following external link: #{link}"
      visit link
      assert_equal link, current_url
      visit "#{@start}articles/#{@a6_slug}"
    end

    # return home
    click_link 'The Vulnerability History Project'
  end
end
