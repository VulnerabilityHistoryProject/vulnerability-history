/**
 * Created by ekbos on 12/13/2016.
 */



/**
 * Function to create the dictionary of timeline data, basically doing what getClosestDate does, but creating an object
 * This is incredibly complicated because I'm nesting data types like crazy - it looks like this:
 * dict(dateGroup: dict(data_type: list(eventAsDict)))
 * Expanded that looks like:
 *
 * {
 *  dateGroup: {
 *              data_type: [
 *                          {
 *                            "id": id,
 *                            "name": name,
 *                            "description": description,
 *                            "date": date,
 *                            "data_type": data_type
 *                           }
 *                          ]
 *             }
 * }
 *
 */
function createTimelineData() {
    var timelineData = {};
    $(".cd-timeline-block").each(function () {
        var id = $(this).find("a").attr('id');
        var name = $(this).find("#title").text().replace(/ /g, '');
        var description = $(this).find("#description").text().trim();
        var string_date = $(this).find("#date").text().trim();
        var date = getDate(string_date);
        var data_type = $(this).attr('id');

        var eventAsDict = {
            "id": id,
            "name": name,
            "description": description,
            "date": date,
            "data_type": data_type
        };
        var closestDate = getClosestDate(datePadLocations, date);
        if (timelineData[closestDate]) {
            var dataTypeDict = timelineData[closestDate];
            if (dataTypeDict[data_type]) {
                var listOfEvents = dataTypeDict[data_type];
                listOfEvents.push(eventAsDict);
                dataTypeDict[data_type] = listOfEvents;
            }
            else {
                dataTypeDict[data_type] = [eventAsDict];
            }
        }
        else {
            var dateGroup = {};
            dateGroup[data_type] = [eventAsDict];
            timelineData[closestDate] = dateGroup;
        }
    });
    return timelineData;
}


/**
 * @global timelineData
 * @global timelineDataKeys
 * Function to run through all items in the timelineData dictionary monster, and update items that aren't grouped to use
 * grouping
 */
function createGroupedObjects(timelineData) {

    var timelineDataKeys = Object.keys(timelineData); // timelineDataKeys represents the date groups
    for (var i = 0; i < timelineDataKeys.length; i++) {
        if (timelineData[timelineDataKeys[i]]) {
            var timelineTypeDict = timelineData[timelineDataKeys[i]];
            var timelineTypeKeys = Object.keys(timelineTypeDict);
            // iterate through second level dictionary and check lengths of items
            for (var j = 0; j < timelineTypeKeys.length; j++) {
                var eventsInGroup = timelineTypeDict[timelineTypeKeys[j]];
                eventsInGroup = createGroups(eventsInGroup);
                timelineTypeDict[timelineTypeKeys[j]] = eventsInGroup;

            }
            timelineData[timelineDataKeys[i]] = timelineTypeDict;
        }
    }

}



/**
 * Function to group an array of items into smaller arrays, the size of the smaller arrays is specified using groupSize
 * @param eventsInGroup - a list of all events (filtered by type) in the date span
 * @global groupSize - the size of groups to create
 */
function createGroups(eventsInGroup) {
    var oldArray = eventsInGroup;
    var newArray = [];
    var j = 0;
    for (var i = 0; i < oldArray.length; i++) {
        if (i % groupSize === 0) {
            j++
        }
        if (!newArray[j]) newArray[j] = [];
        newArray[j].push(oldArray[i])
    }
    return newArray;
}