# **Vulnerability History Project** ![VHP Tests](https://github.com/VulnerabilityHistoryProject/vulnerability-history/workflows/VHP%20Tests/badge.svg)

## **Cite This Data**

---

To cite the writing on vulnerabilityhistory.org, use: [![DOI](https://zenodo.org/badge/66301289.svg)](https://zenodo.org/badge/latestdoi/66301289)

To cite data from a specific project, use:

- Chromium [![DOI](https://zenodo.org/badge/67513158.svg)](https://zenodo.org/badge/latestdoi/67513158)
- HTTPD [![DOI](https://zenodo.org/badge/67513281.svg)](https://zenodo.org/badge/latestdoi/67513281)
- Tomcat [![DOI](https://zenodo.org/badge/166920755.svg)](https://zenodo.org/badge/latestdoi/166920755)
- Struts [![DOI](https://zenodo.org/badge/167394888.svg)](https://zenodo.org/badge/latestdoi/167394888)
- Django [![DOI](https://zenodo.org/badge/243837445.svg)](https://zenodo.org/badge/latestdoi/243837445)

## **Table of Contents**

---

- [Getting Set Up](#getting-set-up)
  - [Normal Setup](#normal-setup)
  - [With Docker](#with-docker)
    - [Common Gotchas](#common-gotchas)
    - [Testing](#testing)
    - [Running Commands](#running-commands)
    - [Reference](#reference)
- [Finding Useful Commands](#finding-useful-commands)
- [Rebuild the Database](#rebuild-the-database)
- [Reload the Production Data](#reload-the-production-data)
- [Testing VHP](#testing-vhp)
- [Useful Commands](#useful-commands)
- [Helpful Dev Tools](#helpful-dev-tools)
- [The CWE csv File](#the-cwe-csv-file)

## **Getting Set Up**

---

### **Normal Setup**

### **Normally**

- Install Ruby 3.0+
- Install NodeJS (14.x)
- Install Yarn
- Install PostgreSQL (latest - pgAdmin is also recommended)
- In PostgreSQL, create a user called "vhp" and "vhp_test". Set the permissions to "Can Log In". Create a random password and set that password for the vhp user. Put that password into secrets.yml (see next bullet). Create two databases: "vhp" and "vhp_test"
- Create a config/secrets.yml based on config/secrets.default.yml. Follow the comments in that file.
- After that, we'll need to install all of our dependencies. From the root of the repo on the command line run:

```shell
  yarn install
  bundle install
```

Then, let's set up our database and load our data:

```shell
  rails db:schema:load
  rails data:clear data:all
  rails server
```

That second one can take a while. Once the server is up, go to `http://localhost:3000` to see the site.

If you are working on the frontend, it's useful to run Webpacker's dev server:

```shell
  yarn watch
```
This speeds up rebuilding the frontend JS, CSS, etc. If you want to do a full build of webpack, do:

```shell
  yarn build
```


### **With Docker**

Building the project with Docker is meant to be an easy setup so there aren't any OS-specific issues throughout the dev process. That being said, this way of developing still needs
a lot of testing to make sure it's good to go, and I wouldn't really advise trying this unless you have some time to debug too.

#### **Common Gotchas**

- Windows Users

  If you are attempting this on Windows, it's been been noted that the way the OS interprets the `Dockerfile` will cause `docker-compose` to complain about a file not existing. Because of this, you should run the `dos2unix` command on the file before trying to run it. [This article](https://futurestud.io/tutorials/how-to-fix-exec-user-process-caused-no-such-file-or-directory-in-docker) explains better

- Directories

  The Docker convention for container naming is `foldername_imagename`. That means if we don't change our folder name from the repo and are building the `app` container, it will be named `vulnerability-history_app`, and other containers will look for this name. This naming is set up by default in `docker-compose.yml`, however if you have renamed your folder, you will want to change the references from `vulnerability-history` to whatever your folder name is (webpacker and test are two containers that will need this done). If you changed the folder to `vhp`, you would update the references to `vhp_app`.

#### **Getting Started**

You'll need docker and docker-compose on your machine to start. You can either do this by means of [Docker Desktop]() or through a package manager, though the former may be better for a visual aid - plus it comes with docker-compose.

Once this is done, go to the directory and type `docker-compose build`. You should see things happening on the terminal! This command builds the image we need to run the VHP container.

```shell
➜  vulnerability-history git:(system_tests_docker) ✗ docker-compose build
...
Successfully built 988dcf0b62ce
Successfully tagged vulnerability-history_app:latest
```

Once this command finishes up, it's time to pull from docker hub. Run `docker-compose up` in the same container. This pulls all other necessary images and starts them up.

Your next destination will be to `localhost:2345`, where our pgAdmin container is exposed. Here, you'll give the login credentials supplied in your `docker-compose.yml` file to log in to both pgAdmin and the server itself. In the future, these may be refactored into local environment variables, but for now, you can edit them in the file itself under the `environment` section of `pgadmin` and `postgres`.

Once logged in, you need to create two databases, `vhp` and `vhp_test`, and their respective users in the server, both with passwords supplied in your `secrets.yml` file, and the permission `Can Log In`.

The last thing to do is kill the containers with `^C` and run two commands to build the database:

```shell
  docker-compose run --rm app rails db:schema:load
  docker-compose run --rm app rails data:clear data:all
```

These will spin up a temporary container to build the database. Once these processes are done, do one more `docker-compose up`. This time if you visit `localhost:3000`, there should be a VHP site waiting for you!

Now I'll go over each of the containers as they appear in `docker-compose.yml`.

- **_redis_**

  Redis helps with the server and db - don't put too much thought into it.

- **_postgres_**

  This is the container for our database. It uses the latest version released on dockerhub, which may cause issues in the future.

- **_pgadmin_**

  I like using pgAdmin to have a better visual representation of the database running. The instructions for setting up the database are the same as listed in the normal configuration. I set it to run on port `2345`.



- **_app_**


  This is the main rails server running on port `3000`.

- **_webpacker_**

These will spin up a temporary container to build the database. Once these processes are done, do one more `docker-compose up`. This time if you visit `localhost:3000`, there should be a VHP site waiting for you!

Now I'll go over each of the containers as they appear in `docker-compose.yml`.

- **_redis_**

  Redis helps with the server and db - don't put too much thought into it.

- **_postgres_**

  This is the container for our database. It uses the latest version released on dockerhub, which may cause issues in the future.

- **_pgadmin_**

  I like using pgAdmin to have a better visual representation of the database running. The instructions for setting up the database are the same as listed in the normal configuration. I set it to run on port `2345`.

- **_app_**

  This is the main rails server running on port `3000`.

- **_webpacker_**

  You can comment this one out if you want, but this is better for web development, so I prefer to leave it in. This runs `ruby bin/webpack-dev-server` and communicates with the VHP container. The only downside is that it adds some time to the startup process.

- **_selenium_**

  This is only useful for system testing, and you can comment this service out if you won't be doing any of that. More about system tests are in the `Testing` section.

- **_test_**

  The testing container does not continuously run after startup. It only runs when the user wants to run tests, which will be covered in the testing section.

#### **Testing**

Regular tests can be run by running `docker-compose run --rm test <command>`

This tells docker-compose to start up a `test` container that removes itself whenever done testing. The test command can be run just like normal after that.

System testing requires one extra tool. Any VNC client will do, but I use VNC Viewer. The system tests will run fine, however to actually see the browser (if you care), you'll need to be able to get into the VNC server running on the `selenium` container. The VNC server itself runs on port `5900`, so you'll need to point the client to `0.0.0.0:5900`. Now you can observe the browser during the system tests.

#### **Running Commands**

You've already seen an example of how to run commands inside a container. The preferred way of doing this is by using `docker-compose run --rm <container_name> <command>`. This spins up the container of your choice to run any command you supply it. It's like a one-time terminal command. The `--rm` flag is not required, but it's useful for not keeping around any containers that would be otherwise using memory.

If you prefer a more interactive shell, you can always connect to the container itself, either through Docker Desktop, or by connecting through your terminal.

#### **Reference**

This was pretty tricky to get working, if you care to know how to do this here are some articles that really helped me out.

[Rails Development with Docker](https://medium.com/better-programming/rails-6-development-with-docker-55437314a1ad)

[Running a Rails App with Webpacker and Docker](https://medium.com/@dirkdk/running-a-rails-app-with-webpacker-and-docker-8d29153d3446)

[Testing Rails Apps in Docker Containers](http://tomazy.com/blog/2017/05/testing-rails-app-in-docker-containers/)

[Using Rails 5.1 System Tests with Docker](https://medium.com/@pacuna/using-rails-5-1-system-tests-with-docker-a90c52ed0648)

[How to run a Rails 6 application using Docker Compose](https://techandfi.com/how-to-run-rails-6-application-docker-compose/)

## Finding Useful Commands

# Having trouble installing pg gem?

As of September 2021, we had some new issues with installing the pg gem on Windows.

After installing Postgres, you might need to do `gem install pg -- --with-pg-config=<path to pg_config>` (don't forget those middle `--`).

This seemed to address it. https://github.com/ged/ruby-pg/issues/365, specifically running `ridk exec pacman -S mingw-w64-x86_64-postgresql` as administrator, then do `gem install pg`

Be sure to check out the Ruby pg README and their issues for anything that might come up: https://github.com/ged/ruby-pg

# Powershell not letting you run scripts?

This gives a good explanation: https://tecadmin.net/powershell-running-scripts-is-disabled-system/

One solution to that is to do your administrative installs using CMD instead of Powershell.

# Finding useful commands

To find out useful commands for working with data:

`rails -T`

## **Rebuild the Database**

---

If `db/schema.rb` has changed recently, you'll need to rebuild the database:

`rails db:schema:load`

## **Reload the Production Data**

---

To load the production data from Chromium and HTTPD:

`rails data:all`

This is the equivalent of running:

`rails data:clear data:chromium data:httpd data:writing`

To skip the clone from github,

`rails data:chromium:nogit`
`rails data:httpd:nogit`

## **Testing VHP**

---

### **System Tests**

System tests are actively being worked on and always improving. That being said, it is worth explaining how we do system tests at the moment.

As of Rails 5.1, system tests are a part of the framework itself using [Capybara](https://github.com/teamcapybara/capybara) for testing. These system tests are meant to simulate user actions and navigation through the site to make sure everything performs at it should. These tests can be found in the `test/system` folder.

Because of some behavior issues with AJAX on our tests, we perform them against the running server as opposed to one spun up by Capybara. This means that to run system tests on your own, there should be a local server running for Capybara to find.

## **Useful Commands**

---

```shell
  rails server
  rails console
```

## **Helpful Dev Tools**

---

Here's a list of our favorite tools for developing this:

- [Atom](https://atom.io/) or [VS Code](https://code.visualstudio.com/)
- [Git Extensions](https://gitextensions.github.io/) for Windows Git clients
- [JSONView](https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc?hl=en) to format JSON responses in your browser

## **The CWE csv File**

---

To download a copy of the CWE csv file, go to https://cwe.mitre.org/data/downloads.html and download
the latest Research Concepts csv listed under 'Navigate CWE'.

Place the csv file in lib/taggers/resources/cwes.csv

Note: this is incomplete, and some CWEs are not included in this that we need. Running a data rebuild will tell you which ones we're missing. In that case, get the info manually and put them into the `manual_cwes.csv` file.

On line 677 of the file, near the end of the line, change the double quotes around `"<script"` to single quotes `'script'`


# Updating the OpenAPI Spec

We're using the OpenAPI specification for defining our RESTFul API. This allows us to be put in various registries, as generate some nice docs for us, and some other potential good things.

Our specification is in `public/openapi.yml`, making it publicly available. So don't put any secrets in there!

We're using [Redocly](https://redocly.com/) tools to generate our docs do linting on our spec.

  * `redocly lint` will check our `openapi.yml` file and find problems.
  * `redocly lint --generate-ignore-file` if we're happy with all the warnings and errors, we can generate an ignore file if we want

## Useful tools

OpenAPI is complicated. These guides and tools will help:

  * [Rails Guides for Testing](https://guides.rubyonrails.org/testing.html#integration-testing), specifically integration testing
  * [Swagger Definition Objects Generator](https://roger13.github.io/SwagDefGen/) was a huge time saver because it infers the existing API response schema for you
  * [Minivore](https://github.com/alekseyl/mini-apivore) is the gem we use to use our integration tests to test against our OpenAPI spec
  * [Swagger.io](https://swagger.io/docs/specification/)
  * [inspector.swagger.io](https://inspector.swagger.io/builder#) can be somewhat useful