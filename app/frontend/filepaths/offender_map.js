import $ from 'jquery'
import * as d3 from 'd3'
import _ from 'lodash'
import {vulnProject, vulnName, ellipsizedFilepath} from 'global/dataToPrettyStrings'

export function OffenderMap(){
    this.project_id = 0; //project_id 0 is "all" projects
    this.cutoff = 2; // number of fixes we need to actually show this. TODO make this configurable

    this.init = function() {
      this.initSVG();
      this.registerHandlers();
      return this;
    }    

    this.initSVG = function(){
      const width = 700 //internal coordinates
      const height = 700
      this.radius = Math.min(width, height) / 2;
      this.svg = d3.select("#offender-map-svg")
                  // .append("svg:svg")
                  // // svg width and height NOT set for responsiveness here!!
                  // // viewBox is the internal coordinate system and then this
                  // // scales to fit its container
                  // .attr("viewBox", `0 0 ${width} ${height}`)
                  // .attr("preserveAspectRatio", "xMidYMid meet")
      this.g = this.svg.append('g')
          .attr('transform', `translate(${width / 2}, ${height / 2 })`);
      this.addHelpText('Click to zoom', 20);
      this.addHelpText('Ctrl+Click leaf node to visit', 35);
      this.addHelpText('Click center to go up', 50);
      this.addToolTip();
    }

    this.setData = function(offenders, projects) {
      this.offenders = offenders
      this.projects = projects
      this.projectJSONToMap()
      this.prependProjectName()
      this.addProjectLegends()
      this.rebuild()
    }

    // e.g. Chromium's foo/bar.c --> chromium/foo/bar.c
    this.prependProjectName = function() {
      this.offenders = this.offenders.map( function(f) {
        f.filepath = `${f.subdomain}/${f.filepath}`;
        return f
      })
    }

    // Draw the help text at the given y coordinate 
    this.addHelpText = function(str, y){
      this.svg.append('text')
              .attr('x', 480)
              .attr('y', y)
              .attr('font-size', 15)
              .attr('style', 'fill: #aaa')
              .html(str)
    }

    this.addToolTip = function(){
        this.tooltip = this.svg.append('text')
                               .attr('x', 0)
                               .attr('y', 680)
                               .attr('font-size', 11)
                               .attr('font-family', "Consolas, 'Liberation Mono', Courier, monospace")
                               .attr('style', 'fill: #000')
    }

    this.registerHandlers = function() {
      $('select.project-choice').on("change", (e) => {
        this.project_id = $("select.project-choice option:selected")
                             .attr('value');
        this.rebuild();
      });
    }

    this.addProjectLegends = function() {
      let y = 126
      let svg = this.svg
      this.projects.forEach(function(p){
        svg.append('text')
           .attr('x', 0)
           .attr('y', y)
           .attr('font-size', 15)
           .attr('font-weight', 'bold')
           .style('fill', p.bg_color)
           .html(p.name)
        y -= 17
      })
    }


    this.rebuild = function() {
      const cluster = this.rebuildDataHierarchy();
      this.rebuildVisualization(cluster);
    }

    // Convert from the JSON response from the API to a formatted needed for //
    // D3's hierarchical clustering.
    // 1. Filter out according to project & num_fixes cutoff
    // 2. Prepend the project name to the filepath
    // 2. Parentify - add parent directories to the data and keep it sorted
    // 3. Clusterify - convert to D3's clustered hierarchy data structure,
    // 4. Partition - append data structure with layout X's & Y's
    this.rebuildDataHierarchy = function(){
      const filtered = this.offenders.filter( //accept only filepaths
        f => (f.project_id == this.project_id || this.project_id == 0)
             && f.num_fixes >= this.cutoff
      );
      const cluster = this.clusterify(this.parentify(filtered));
      var partition = d3.partition();
      partition(cluster);
      return cluster
    }

    /*
    Given a D3 partition()'d cluster hierarchy, draw stuff partition() computed
    X's and Y's for us, but it's in its own coordinate space AND uses a
    traditional rectangle-based hierarchy. So we need to map those numbers to a
    circular pattern in our own coordinate system. Then do styling with colors
    and other visual fanciness.
    */
    this.rebuildVisualization = function(cluster) {
      this.x = d3.scaleLinear().range([0, 2 * Math.PI]);
      this.y = d3.scaleSqrt().range([0, this.radius]);

      this.arc = d3.arc() //from rectangles to divided circles
        .startAngle(d => Math.max(0, Math.min(2 * Math.PI, this.x(d.x0))))
        .endAngle(d => Math.max(0, Math.min(2 * Math.PI, this.x(d.x1))))
        .innerRadius(d => Math.max(0, this.y(d.y0)))
        .outerRadius(d => Math.max(0, this.y(d.y1)));

      const colorScale = d3.interpolateRgb('#774b70','#ce6dbd')
      const cluster_depth = cluster.height;
      const color = d3.scaleSequential(colorScale).domain([0,cluster_depth]);

      this.g.selectAll('path').remove(); // remove previous if there
      this.g.selectAll('path')
        .data(cluster.descendants())
        .enter().append('path')
        .attr("d", this.arc)
        .style('stroke', '#fff')
        .style('stroke-width', '0.25px')
        .style("fill", d => this.computeColor(d.data.project_id, d.depth))
        .on("click", d => this.clicked(d, this))
        .on("mouseover", d => this.mouseovered(d, this))
        .attr("transform", "scale(0.05)")
        .transition().attr("transform", "scale(1.1)").duration(200) //ms
        .transition().attr("transform", "scale(1.0)").duration(300) //ms
        ;
    }

    // D3's stratify method needs the parent directories, and sorted
    // e.g. filepath: foo/bar/baz.c
    //         ---converts too---
    //     /
    //     /foo
    //     /foo/bar
    //     /foo/bar/baz.c
    // We also need to make sure this is all unique,
    // (e.g. there's only one /foo), so we use hashes
    this.parentify = function(offenderList) {
      const parents = { '/' : 0 }; // init with root directory, purple
      offenderList.forEach(function(entry) {
        let filepath = entry.filepath;
        while(filepath.indexOf('/') > 0) {
          filepath = filepath.substring(0, filepath.lastIndexOf('/'));
          parents[filepath] = entry.project_id;
        }
      });
      for(let key in parents) {
        offenderList.push({
          'filepath' : key,
          'id' : null, // there is no filepath ID for this, it's a directory!
          'num_fixes' : null, //init this to null - it'll be updated later
          'project_id' : parents[key]
        });
      }
      offenderList.sort(function(a,b){ // sort these alphabetically
        return (a.filepath > b.filepath) ? 1 :
                ((b.filepath > a.filepath) ? -1 : 0);
      });
      return offenderList;
    }

    // Given filepath data with parents, generate a cluster hierarchy
    // Also: add up the values of each parent
    this.clusterify = function(data){
      const stratify = d3
        .stratify()
        .parentId(function (d) {
          if(d.filepath == '/') return null;
          if(d.filepath.indexOf('/') > 0) { // non-root file
            return d.filepath.substring(0, d.filepath.lastIndexOf('/'));
          } else { //root file
            return '/';
          }
        })
        .id(function (d) {
          return d.filepath;
        });
      let root = stratify(data);
      root.sum(function(d) { return d.num_fixes });
      return root;
    }

    // Ctrl+Click means we go to the page
    // Click means we zoom in
    this.clicked = function(d, map) {
      if(d3.event.ctrlKey && d.data.slug !== undefined) {
        location.href = `/filepaths/${d.data.slug}`
      } else {
        this.zoom(d, map)
      }
    }

    // Zooming is accomplished by changing how the xy's are interpolated
    this.zoom = function(d, map) {
      map.svg.transition()
        .duration(750) // ms
        .tween("scale", function() {
          var xd = d3.interpolate(map.x.domain(), [d.x0, d.x1]),
              yd = d3.interpolate(map.y.domain(), [d.y0, 1]),
              yr = d3.interpolate(map.y.range(), [d.y0 ? 20 : 0, map.radius]);
          return function(t) { map.x.domain(xd(t)); map.y.domain(yd(t)).range(yr(t)); };
        })
        .selectAll("path")
        .attrTween("d", function(d) { return function() { return map.arc(d); }; });
    }

    // Init a lookup table for project colors
    this.projectJSONToMap = function() {
      const reducer = function(pcMap, jsonRow) {
        pcMap[jsonRow.id] = jsonRow.bg_color
        return pcMap
      }
      this.projectColors = _.reduce(this.projects, reducer, {0 : '#F53663'})
    }

    // Actually use the lookup table.

    this.computeColor = function(project_id, _depth){
      return this.projectColors[project_id]
    }

    this.mouseovered = function(d, self){
      if(d.data.id) { //is this a filepath?
          self.tooltip
              .style("visibility", "visible")
              .style("opacity", "100")
              .style("top", d3.event.pageY + "px")
              .style("left", d3.event.pageX + "px")
              .html(`<a href=/filepaths/${d.data.slug}>${ellipsizedFilepath(d.data.filepath, 20, 75)[1]}</a>`)
      } else {  // or a directory?
          self.tooltip
              .style("visibility", "visible")
              .style("opacity", "100")
              .style("top", d3.event.pageY + "px")
              .style("left", d3.event.pageX + "px")
              .html(ellipsizedFilepath(d.data.filepath, 20, 75)[1]);
      }
    }
}
