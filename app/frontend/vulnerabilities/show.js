import $ from "jquery";
import { timelines } from "./timelines";
import SimpleDate from "../global/simpleDate";
import { vhpMarkdown } from "../global/vhpMarkdown";
import { ellipsizedFilepath } from "../global/dataToPrettyStrings";
import * as d3 from "d3";

function initHTimeline(defaultZoom = "vcc_to_fix") {
  window.filters = [];

  var settings = {
    margin: { top: 10, bottom: 45, left: 60, right: 60 },
    timelineHeight: 16,
    chicHeight: 14,
    chicWidth: 20,
    cLowerLim: 13,
    cUpperLim: 15,
    xAxisHeight: 43,
    fade_ms: 700,
    defaultZoomValue: defaultZoom,
  };

  var h = new timelines(settings);
  h.init();
  return h;
}

/** sort the events by date oldest to newest
 * @param events - array of hashes with a "date" object
 * @returns {*} - array of sorted event hashes
 */
function sortEvents(events) {
  events.sort(function (a, b) {
    return b.date.getTime() - a.date.getTime();
  });
  return events;
}

function populateHTimeline(hTimeline, vulnEvents) {
  if (vulnEvents.length == 0) {
    return;
  }

  var zoomLevels = new Map();
  const icon_str = '<i class="vhp-icon-zoom-in">/</i>';
  zoomLevels.set("Origin to fix", "vcc_to_fix");
  zoomLevels.set("All Events", "first_to_last");
  zoomLevels.set("All Time", "all");

  hTimeline.populateTimelines(vulnEvents, zoomLevels);

  $("body").on("change", ".htimeline_toggle", () => hTimeline.filterToggled());

  // the dropdown list isn't guaranteed to exist at this point, so we put the
  // event handler on the body with an additional selector of "#zoom-dropdown"
  // that will be checked only after the event is triggered.

  $("body").on("change", "#zoom-dropdown", function (event) {
    switch (event.currentTarget.value) {
      case "all":
        hTimeline.zoomChanged(new Date(0), new Date());
        break;
      case "vcc_to_fix":
        var minDate, maxDate;
        for (var i = 0; i < vulnEvents.length; i++) {
          // in case no fix event(s) exist, set a default for maxdate to be
          // the last non-release event
          if (vulnEvents[i].event_type != "release") {
            maxDate = new Date(vulnEvents[i].date);
            break;
          }
        }

        for (var i = vulnEvents.length - 1; i >= 0; i--) {
          // in case no vcc event(s) exist, set a default for mindate to be
          // the first non-release event
          if (vulnEvents[i].event_type != "release") {
            minDate = new Date(vulnEvents[i].date);
            break;
          }
        }

        for (var i = 0; i < vulnEvents.length; i++) {
          if (vulnEvents[i].event_type == "fix") {
            // get last fix
            maxDate = new Date(vulnEvents[i].date);
            break;
          }
        }

        for (var i = vulnEvents.length - 1; i >= 0; i--) {
          if (vulnEvents[i].event_type == "vcc") {
            // get first vcc
            minDate = new Date(vulnEvents[i].date);
            break;
          }
        }

        hTimeline.zoomChanged(minDate, maxDate);
        break;
      case "first_to_last":
        for (var i = vulnEvents.length - 1; i >= 0; i--) {
          var type = vulnEvents[i].event_type;
          if (
            type != "same directory" &&
            type != "same cwe" &&
            type != "release"
          ) {
            var minDate = new Date(vulnEvents[i].date);
            break;
          }
        }

        for (var i = 0; i < vulnEvents.length; i++) {
          if (vulnEvents[i].event_type != "release") {
            var maxDate = new Date(vulnEvents[i].date);
            break;
          }
        }

        hTimeline.zoomChanged(minDate, maxDate);
        break;

      default:
        hTimeline.zoomChanged(new Date(0), new Date());
    }
  });

  $("#zoom-dropdown").change();
}

function populateVTimeline(vulnEvents) {
  function pluralize(count, text) {
    return count > 1 ? text + "s" : text;
  }

  for (let e of vulnEvents) {
    var notes = e.notes;
    var accordion = "";
    if (notes) {
      var template = `
        <ul class="accordion vertical menu" data-accordion-menu>
          <li><a href="#">:menu_name:</a>
            <ul class="menu vertical nested">
              :menu_items:
            </ul>
          </li>
        </ul>`;

      if (notes.hasOwnProperty("commits")) {
        var commits = notes.commits;
        var temp_acc = template.replace(
          ":menu_name:",
          pluralize(Object.keys(commits).length, "Commit")
        );
        commit_rows = [];
        Object.keys(commits).map(function (h) {
          var short_hash = h.substring(0, 12);
          if (commits[h] == "") {
            commit_rows.push(
              `<li><a class="disabled">${short_hash} (Untracked)</a></li>`
            );
          } else {
            commit_rows.push(
              `<li><a href='/commits/${h}'>${short_hash} - ${commits[h]}</a></li>`
            );
          }
        });
        temp_acc = temp_acc.replace(":menu_items:", commit_rows.join(""));
        accordion += temp_acc;
      }

      if (notes.hasOwnProperty("files")) {
        var files = notes.files;
        var temp_acc = template.replace(
          ":menu_name:",
          pluralize(Object.keys(files).length, "Impacted File")
        );
        // some files aren't found in the db. in that case, disable the link.
        files = files.map(
          (f) =>
            `<li><a ${
              f.slug == "" ? 'class="disabled"' : `href="/filepaths/${f.slug}"`
            }>${f.file}</a></li>`
        );
        temp_acc = temp_acc.replace(":menu_items:", files.join(""));
        accordion += temp_acc;
      }

      if (notes.hasOwnProperty("developers")) {
        var info =
          '<i class="vhp-icon-info"></i><span>To protect their ' +
          "privacy, developers are given animal-related nicknames.</span>";
        var devs = notes.developers;
        var temp_acc = template.replace(
          ":menu_name:",
          pluralize(devs.length, "Developer") + info
        );

        devs = devs.map((d) =>
          d == null
            ? `<li><a class="disabled">Unidentified Developer</a></li>`
            : `<li><a href='/developers/${d}'>${d}</a></li>`
        );
        temp_acc = temp_acc.replace(":menu_items:", devs.join(""));
        accordion += temp_acc;
      }
    }

    const block = $("#vtimeline-template").clone();
    block.attr("data-id", e.id);
    block.attr("data-type", e.event_type);
    block.find(".vtimeline-anchor").attr("id", "event_" + e.id);
    if (e.event_type == "release") {
      block.attr("id", "release_block_" + e.id);
      block.find(".vtimeline-anchor").attr("id", "release_" + e.id);
    } else {
      block.attr("id", "event_block_" + e.id);
      block.find(".vtimeline-anchor").attr("id", "event_" + e.id);
    }
    block.find(".title").html(e.title);
    block.find(".description").html(vhpMarkdown(e.description) + accordion);
    block.find(".description").addClass("shortened"); // applies fading
    block.find(".isodate").html(e.date);
    const event_date = new SimpleDate(e.date).timestampFormat();
    block.find(".pretty_date").html(event_date);
    block.find(".timeline-icon").html(e.icon);
    block.find(".vtimeline-img").css("background-color", e.color);
    $("#vtimeline").append(block);
    block.show();

    // hide "see more" and "see less" elements if the description is small
    // enough or if there is a trivial amount of overflow. note that at this
    // point in the code each description has already been shortened, so the
    // scrollheight and clientheight properties below will reflect that.
    const desc = block.find(".description");
    if (desc.prop("scrollHeight") - desc.prop("clientHeight") < 75) {
      desc.removeClass("shortened");
      desc.css("height", "initial");
      block.find(".see_more").remove();
      block.find(".see_less").remove();
    }
  }
  $("#vtimeline-template").remove(); // remove so we start upper-left

  // expand event description when clicked
  $(".see_more").click(function () {
    $(this).attr("hidden", "true");
    $(this).parent().find(".description").css("height", "initial");
    $(this).parent().find(".description").toggleClass("shortened");
    $(this).parent().find(".see_less").removeAttr("hidden");
  });

  // shorten event description when clicked
  $(".see_less").click(function () {
    $(this).attr("hidden", "true");
    $(this).parent().find(".description").css("height", "");
    $(this).parent().find(".description").toggleClass("shortened");
    $(this).parent().find(".see_more").removeAttr("hidden");
  });

  // create all of the accordion menus for the numerous links on the page
  // e.g. commits and files
  $(".accordion").each(function (i) {
    var e = new Foundation.AccordionMenu($(this));
  });
}

function populateMatrix(events) {
  // vulnerability_events = events;
  // gathers a list of top contributors on the project
  var top_contributors = (data) => {
    var map = [];
    for (var i = 0; i < data.length; i++) {
      // checks if the author already exists in map[]
      if (map.some((e) => e.author === data[i].CommitAuthor)) {
        map.filter((e) => e.author === data[i].CommitAuthor)[0].count += 1; // increases the count of frequency of commits
      } else {
        // adds new author to map
        map.push({
          author: data[i].CommitAuthor,
          count: 1,
        });
      }
    }

    // returns top 12 overriding developers
    return map
      .sort((a, b) => {
        return b.age - a.age;
      })
      .map((e) => e.author)
      .slice(0, 12);
  };

  // fixme should probably be a churn function
  var overwrite_log = {
    start_date: events[events.length - 1].Date, // fixme is this really the start of the vulnerability?
    end_date: events[0].Date,
    top_contributors: top_contributors(events),
    commit_history: events,
  };

  // mini lane data
  var laneLength = overwrite_log.top_contributors.length,
    timeBegin = new Date(overwrite_log.start_date).getTime(),
    timeEnd = new Date(overwrite_log.end_date).getTime();

  var dimensions = [100, 15, 0, 120], // [top, right, bottom, left]
    width = 500 - dimensions[1] - dimensions[3],
    height = 600 - dimensions[0] - dimensions[2],
    miniHeight = laneLength * 12 + 50,
    miniWidth = 10,
    mainHeight = height - miniHeight - 50;

  var laneDomain = [];
  var laneRange = [];
  var j = 0;
  for (var i = 0; i < width; i += width / laneLength) {
    laneDomain.push(j);
    laneRange.push(i);
    j++;
  }

  const author_colorscale = d3
    .scaleOrdinal(d3.schemePaired)
    .domain(overwrite_log.top_contributors);

  // scales
  var x = d3.scaleLinear().domain([timeBegin, timeEnd]).range([0, width]);
  var x1 = d3.scaleLinear().range([0, width]);
  var x3 = d3.scaleLinear().domain(laneDomain).range(laneRange);
  var y1 = d3.scaleLinear().domain([0, laneLength]).range([0, mainHeight]);
  var y2 = d3.scaleLinear().domain([0, laneLength]).range([0, miniHeight]);

  // main graph class
  var chart = d3
    .selectAll("#matrix")
    .append("svg")
    .attr("width", width + dimensions[1] + dimensions[3])
    .attr("height", height + dimensions[0] + dimensions[2])
    .attr("class", "chart");
  chart
    .append("defs")
    .append("clippath")
    .attr("id", "clip")
    .append("rect")
    .attr("width", width)
    .attr("height", mainHeight);

  // matrix
  var main = chart
    .append("g")
    .attr("transform", "translate(" + dimensions[3] + "," + dimensions[0] + ")")
    .attr("width", width)
    .attr("height", mainHeight)
    .attr("class", "main");

  var itemRects = main
    .append("g")
    .attr("clip-path", "url(#clip)")
    .attr("class", "matrix");

  // code graph
  var code = chart
    .append("g")
    .attr(
      "transform",
      "translate(" + (dimensions[3] + width + dimensions[3]) + "," + 0 + ")"
    )
    .attr("width", 300)
    .attr("height", mainHeight + dimensions[0] + 50)
    .attr("class", "codegraph");

  // mini timeline
  var mini = chart
    .append("g")
    .attr(
      "transform",
      "translate(" +
        dimensions[3] +
        "," +
        (mainHeight + dimensions[0] + 50) +
        ")"
    )
    .attr("width", width)
    .attr("height", miniHeight)
    .attr("class", "mini");

  // gathers the username from the given address
  var slice_username = (e) => e.split("@")[0];

  // top username labels
  main
    .append("g")
    .selectAll(".lanetext")
    .data(overwrite_log.top_contributors)
    .enter()
    .append("text")
    .text((d) => slice_username(d))
    .attr("text-anchor", "start")
    .attr("transform", (d, i) => {
      var x = x3(i) + width / laneLength / 2;
      var y = -50;
      return "translate(" + x + "," + y + "), rotate(-20)";
    })
    .attr("dy", ".5ex")
    .attr("class", "lanetext");

  // side username labels
  main
    .append("g")
    .selectAll(".lanetext")
    .data(overwrite_log.top_contributors)
    .enter()
    .append("text")
    .text((d) => slice_username(d))
    .attr("x", -dimensions[1])
    .attr("y", (d, i) => y1(i + 0.5))
    .attr("dy", ".5ex")
    .attr("text-anchor", "end")
    .attr("class", "lanetext");

  // mini timeline username labels
  mini
    .append("g")
    .selectAll(".lanetext")
    .data(overwrite_log.top_contributors)
    .enter()
    .append("text")
    .text((d) => slice_username(d))
    .attr("x", -dimensions[1])
    .attr("y", (d, i) => y2(i + 0.6))
    .attr("dy", ".5ex")
    .attr("text-anchor", "end")
    .attr("class", "lanetext");

  // function to turn date into int for scale
  function dateify(date) {
    return new Date(date).getTime();
  }

  // mini item rects
  mini
    .append("g")
    .selectAll("miniitems")
    .data(overwrite_log.commit_history)
    .enter()
    .append("rect")
    .attr(
      "class",
      (d) => "miniItem" + overwrite_log.top_contributors.indexOf(d.CommitAuthor)
    )
    .attr("x", (d) => x(dateify(d.Date))) // x(d.start)
    .attr(
      "y",
      (d) =>
        y2(overwrite_log.top_contributors.indexOf(d.CommitAuthor) + 0.5) - 5
    )
    .attr("width", miniWidth)
    .attr("height", 15)
    .attr("fill", (d, i) => author_colorscale(d.CommitAuthor));

  // brush for highlighting over items on mini timeline
  var brush = d3
    .brushX(x)
    .extent([
      [0, 0],
      [width, miniHeight],
    ])
    .on("start brush", display);

  // adds brush to timeline
  mini
    .append("g")
    .attr("class", "x brush")
    .call(brush)
    .call(brush.move, [0, width])
    .selectAll("rect")
    .attr("y", 1)
    .attr("height", miniHeight - 1);

  var filenames_container = code.append("g").attr("class", "fn_container");

  let codeContainer = code
    .append("g")
    .attr("x", 0)
    .attr("y", 50)
    .attr("width", 300)
    .attr("height", mainHeight + dimensions[0] + miniHeight)
    .attr("class", "codecontainer");

  let codeField = codeContainer
    .append("rect")
    .attr("x", 0)
    .attr("y", 50)
    .attr("width", 300)
    .attr("height", mainHeight + dimensions[0] + miniHeight)
    .attr("class", "codegraph");

  const filename_tab_x = 0;
  const filename_tab_y = 15;
  const filename_tab_width = 150;
  const filename_tab_height = 35;

  const filename_tab_lr_width = 50;

  var filename_tab = filenames_container.append("g");
  filename_tab
    .append("rect")
    .attr("x", filename_tab_x)
    .attr("y", filename_tab_y)
    .attr("width", filename_tab_width)
    .attr("height", filename_tab_height)
    .attr("class", "filename-tab");

  var filename_tab_left = filenames_container.append("g");
  filename_tab_left
    .append("rect")
    .attr("x", filename_tab_width)
    .attr("y", filename_tab_y)
    .attr("width", filename_tab_lr_width)
    .attr("height", filename_tab_height)
    .attr("class", "filename-tab-lr left");
  filename_tab_left
    .append("text")
    .text("<")
    .attr("x", filename_tab_width + filename_tab_lr_width / 2)
    .attr("y", filename_tab_y + filename_tab_height / 2)
    .attr("text-anchor", "middle")
    .attr("dominant-baseline", "middle")
    .attr("class", "nav-arrow");

  var filename_tab_right = filenames_container.append("g");
  filename_tab_right
    .append("rect")
    .attr("x", filename_tab_width + filename_tab_lr_width)
    .attr("y", filename_tab_y)
    .attr("width", filename_tab_lr_width)
    .attr("height", filename_tab_height)
    .attr("class", "filename-tab-lr right");
  filename_tab_right
    .append("text")
    .text(">")
    .attr(
      "x",
      filename_tab_width + filename_tab_lr_width + filename_tab_lr_width / 2
    )
    .attr("y", filename_tab_y + filename_tab_height / 2)
    .attr("text-anchor", "middle")
    .attr("dominant-baseline", "middle")
    .attr("class", "nav-arrow");

  // displays the matrix, timeline, and code bar
  function display() {
    const selection = d3.brushSelection(this);
    var minExtent = selection[0],
      maxExtent = selection[1],
      visItems = overwrite_log.commit_history.filter(
        (d) =>
          x(dateify(d.Date)) < maxExtent &&
          x(dateify(d.Date)) + miniWidth > minExtent
      ),
      visFiles = [];

    for (i = 0; i < visItems.length; i++) {
      for (j = 0; j < visItems[i].ChurnFiles.length; j++) {
        if (
          visFiles.some((e) => e.file === visItems[i].ChurnFiles[j].FileName)
        ) {
          visFiles
            .filter((e) => e.file === visItems[i].ChurnFiles[j].FileName)[0]
            .overwriting_authors.push({
              author: visItems[i].CommitAuthor,
              lines_changed:
                visItems[i].ChurnFiles[j].InteractiveChurn != null
                  ? {
                      type: "interactive",
                      data: visItems[i].ChurnFiles[j].InteractiveChurn,
                    }
                  : { type: "self", data: visItems[i].ChurnFiles[j].SelfChurn },
            });
        } else {
          visFiles.push({
            file: visItems[i].ChurnFiles[j].FileName,
            original_author: visItems[i].CommitAuthor,
            overwriting_authors: new Array(),
          });
        }
      }
    }

    var colorscale = d3
      .scaleSequential(d3.interpolateGreys)
      .domain([0, overwrite_log.commit_history.length]);

    const len_contributors = overwrite_log.top_contributors.length;
    let ow_matrix = new Array(len_contributors);
    for (i = 0; i < len_contributors; i++) {
      ow_matrix[i] = new Array(len_contributors);
    }
    for (i = 0; i < len_contributors; i++) {
      for (j = 0; j < len_contributors; j++) {
        ow_matrix[i][j] = [i, 0];
      }
    }

    x1.domain([minExtent, maxExtent]);

    for (i = 0; i < visFiles.length; i++) {
      for (j = 0; j < visFiles[i].overwriting_authors.length; j++) {
        ow_matrix[
          overwrite_log.top_contributors.indexOf(visFiles[i].original_author)
        ][
          overwrite_log.top_contributors.indexOf(
            visFiles[i].overwriting_authors[j].author
          )
        ][1]++;
      }
    }

    // fill in the matrix
    var rows = itemRects
      .selectAll(".row")
      .data(ow_matrix)
      .join("g")
      .attr("x", 0)
      .attr("y", (d, i) => y1(i))
      .attr("width", width)
      .attr("height", mainHeight / laneLength)
      .attr("class", "row");
    var squares = rows
      .selectAll(".cell")
      .data((d) => d)
      .join("rect")
      .attr("x", (d, i) => x3(i)) // x3()
      .attr("y", (d) => y1(d[0])) // y1()
      .attr("width", width / laneLength)
      .attr("height", mainHeight / laneLength)
      .attr("fill", (d) => colorscale(d[1]))
      .attr("class", "cell");

    rows.exit().remove();
    squares.exit().remove();

    let file_position = 0;

    const update_file = (file) => {
      filenames_container
        .selectAll(".file")
        .data([file])
        .join("text")
        .text((d) => console.log(ellipsizedFilepath(d.file, 5, 15)[1]))
        .attr("x", 5)
        .attr("y", 36)
        .attr("class", "file");
      // if (file.overwriting_authors.length > 0) {
      //   let unplaced_lines = codeContainer
      //     .selectAll(".codelinegroup")
      //     .data(file.overwriting_authors)
      //     .join("g")
      //     // .attr("width")
      //     .attr("fill", (d) => author_colorscale(d.author))
      //     // .attr("fill", "white")
      //     // .attr("fill") !! color should be the author's given color in the graph
      //     // .data((d) => console.log(d))
      //     // .attr("x", (d) => console.log(d))
      //     // .attr("y", (d) => d * 10)
      //     // .attr("width", 20)
      //     // .attr("height", 10)
      //     .attr("class", "codelinegroup");
      //   // let placed_lines = unplaced_lines
      //   //   .selectAll(".codeline")
      //   //   .data((d) => d.lines_changed.data)
      //   //   .join("rect")
      //   //   .attr("fill", "blue")
      //   //   .attr("x", 10)
      //   //   .attr("y", (d) => d * 10 + filename_tab_height)
      //   //   .attr("width", 200)
      //   //   .attr("height", 10)
      //   //   .attr("class", "codeline");
      // }
    };

    $(".left").on("click", () => {
      file_position - 1 < 0
        ? (file_position = visFiles.length - 1)
        : (file_position -= 1);
      update_file(visFiles[file_position]);
    });

    $(".right").on("click", () => {
      file_position + 1 == visFiles.length
        ? (file_position = 0)
        : (file_position += 1);
      update_file(visFiles[file_position]);
    });

    // update_file(visFiles[file_position]);
  }
}

$(document).ready(function () {
  var hTimeline = initHTimeline();
  var events = []; // global to the page for resizing

  $.when(
    $.ajax(`/api/vulnerabilities/${vulnerability_id}/events`),
    $.ajax(`/api/vulnerabilities/${vulnerability_id}`),
    $.ajax(`/api/projects/${project_id}/releases`)
  ).then((vulnEvents, vuln, releases) => {
    for (let e of vulnEvents[0]) {
      // here we convert rails ar date string to js date object
      // different browsers treat time parsing differently
      // so we need to specify the date format string.

      e.date = new SimpleDate(e.date).createJSDate();
      events.push(e); // add to global events
    }

    // fixme disabled because this was breaking other code
    // for (let e of releases[0]) {
    //   e.event_type = e.notes.event_type;
    //   e.title = e.notes.title;
    //   e.description = e.notes.description;
    //   e.style_color = e.notes.color;
    //   e.style_icon = e.notes.icon;
    //   e.notes = {}
    //   e.date = new date(moment(e.date_released, 'yyyy-mm-dd'));
    //   events.push(e); // add to global events
    // }

    events = sortEvents(events);
    $("#vtimeline_loading").remove();
    populateVTimeline(events);

    $("#htimeline-loading").hide();
    populateHTimeline(hTimeline, events);

    $.when(
      $.ajax(`/api/commits/${vuln[0].notes.vccs[0].commit}`),
      $.ajax(`/api/commits/${vuln[0].notes.fixes[0].commit}`),
      $.ajax("/output-ref.json")
    ).then((vcc, fix, output) => {
      // these are the files that we care about
      const relevant_files = (start, end) => {
        let common = [];
        for (let f in start.notes.filepaths) {
          if (f in end.notes.filepaths) {
            common.push(f);
          }
        }
        return common;
      };

      // const rf = relevant_files(vcc[0], fix[0]);
      // FIXME will factor in project id's later
      const relevant_commits = (start, end, commits) => {
        // let commits = [];
        // for (c in commits)
        // console.log(project_id);
      };

      // relevant_commits(vcc[0], fix[0], output[0]);
      // console.log(output[0]);
      populateMatrix(output[0]);
    });
    // $.getJSON("/output.json", (data) => populateMatrix(events, vuln, data));
  });

  window.onresize = function () {
    // maintain zoom level when resizing
    var zoomvalue = $("#zoom-dropdown").val();

    $("#htimeline-loading").show();
    hTimeline = initHTimeline(zoomvalue);
    $("#htimeline-loading").hide();
    populateHTimeline(hTimeline, events);
  };
});
