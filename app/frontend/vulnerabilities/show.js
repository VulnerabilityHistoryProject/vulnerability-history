import $ from "jquery";
import { timelines } from "./timelines";
import SimpleDate from "../global/simpleDate";
import { vhpMarkdown } from "../global/vhpMarkdown";
import { ellipsizedFilepath } from "../global/dataToPrettyStrings";
import * as d3 from "d3";

function initHTimeline(defaultZoom = "vcc_to_fix") {
  window.filters = [];

  var settings = {
    margin: { top: 10, bottom: 45, left: 60, right: 60 },
    timelineHeight: 16,
    chicHeight: 14,
    chicWidth: 20,
    cLowerLim: 13,
    cUpperLim: 15,
    xAxisHeight: 43,
    fade_ms: 700,
    defaultZoomValue: defaultZoom,
  };

  var h = new timelines(settings);
  h.init();
  return h;
}

/** sort the events by date oldest to newest
 * @param events - array of hashes with a "date" object
 * @returns {*} - array of sorted event hashes
 */
function sortEvents(events) {
  events.sort(function (a, b) {
    return b.date.getTime() - a.date.getTime();
  });
  return events;
}

function populateHTimeline(hTimeline, vulnEvents) {
  if (vulnEvents.length == 0) {
    return;
  }

  var zoomLevels = new Map();
  const icon_str = '<i class="vhp-icon-zoom-in">/</i>';
  zoomLevels.set("Origin to fix", "vcc_to_fix");
  zoomLevels.set("All Events", "first_to_last");
  zoomLevels.set("All Time", "all");

  hTimeline.populateTimelines(vulnEvents, zoomLevels);

  $("body").on("change", ".htimeline_toggle", () => hTimeline.filterToggled());

  // the dropdown list isn't guaranteed to exist at this point, so we put the
  // event handler on the body with an additional selector of "#zoom-dropdown"
  // that will be checked only after the event is triggered.

  $("body").on("change", "#zoom-dropdown", function (event) {
    switch (event.currentTarget.value) {
      case "all":
        hTimeline.zoomChanged(new Date(0), new Date());
        break;
      case "vcc_to_fix":
        var minDate, maxDate;
        for (var i = 0; i < vulnEvents.length; i++) {
          // in case no fix event(s) exist, set a default for maxdate to be
          // the last non-release event
          if (vulnEvents[i].event_type != "release") {
            maxDate = new Date(vulnEvents[i].date);
            break;
          }
        }

        for (var i = vulnEvents.length - 1; i >= 0; i--) {
          // in case no vcc event(s) exist, set a default for mindate to be
          // the first non-release event
          if (vulnEvents[i].event_type != "release") {
            minDate = new Date(vulnEvents[i].date);
            break;
          }
        }

        for (var i = 0; i < vulnEvents.length; i++) {
          if (vulnEvents[i].event_type == "fix") {
            // get last fix
            maxDate = new Date(vulnEvents[i].date);
            break;
          }
        }

        for (var i = vulnEvents.length - 1; i >= 0; i--) {
          if (vulnEvents[i].event_type == "vcc") {
            // get first vcc
            minDate = new Date(vulnEvents[i].date);
            break;
          }
        }

        hTimeline.zoomChanged(minDate, maxDate);
        break;
      case "first_to_last":
        for (var i = vulnEvents.length - 1; i >= 0; i--) {
          var type = vulnEvents[i].event_type;
          if (
            type != "same directory" &&
            type != "same cwe" &&
            type != "release"
          ) {
            var minDate = new Date(vulnEvents[i].date);
            break;
          }
        }

        for (var i = 0; i < vulnEvents.length; i++) {
          if (vulnEvents[i].event_type != "release") {
            var maxDate = new Date(vulnEvents[i].date);
            break;
          }
        }

        hTimeline.zoomChanged(minDate, maxDate);
        break;

      default:
        hTimeline.zoomChanged(new Date(0), new Date());
    }
  });

  $("#zoom-dropdown").change();
}

function populateVTimeline(vulnEvents) {
  function pluralize(count, text) {
    return count > 1 ? text + "s" : text;
  }

  for (let e of vulnEvents) {
    var notes = e.notes;
    var accordion = "";
    if (notes) {
      var template = `
        <ul class="accordion vertical menu" data-accordion-menu>
          <li><a href="#">:menu_name:</a>
            <ul class="menu vertical nested">
              :menu_items:
            </ul>
          </li>
        </ul>`;

      if (notes.hasOwnProperty("commits")) {
        var commits = notes.commits;
        var temp_acc = template.replace(
          ":menu_name:",
          pluralize(Object.keys(commits).length, "Commit")
        );
        commit_rows = [];
        Object.keys(commits).map(function (h) {
          var short_hash = h.substring(0, 12);
          if (commits[h] == "") {
            commit_rows.push(
              `<li><a class="disabled">${short_hash} (Untracked)</a></li>`
            );
          } else {
            commit_rows.push(
              `<li><a href='/commits/${h}'>${short_hash} - ${commits[h]}</a></li>`
            );
          }
        });
        temp_acc = temp_acc.replace(":menu_items:", commit_rows.join(""));
        accordion += temp_acc;
      }

      if (notes.hasOwnProperty("files")) {
        var files = notes.files;
        var temp_acc = template.replace(
          ":menu_name:",
          pluralize(Object.keys(files).length, "Impacted File")
        );
        // some files aren't found in the db. in that case, disable the link.
        files = files.map(
          (f) =>
            `<li><a ${
              f.slug == "" ? 'class="disabled"' : `href="/filepaths/${f.slug}"`
            }>${f.file}</a></li>`
        );
        temp_acc = temp_acc.replace(":menu_items:", files.join(""));
        accordion += temp_acc;
      }

      if (notes.hasOwnProperty("developers")) {
        var info =
          '<i class="vhp-icon-info"></i><span>To protect their ' +
          "privacy, developers are given animal-related nicknames.</span>";
        var devs = notes.developers;
        var temp_acc = template.replace(
          ":menu_name:",
          pluralize(devs.length, "Developer") + info
        );

        devs = devs.map((d) =>
          d == null
            ? `<li><a class="disabled">Unidentified Developer</a></li>`
            : `<li><a href='/developers/${d}'>${d}</a></li>`
        );
        temp_acc = temp_acc.replace(":menu_items:", devs.join(""));
        accordion += temp_acc;
      }
    }

    const block = $("#vtimeline-template").clone();
    block.attr("data-id", e.id);
    block.attr("data-type", e.event_type);
    block.find(".vtimeline-anchor").attr("id", "event_" + e.id);
    if (e.event_type == "release") {
      block.attr("id", "release_block_" + e.id);
      block.find(".vtimeline-anchor").attr("id", "release_" + e.id);
    } else {
      block.attr("id", "event_block_" + e.id);
      block.find(".vtimeline-anchor").attr("id", "event_" + e.id);
    }
    block.find(".title").html(e.title);
    block.find(".description").html(vhpMarkdown(e.description) + accordion);
    block.find(".description").addClass("shortened"); // applies fading
    block.find(".isodate").html(e.date);
    const event_date = new SimpleDate(e.date).timestampFormat();
    block.find(".pretty_date").html(event_date);
    block.find(".timeline-icon").html(e.icon);
    block.find(".vtimeline-img").css("background-color", e.color);
    $("#vtimeline").append(block);
    block.show();

    // hide "see more" and "see less" elements if the description is small
    // enough or if there is a trivial amount of overflow. note that at this
    // point in the code each description has already been shortened, so the
    // scrollheight and clientheight properties below will reflect that.
    const desc = block.find(".description");
    if (desc.prop("scrollHeight") - desc.prop("clientHeight") < 75) {
      desc.removeClass("shortened");
      desc.css("height", "initial");
      block.find(".see_more").remove();
      block.find(".see_less").remove();
    }
  }
  $("#vtimeline-template").remove(); // remove so we start upper-left

  // expand event description when clicked
  $(".see_more").click(function () {
    $(this).attr("hidden", "true");
    $(this).parent().find(".description").css("height", "initial");
    $(this).parent().find(".description").toggleClass("shortened");
    $(this).parent().find(".see_less").removeAttr("hidden");
  });

  // shorten event description when clicked
  $(".see_less").click(function () {
    $(this).attr("hidden", "true");
    $(this).parent().find(".description").css("height", "");
    $(this).parent().find(".description").toggleClass("shortened");
    $(this).parent().find(".see_more").removeAttr("hidden");
  });

  // create all of the accordion menus for the numerous links on the page
  // e.g. commits and files
  $(".accordion").each(function (i) {
    var e = new Foundation.AccordionMenu($(this));
  });
}

// long function to populate the overrite matrix and sidebar
function populateMatrix(events) {
  // gathers a list of top contributors on the project
  var top_contributors = (data) => {
    var map = [];
    for (var i = 0; i < data.length; i++) {
      // checks if the author already exists in map[]
      if (map.some((e) => e.author === data[i].CommitAuthor)) {
        map.filter((e) => e.author === data[i].CommitAuthor)[0].count += 1; // increases the count of frequency of commits
      } else {
        // adds new author to map
        map.push({
          author: data[i].CommitAuthor,
          count: 1,
        });
      }
    }

    // returns top 12 overriding developers. 12 because that seems to be an alright number to try and fit on the page
    return map
      .sort((a, b) => {
        return b.age - a.age;
      })
      .map((e) => e.author)
      .slice(0, 12);
  };

  // fixme - should probably be a churn function
  var overwrite_log = {
    start_date: events[events.length - 1].Date, // fixme is this really the start of the vulnerability?
    end_date: events[0].Date,
    top_contributors: top_contributors(events),
    commit_history: events,
  };

  // mini lane data
  // lane_length : the number of top contributors to a project
  // time_begin : when the vulnerability first started
  // time_end : when the vulnerability ended according to the data
  var lane_length = overwrite_log.top_contributors.length,
    time_begin = new Date(overwrite_log.start_date).getTime(),
    time_end = new Date(overwrite_log.end_date).getTime();

  // dimensions : [top, right, bottom, left]
  // width : the width of the matrix + minibar
  // height : the height of the matrix + minibar
  // mini_width : width of the items in the mini bar
  // mini_height : height of the mini bar
  // main_height : height of the matrix
  var dimensions = [100, 15, 0, 120],
    width = 500 - dimensions[1] - dimensions[3],
    height = 600 - dimensions[0] - dimensions[2],
    mini_width = 10,
    mini_height = lane_length * 12 + 50,
    main_height = height - mini_height - 50;

  // lane_domain_plots : a list of x coordinates for matrix squares
  // lane_range_plots : a list of y coordinates for matrix squars
  var lane_domain_plots = [];
  var lane_range_plots = [];
  var j = 0;
  for (var i = 0; i < width; i += width / lane_length) {
    lane_domain_plots.push(j);
    lane_range_plots.push(i);
    j++;
  }

  // this little function assigns colors to authors for the visualization
  const author_colorscale = d3
    .scaleOrdinal(d3.schemePaired)
    .domain(overwrite_log.top_contributors);

  // minibar_commit_scale : scale to help with plotting commits on dates in the minibar
  // x1 :
  // matrix_x_axis_scale : scale to plot points along the x axis of the matrix
  // matrix_y_axis_scale : scale to plot points along the y axis of the matrix
  // minibar_y_axis_scale : scale to plot points along the y asis if the minibar
  var minibar_commit_scale = d3
    .scaleLinear()
    .domain([time_begin, time_end])
    .range([0, width]);
  var x1 = d3.scaleLinear().range([0, width]);
  var matrix_x_axis_scale = d3
    .scaleLinear()
    .domain(lane_domain_plots)
    .range(lane_range_plots);
  var matrix_y_axis_scale = d3
    .scaleLinear()
    .domain([0, lane_length])
    .range([0, main_height]);
  var minibar_y_axis_scale = d3
    .scaleLinear()
    .domain([0, lane_length])
    .range([0, mini_height]);

  // css class for the matrix + minibar
  // width : width + x offsets
  // height : height + y offsets
  var chart = d3
    .selectAll("#matrix")
    .append("svg")
    .attr("width", width + dimensions[1] + dimensions[3])
    .attr("height", height + dimensions[0] + dimensions[2])
    .attr("class", "chart");

  // main class for matrix
  // width : width
  // height : main_height
  var main = chart
    .append("g")
    .attr("transform", "translate(" + dimensions[3] + "," + dimensions[0] + ")")
    .attr("width", width)
    .attr("height", main_height)
    .attr("class", "main");

  // class for the matrix 2D matrix
  var matrix = main.append("g").attr("class", "matrix");

  // code graph
  // width : width
  // height : main_height + y offsets
  var code = chart
    .append("g")
    .attr(
      "transform",
      "translate(" + (dimensions[3] + width + dimensions[3]) + "," + 0 + ")"
    )
    .attr("width", width)
    .attr("height", main_height + dimensions[0] + 50)
    .attr("class", "codegraph");

  // mini timeline
  // width : width
  // height : mini_height
  var mini = chart
    .append("g")
    .attr(
      "transform",
      "translate(" +
        dimensions[3] +
        "," +
        (main_height + dimensions[0] + 50) +
        ")"
    )
    .attr("width", width)
    .attr("height", mini_height)
    .attr("class", "mini");

  // gathers the username from the given address by cutting the username from the email account given
  var slice_username = (e) => e.split("@")[0];

  // top username labels
  // gathered from the list of top contributors
  main
    .append("g")
    .selectAll(".lanetext")
    .data(overwrite_log.top_contributors)
    .enter()
    .append("text")
    .text((d) => slice_username(d))
    .attr("text-anchor", "start")
    .attr("transform", (d, i) => {
      var x = matrix_x_axis_scale(i) + width / lane_length / 2;
      var y = -50;
      return "translate(" + x + "," + y + "), rotate(-20)";
    })
    .attr("dy", ".5ex")
    .attr("class", "lanetext");

  // side username labels
  // same as the top labels but on the side
  main
    .append("g")
    .selectAll(".lanetext")
    .data(overwrite_log.top_contributors)
    .enter()
    .append("text")
    .text((d) => slice_username(d))
    .attr("x", -dimensions[1])
    .attr("y", (d, i) => matrix_y_axis_scale(i + 0.5))
    .attr("dy", ".5ex")
    .attr("text-anchor", "end")
    .attr("class", "lanetext");

  // mini timeline username labels
  // same as the last two but for the minibar
  mini
    .append("g")
    .selectAll(".lanetext")
    .data(overwrite_log.top_contributors)
    .enter()
    .append("text")
    .text((d) => slice_username(d))
    .attr("x", -dimensions[1])
    .attr("y", (d, i) => minibar_y_axis_scale(i + 0.6))
    .attr("dy", ".5ex")
    .attr("text-anchor", "end")
    .attr("class", "lanetext");

  // function to turn dates into int for scales for the mini timeline
  function dateify(date) {
    return new Date(date).getTime();
  }

  // mini item rects
  // uses the date provided in the commit data to plot points on the timeline
  mini
    .append("g")
    .selectAll()
    .data(overwrite_log.commit_history)
    .enter()
    .append("rect")
    .attr(
      "class",
      (d) => "miniItem" + overwrite_log.top_contributors.indexOf(d.CommitAuthor)
    )
    .attr("x", (d) => minibar_commit_scale(dateify(d.Date)))
    .attr(
      "y",
      (d) =>
        minibar_y_axis_scale(
          overwrite_log.top_contributors.indexOf(d.CommitAuthor) + 0.5
        ) - 5
    )
    .attr("width", mini_width)
    .attr("height", 15)
    .attr("fill", (d, i) => author_colorscale(d.CommitAuthor));

  // brush for highlighting over items on mini timeline
  var brush = d3.brushX(minibar_commit_scale).extent([
    [0, 0],
    [width + mini_width, mini_height],
  ]);

  // adds brush to timeline
  mini
    .append("g")
    .attr("class", "x brush")
    .call(brush)
    .call(brush.move, [0, width + mini_width])
    .selectAll("rect")
    .attr("y", 1)
    .attr("height", mini_height - 1);

  var filenames_container = code.append("g").attr("class", "fn_container");

  let codeContainer = code
    .append("g")
    .attr("x", 0)
    .attr("y", 50)
    .attr("width", 300)
    .attr("height", main_height + dimensions[0] + mini_height)
    .attr("class", "codecontainer");

  codeContainer
    .append("rect")
    .attr("x", 0)
    .attr("y", 50)
    .attr("width", 350)
    .attr("height", main_height + dimensions[0] + mini_height)
    .attr("class", "codegraph");

  const filename_tab_x = 0;
  const filename_tab_y = 15;
  const filename_tab_width = 280;
  const filename_tab_height = 35;

  const filename_tab_lr_width = 35;

  var filename_tab = filenames_container.append("g");
  filename_tab
    .append("rect")
    .attr("x", filename_tab_x)
    .attr("y", filename_tab_y)
    .attr("width", filename_tab_width)
    .attr("height", filename_tab_height)
    .attr("class", "filename-tab");

  var filename_tab_left = filenames_container.append("g");
  filename_tab_left
    .append("rect")
    .attr("x", filename_tab_width)
    .attr("y", filename_tab_y)
    .attr("width", filename_tab_lr_width)
    .attr("height", filename_tab_height)
    .attr("class", "filename-tab-lr left");
  filename_tab_left
    .append("text")
    .text("<")
    .attr("x", filename_tab_width + filename_tab_lr_width / 2)
    .attr("y", filename_tab_y + filename_tab_height / 2)
    .attr("text-anchor", "middle")
    .attr("dominant-baseline", "middle")
    .attr("class", "nav-arrow");

  var filename_tab_right = filenames_container.append("g");
  filename_tab_right
    .append("rect")
    .attr("x", filename_tab_width + filename_tab_lr_width)
    .attr("y", filename_tab_y)
    .attr("width", filename_tab_lr_width)
    .attr("height", filename_tab_height)
    .attr("class", "filename-tab-lr right");
  filename_tab_right
    .append("text")
    .text(">")
    .attr(
      "x",
      filename_tab_width + filename_tab_lr_width + filename_tab_lr_width / 2
    )
    .attr("y", filename_tab_y + filename_tab_height / 2)
    .attr("text-anchor", "middle")
    .attr("dominant-baseline", "middle")
    .attr("class", "nav-arrow");

  brush.on("start brush", display);
  display();

  // displays the matrix, timeline, and code bar
  function display() {
    const selection = this ? d3.brushSelection(this) : [0, width + mini_width];
    var min_extent = selection[0],
      max_extent = selection[1],
      visItems = overwrite_log.commit_history.filter(
        (d) =>
          minibar_commit_scale(dateify(d.Date)) < max_extent &&
          minibar_commit_scale(dateify(d.Date)) + mini_width > min_extent
      ),
      visFiles = [];
    console.log(min_extent);
    console.log(max_extent);

    for (i = 0; i < visItems.length; i++) {
      for (j = 0; j < visItems[i].ChurnFiles.length; j++) {
        if (
          visFiles.some((e) => e.file === visItems[i].ChurnFiles[j].FileName)
        ) {
          visFiles
            .filter((e) => e.file === visItems[i].ChurnFiles[j].FileName)[0]
            .overwriting_authors.push({
              author: visItems[i].CommitAuthor,
              lines_changed:
                visItems[i].ChurnFiles[j].InteractiveChurn != null
                  ? {
                      type: "interactive",
                      data: visItems[i].ChurnFiles[j].InteractiveChurn,
                    }
                  : { type: "self", data: visItems[i].ChurnFiles[j].SelfChurn },
            });
        } else {
          visFiles.push({
            file: visItems[i].ChurnFiles[j].FileName,
            original_author: visItems[i].CommitAuthor,
            overwriting_authors: new Array(),
          });
        }
      }
    }

    var colorscale = d3
      .scaleSequential(d3.interpolateGreys)
      .domain([0, overwrite_log.commit_history.length]);

    const len_contributors = overwrite_log.top_contributors.length;
    let ow_matrix = new Array(len_contributors);
    for (i = 0; i < len_contributors; i++) {
      ow_matrix[i] = new Array(len_contributors);
    }
    for (i = 0; i < len_contributors; i++) {
      for (j = 0; j < len_contributors; j++) {
        ow_matrix[i][j] = [i, 0];
      }
    }

    x1.domain([min_extent, max_extent]);

    for (i = 0; i < visFiles.length; i++) {
      for (j = 0; j < visFiles[i].overwriting_authors.length; j++) {
        ow_matrix[
          overwrite_log.top_contributors.indexOf(visFiles[i].original_author)
        ][
          overwrite_log.top_contributors.indexOf(
            visFiles[i].overwriting_authors[j].author
          )
        ][1]++;
      }
    }

    // fill in the matrix
    var rows = matrix
      .selectAll(".row")
      .data(ow_matrix)
      .join("g")
      .attr("x", 0)
      .attr("y", (d, i) => matrix_y_axis_scale(i))
      .attr("width", width)
      .attr("height", main_height / lane_length)
      .attr("class", "row");
    var squares = rows
      .selectAll(".matrix_cell")
      .data((d) => d)
      .join("rect")
      .attr("x", (d, i) => matrix_x_axis_scale(i)) // matrix_x_axis_scale()
      .attr("y", (d) => matrix_y_axis_scale(d[0])) // matrix_y_axis_scale()
      .attr("width", width / lane_length)
      .attr("height", main_height / lane_length)
      .attr("fill", (d) => colorscale(d[1]))
      .attr("class", "matrix_cell");

    rows.exit().remove();
    squares.exit().remove();

    let file_position = 0;

    let num_lines = 200; // for now

    const update_file = (file) => {
      filename_tab
        .selectAll(".file")
        .data([file])
        .join("text")
        .text((d) => ellipsizedFilepath(d.file, 10, 15)[1]) // set to 10, but for a path prefix > 10, this will have to be changed to a bigger number
        .attr("x", 5)
        .attr("y", 36)
        .attr("class", "file");
      if (file.overwriting_authors.length > 0) {
        console.log(file.overwriting_authors);
        let unplaced_lines = codeContainer
          .selectAll(".codelinegroup")
          .data(file.overwriting_authors)
          .join("g")
          // .attr("width")
          // .attr("fill", (d) => author_colorscale(d.author))
          // .attr("fill", "white")
          // .attr("fill") !! color should be the author's given color in the graph
          // .data((d) => console.log(d))
          // .attr("x", (d) => console.log(d))
          // .attr("y", (d) => d * 10)
          // .attr("width", 20)
          .attr("class", "codelinegroup");

        // this is where the data is converted to actual visible lines in the code field
        unplaced_lines
          .selectAll(".codeline")
          .data((d) => d.lines_changed.data)
          .join("g")
          .append("rect")
          .attr("fill", (d) => author_colorscale(d % 10))
          .attr("x", 0)
          .attr(
            "y",
            (d) =>
              d * ((main_height + dimensions[0] + mini_height) / num_lines) +
              filename_tab_height
          )
          .attr("width", 350)
          .attr("height", 10) // (main_height + dimensions[0] + mini_height) / num_lines)
          .attr("class", "codeline");

        // unplaced_lines
        //   .selectAll(".codeline")
        //   .data((d) => d.lines_changed.data)
        //   .append("g")
        //   .append("text")
        //   .text((d) => d)
        //   .attr("x", 0)
        //   .attr("y", (d) => d * 10 + filename_tab_height);
      }
    };

    // why do these get called 5 times?
    $(".left").on("click", () => {
      file_position - 1 < 0
        ? (file_position = visFiles.length - 1)
        : (file_position -= 1);
      update_file(visFiles[file_position]);
    });

    $(".right").on("click", () => {
      file_position + 1 == visFiles.length
        ? (file_position = 0)
        : (file_position += 1);
      update_file(visFiles[file_position]);
    });

    update_file(visFiles[file_position]);
  }
}

$(document).ready(function () {
  var hTimeline = initHTimeline();
  var events = []; // global to the page for resizing

  $.when(
    $.ajax(`/api/vulnerabilities/${vulnerability_id}/events`),
    $.ajax(`/api/vulnerabilities/${vulnerability_id}`),
    $.ajax(`/api/projects/${project_id}/releases`)
  ).then((vulnEvents, vuln, releases) => {
    for (let e of vulnEvents[0]) {
      // here we convert rails ar date string to js date object
      // different browsers treat time parsing differently
      // so we need to specify the date format string.

      e.date = new SimpleDate(e.date).createJSDate();
      events.push(e); // add to global events
    }

    // fixme disabled because this was breaking other code
    // for (let e of releases[0]) {
    //   e.event_type = e.notes.event_type;
    //   e.title = e.notes.title;
    //   e.description = e.notes.description;
    //   e.style_color = e.notes.color;
    //   e.style_icon = e.notes.icon;
    //   e.notes = {}
    //   e.date = new date(moment(e.date_released, 'yyyy-mm-dd'));
    //   events.push(e); // add to global events
    // }

    events = sortEvents(events);
    $("#vtimeline_loading").remove();
    populateVTimeline(events);

    $("#htimeline-loading").hide();
    populateHTimeline(hTimeline, events);

    $.when(
      $.ajax(`/api/commits/${vuln[0].notes.vccs[0].commit}`),
      $.ajax(`/api/commits/${vuln[0].notes.fixes[0].commit}`),
      $.ajax("/output-ref.json")
    ).then((vcc, fix, output) => {
      // these are the files that we care about
      const relevant_files = (start, end) => {
        let common = [];
        for (let f in start.notes.filepaths) {
          if (f in end.notes.filepaths) {
            common.push(f);
          }
        }
        return common;
      };

      // const rf = relevant_files(vcc[0], fix[0]);
      // FIXME will factor in project id's later
      const relevant_commits = (start, end, commits) => {
        // let commits = [];
        // for (c in commits)
        // console.log(project_id);
      };

      // relevant_commits(vcc[0], fix[0], output[0]);
      // console.log(output[0]);
      populateMatrix(output[0]);
    });
    // $.getJSON("/output.json", (data) => populateMatrix(events, vuln, data));
  });

  window.onresize = function () {
    // maintain zoom level when resizing
    var zoomvalue = $("#zoom-dropdown").val();

    $("#htimeline-loading").show();
    hTimeline = initHTimeline(zoomvalue);
    $("#htimeline-loading").hide();
    populateHTimeline(hTimeline, events);
  };
});
