import * as d3 from 'd3'

/* Data from CSV
Vulnerabilities,CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer,100
Vulnerabilities,CWE-121: Stack-based Buffer Overflow,20
Vulnerabilities,CWE-200: Information Exposure,20
CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer,CVE-2004-0751,100
CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer,CVE-2004-0747,100
CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer,CVE-2008-6998,100
CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer,CVE-2010-0663,100
CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer,CVE-2010-3415,100
CWE-121: Stack-based Buffer Overflow,CVE-2008-6998,20
CWE-200: Information Exposure,CVE-2010-0663,20
CVE-2004-0751,Tag: Lesson,12.5
CVE-2004-0751,Tag: Lifetime(1-2 Years),12.5
CVE-2004-0751,Tag: VCC,12.5
CVE-2004-0751,Tag: Fix(Small),12.5
CVE-2004-0751,Tag: Language (C),12.5
CVE-2004-0751,Tag: Discovered Externally,12.5
CVE-2004-0751,Tag: HTTPD Subsystem(modules/ssl/ssl_engine_io.c),12.5
CVE-2004-0751,Tag: Project(HTTPD),12.5
CVE-2004-0747,Tag: Lesson,10
CVE-2004-0747,Tag: Lifetime(2-5 Years),10
CVE-2004-0747,Tag: Fix(Big),10
CVE-2004-0747,Tag: Discovered Externally,10
CVE-2004-0747,Tag: Discovered Manually,10
CVE-2004-0747,Tag: Util,10
CVE-2004-0747,Tag: VCC,10
CVE-2004-0747,Tag: Project(HTTPD),10
CVE-2004-0747,Tag: HTTPD Subsystem(server),10
CVE-2004-0747,Tag: Language (C),10
CVE-2008-6998,Tag: Lesson,14.28
CVE-2008-6998,Tag: Lifetime(30 - 90 Days),14.28
CVE-2008-6998,Tag: Fix(Small),14.28
CVE-2008-6998,Tag: VCC,14.28
CVE-2008-6998,Tag: Project(Chromium),14.28
CVE-2008-6998,Tag: Language (C++),14.28
CVE-2008-6998,Tag: Chromium subsystem(url_elider),14.28
CVE-2010-0663,Tag: Lesson,11.11
CVE-2010-0663,Tag: Lifetime(1-2 Years),11.11
CVE-2010-0663,Tag: Fix(Small),11.11
CVE-2010-0663,Tag: Discovered Externally,11.11
CVE-2010-0663,Tag: Discovered Manually,11.11
CVE-2010-0663,Tag: VCC,11.11
CVE-2010-0663,Tag: Project(Chromium),11.11
CVE-2010-0663,Tag: Chromium subsystem utilities,11.11
CVE-2010-0663,Tag: Language(C++),11.11
CVE-2010-3415,Tag: Lesson,10
CVE-2010-3415,Tag: Lifetime(90 - 180 Days),10
CVE-2010-3415,Tag: Fix(Small),10
CVE-2010-3415,Tag: Discovered Externally,10
CVE-2010-3415,Tag: Discovered Manually,10
CVE-2010-3415,Tag: VCC,10
CVE-2010-3415,Tag: Bounty Awarrded ,10
CVE-2010-3415,Tag: Project(Chromium),10
CVE-2010-3415,Tag: Chromium Subsystem(Geolocation),10
CVE-2010-3415,Tag: Language(C++),10

*/


export default function TagTrends(){

	this.init = function(){

		

		d3.sankey = function() {
			var sankey = {},
				nodeWidth = 24,
				nodePadding = 8,
				size = [1, 1],
				nodes = [],
				links = [];
			
			sankey.nodeWidth = function(_) {
				if (!arguments.length) return nodeWidth;
				nodeWidth = +_;
				return sankey;
			};

			sankey.nodePadding = function(_) {
				if (!arguments.length) return nodePadding;
				nodePadding = +_;
				return sankey;
			};

			sankey.nodes = function(_) {
				if (!arguments.length) return nodes;
				nodes = _;
				return sankey;
			};

			sankey.links = function(_) {
				if (!arguments.length) return links;
				links = _;
				return sankey;
			};

			sankey.size = function(_) {
				if (!arguments.length) return size;
				size = _;
				return sankey;
			};

			sankey.layout = function(iterations) {
				computeNodeLinks();
				computeNodeValues();
				computeNodeBreadths();
				computeNodeDepths(iterations);
				computeLinkDepths();
				return sankey;
			};

			sankey.relayout = function() {
				computeLinkDepths();
				return sankey;
			};

			sankey.link = function() {
				var curvature = .5;

				function link(d) {
					var x0 = d.source.x + d.source.dx,
						x1 = d.target.x,
						xm = x0 + (x1 - x0) * curvature,
						y0 = d.source.y + d.sy + d.dy / 2,
						y1 = d.target.y + d.ty + d.dy / 2;
					return "M" + x0 + "," + y0
						 + "C" + xm + "," + y0
						 + " " + xm + "," + y1
						 + " " + x1 + "," + y1;
				}

				link.curvature = function(_) {
					if (!arguments.length) return curvature;
					curvature = +_;
					return link;
				};

				return link;
			};

			// Populate the sourceLinks and targetLinks for each node.
			// Also, if the source and target are not objects, assume they are indices.
			function computeNodeLinks() {
				nodes.forEach(function(node) {
					node.sourceLinks = [];
					node.targetLinks = [];
				});
				links.forEach(function(link) {
					var source = link.source,
						target = link.target;
					if (typeof source === "number") source = link.source = nodes[link.source];
					if (typeof target === "number") target = link.target = nodes[link.target];
					source.sourceLinks.push(link);
					target.targetLinks.push(link);
				});
			}

			// Compute the value (size) of each node by summing the associated links.
			function computeNodeValues() {
				nodes.forEach(function(node) {
					node.value = Math.max(
						d3.sum(node.sourceLinks, value),
						d3.sum(node.targetLinks, value)
					);
				});
			}

			// Iteratively assign the breadth (x-position) for each node.
			// Nodes are assigned the maximum breadth of incoming neighbors plus one;
			// nodes with no incoming links are assigned breadth zero, while
			// nodes with no outgoing links are assigned the maximum breadth.
			function computeNodeBreadths() {
				var remainingNodes = nodes,
					nextNodes,
					x = 0;

				while (remainingNodes.length) {
					nextNodes = [];
					remainingNodes.forEach(function(node) {
						node.x = x;
						node.dx = nodeWidth;
						node.sourceLinks.forEach(function(link) {
							nextNodes.push(link.target);
						});
					});
					remainingNodes = nextNodes;
					++x;
				}

				//
				moveSinksRight(x);
				scaleNodeBreadths((size[0] - nodeWidth) / (x - 1));
			}

			function moveSourcesRight() {
				nodes.forEach(function(node) {
					if (!node.targetLinks.length) {
						node.x = d3.min(node.sourceLinks, function(d) { return d.target.x; }) - 1;
					}
				});
			}

			function moveSinksRight(x) {
				nodes.forEach(function(node) {
					if (!node.sourceLinks.length) {
						node.x = x - 1;
					}
				});
			}

			function scaleNodeBreadths(kx) {
				nodes.forEach(function(node) {
					node.x *= kx;
				});
			}

			function computeNodeDepths(iterations) {
				var nodesByBreadth = d3.nest()
					.key(function(d) { return d.x; })
					.sortKeys(d3.ascending)
					.entries(nodes)
					.map(function(d) { return d.values; });

				//

				initializeNodeDepth();
				resolveCollisions();
				for (var alpha = 1; iterations > 0; --iterations) {
					relaxRightToLeft(alpha *= 0.99);
					resolveCollisions();
					relaxLeftToRight(alpha);
					resolveCollisions();
				}

				function initializeNodeDepth() {
					var ky = d3.min(nodesByBreadth, function(nodes) {
						return (size[1] - (nodes.length - 1) * nodePadding) / d3.sum(nodes, value);
					});

					nodesByBreadth.forEach(function(nodes) {
						nodes.forEach(function(node, i) {
							node.y = i;
							node.dy = node.value * ky;
						});
					});

					links.forEach(function(link) {
						link.dy = link.value * ky;
					});
				}

				function relaxLeftToRight(alpha) {
					nodesByBreadth.forEach(function(nodes, breadth) {
						nodes.forEach(function(node) {
							if (node.targetLinks.length) {
								var y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);
								node.y += (y - center(node)) * alpha;
							}
						});
					});

					function weightedSource(link) {
						return center(link.source) * link.value;
					}
				}

				function weightedSource(link) {
					return center(link.source) * link.value;
				}

				function relaxRightToLeft(alpha) {
					nodesByBreadth.slice().reverse().forEach(function(nodes) {
						nodes.forEach(function(node) {
							if (node.sourceLinks.length) {
								var y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);
								node.y += (y - center(node)) * alpha;
							}
						});
					});

					function weightedTarget(link) {
						return center(link.target) * link.value;
					}
				}

				function resolveCollisions() {
					nodesByBreadth.forEach(function(nodes) {
						var node,
							dy,
							y0 = 0,
							n = nodes.length,
							i;

						// Push any overlapping nodes down.
						nodes.sort(ascendingDepth);
						for (i = 0; i < n; ++i) {
							node = nodes[i];
							dy = y0 - node.y;
							if (dy > 0) node.y += dy;
							y0 = node.y + node.dy + nodePadding;
						}

						// If the bottommost node goes outside the bounds, push it back up.
						dy = y0 - nodePadding - size[1];
						if (dy > 0) {
							y0 = node.y -= dy;

							// Push any overlapping nodes back up.
							for (i = n - 2; i >= 0; --i) {
								node = nodes[i];
								dy = node.y + node.dy + nodePadding - y0;
								if (dy > 0) node.y -= dy;
								y0 = node.y;
							}
						}
					});
				}

				function ascendingDepth(a, b) {
					return a.y - b.y;
				}

			}

			function ascendingSourceDepth(a, b) {
				return a.source.y - b.source.y;
			}

			function ascendingTargetDepth(a, b) {
				return a.target.y - b.target.y;
			}

			function center(node) {
				return node.y + node.dy / 2;
			}

			function value(link) {
				return link.value;
			}

			return sankey;
			
		};
		// chart = SankeyChart({
		// 	links : readcsv
		//   }, {
		// 	nodeGroup: d => d.id.split(/\W/)[0], // takes first word for color
		// 	nodeAlign: "justify",  //set but some button input (sankeyJustify)
		// 	//linkColor: "red", //set by some button input ("source" or "target")
		// 	format: (f => d => '${f(d)} TWh')(d3.format(",.1~f")),
		// 	width: 640,
		// 	height : 600
		//   })
		// return chart;
	}





}

	
	  
// 	  //reading in the data
// 	  const readcsv = [
// 		{source: "Vulnerabilities", target: "CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer", value: 100},
// 		{source: "Vulnerabilities", target: "CWE-121: Stack-based Buffer Overflow", value: 20},
// 		{source: "Vulnerabilities", target: "CWE-200: Information Exposure", value: 20},
// 		{source: "CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer", target: "CVE-2004-0751", value: 100},
// 	  ]
	  

// 	  function SankeyChart({
// 		nodes, // array of node objects
// 		links, // array of link objects
// 	  },
// 	  {
// 		format = ",",  // format specifier for values in titles
// 		//align = "justify", // shorthand for nodeAlign
// 		nodeID = d => d.id, // given d in nodes, returns a unique identifier (string)
// 		nodeGroup, // given d in (computed) nodes, text to label associated rect
// 		nodeGroups, // array of ordinal values representing node groups
// 		nodeLabel, // given d, text to label the associated rect
// 		nodeTitle = d => '${d.id}\n${format(d.value)}', //given d in (computed) nodes, hover text
// 		//nodeAlign = align, // Node alignment strategy (left, right, justify, center)
// 		nodeWidth = 15, // width of node rects
// 		nodePadding = 10, // vertical separation between adjacent nodes
// 		nodeLabelPadding = 6, // horizontal separation betweem mpde and label
// 		nodeStroke = "CurrentColor", // stroke color for node rects
// 		nodeStrokeWidth, // width of stroke around node rects (in pixels)
// 		nodeStrokeOpacity, // opacity of stroke around node rects
// 		nodeStrokeLinejoin, //line join for stroke around node rects
// 		linkSource = ({source}) => source, // given d in links, returns a node to identifier string
// 		linkTarget = ({target}) => target, // given d in links, returns a node to identifier string
// 		linkValue = ({value}) => value, // given d in links, returns a numeric value
// 		linkPath = d3.Sankey.sankeyLinkHorizontal(), // given d in (computed) links, returns svg path
// 		linkTitle = d => '${d.source.id} â†’ ${d.target.id}\n${format(d.value)}', // given d in (computed) links
// 		linkColor = "source-target", //source, target, source-target, or static color
// 		linkStrokeOpacity = 0.5, // link stroke opacity
// 		linkMixBlendMode = "multiply", // link blending mode
// 		colors = d3.schemeTableau10, // array of colors
// 		width = 640, // outer width, in pixels
// 		height = 400, // outer height, in pixels
// 		marginTop = 5, // top margin, in pixels
// 		marginRight = 1, // right margin, in pixels
// 		marginBottom = 5, // bottom margin, in pixels
// 		marginLeft = 1, // left margin, in pixels
// 	  } = {}) {

// 		// Convert nodeAlign to a function (d3-sankey is not part of core d3)
// 		if (typeof nodeAlign !== "function") nodeAlign = {
// 		  left: d3Sankey.sankeyLeft,
// 		  right: d3Sankey.sankeyRight,
// 		  center: d3Sankey.sankeyCenter,
// 		}[nodeAlign] ?? d3Sankey.sankeyJustify;

// 		//computing values??
// 		const LS = d3.map(links, linkSource).map(intern);
// 		const LT = d3.map(links, linkTarget).map(intern);
// 		const LV = d3.map(links, linkValue);
// 		if (nodes == undefined) nodes = Array.from(d3.union(LS, LT), id => ({id}));
// 		const N = d3.map(nodes, nodeID).map(intern);
// 		const G = nodeGroup == null ? null : d3.map(nodes, nodeGroup).map(intern);

// 		//replacing the input nodes and links with mutable objects for the simulation
// 		nodes = d3.map(nodes, (_, i) => ({id: N[i]}));
// 		links = d3.map(links, (_, i) => ({source: LS[i], target: LT[i], value: LV[i]}));

// 		//ignoring group-based link color option if no groups are specified
// 		if (!G && ["source", "target", "source-target"].includes(linkColor)) linkColor = "CurrentColor";

// 		//computing default domains
// 		if (G && nodeGroups == undefined) nodeGroups = G;

// 		//constructing the color scales
// 		const color = nodeGroup == null ? null : d3.scaleOrdinal(nodeGroups, colors);

// 		//Computing sankey layout
// 		d3Sankey.sankey()
// 		  .nodeID(({index: i}) => N[i])
// 		  .nodeAlign(nodeAlign)
// 		  .nodeWidth(nodeWidth)
// 		  .nodePadding(nodePadding)
// 		  .extent([[marginLeft, marginTop], [width - marginRight, height - marginBottom]])
// 		  ({nodes, links});

// 		  //computing titles and labels using layout nodes, to access aggregate values.
// 		  if(typeof format !== "function") format = d3.format(format);
// 		  const Tl = nodeLabel == undefined ? N : nodeLabel == null ? null : d3.map(nodes, nodeLabel);
// 		  const Tt = nodeTitle == null ? null : d3.map(nodes, nodeTitle);
// 		  const Lt = linkTitle == null ? null : d3.map(links, linkTitle);

// 		  //unique identifier for clip path to avoid conflixts
// 		  const uid = '0-${Math.random().toString(16).slice(2)}';
// 		  console.log("Made it to sankey chart v1")

// 		  const svg = d3.select("#tag-trends-svg")
// 		  	console.log("Made it to sankey svg")	
// 			  .attr("width", width)
// 			  .attr("height", height)
// 			  .attr("viewBox", [0, 0, width, height])
// 			  .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

// 		  const node = svg.append("g")
// 			  .attr("stroke", nodeStroke)
// 			  .attr("stroke-width", nodeStrokeWidth)
// 			  .attr("stroke-opacity", nodeStrokeOpacity)
// 			  .attr("stroke-linejoin", nodeStrokeLinejoin)
// 			.selectAll("rect")
// 			.data(nodes)
// 			.join("rect")
// 			  .attr("x", d => d.x0)
// 			  .attr("y", d => d.y0)
// 			  .attr("height", d => d.y1 - d.y0)
// 			  .attr("width", d => d.x1 - d.x0)

// 		  if (G) node.attr("fill", ({index: i}) => color(G[i]));
// 		  if (Tt) node.append("title").text(({index: i}) => Tt[i]);

// 		  const link = svg.append("g")
// 			  .attr("fill", "none")
// 			  .attr("stroke-opacity", linkStrokeOpacity)
// 			.selectAll("g")
// 			.data(links)
// 			.join("g")
// 			  .style("mix-blend-mode", linkMixBlendMode);

// 		  if (linkColor === "source-target") link.append("linearGradient")
// 			  .attr("id", d => '${uid}-link-${d.index}')
// 			  .attr("gradientUnits", "userSpaceOnUse")
// 			  .attr("x1", d => d.source.x1)
// 			  .attr("x2", d => d.target.x0)
// 			  .call(gradient => gradient.append("stop")
// 				  .attr("offset", "0%")
// 				  .attr("stop-color", ({source: {index: i}}) => color(G[i])))
// 			  .call(gradient => gradient.append("stop")
// 				  .attr("offset", "100%")
// 				  .attr("stop-color", ({target: {index: i}}) => color(G[i])));

// 		  link.append("path")
// 			  .attr("d", linkPath)
// 			  .attr("stroke", linkColor === "source-target" ? ({index: i}) => 'url(#${uid}-link-${i}))'
// 				  : linkColor === "source" ? ({source: {index: i}}) => color(G[i])
// 				  : linkColor === "target" ? ({target: {index: i}}) => color(G[i])
// 				  : linkColor)
// 			  .attr("stroke-width", ({width}) => Math.max(1, width))
// 			  .call(Lt ? path => path.append("title").text(({index: i}) => Lt[i]) : () => {});

// 		  if (Tl) svg.append("g")
// 			  .attr("font-family", "sans-serif")
// 			  .attr("font-size", 10)
// 			.selectAll("text")
// 			.data(nodes)
// 			.join("text")
// 			  .attr("x", d => d.x0 < width / 2 ? d.x1 + nodeLabelPadding : d.x0 - nodeLabelPadding)
// 			  .attr("y", d => (d.y1 + d.y0) / 2)
// 			  .attr("dy", "0.35em")
// 			  .attr("text-anchor", d => d.x0 < width / 2 ? "start" : "end")
// 			  .text(({index: i}) => Tl[i]);

// 		  function intern(value) {
// 			return value !== nul && typeof value === "object" ? value.valueOf() : {value};
// 		  }

// 		  return Object.assign(svg.node(), {scales: {color}});
// 	  }


//   }


export function onInsightsTagTrends(){
	console.log("Hello, tag trends!")
	console.log("entering sankey chart init")
	const sankeyChart = new TagTrends().init();
	d3.select('#tag-trends').append("p").html("I'm in d3!")
}





