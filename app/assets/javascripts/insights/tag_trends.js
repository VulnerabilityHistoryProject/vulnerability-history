import * as d3 from 'd3'

/* Data from CSV
Vulnerabilities,CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer,100
Vulnerabilities,CWE-121: Stack-based Buffer Overflow,20
Vulnerabilities,CWE-200: Information Exposure,20
CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer,CVE-2004-0751,100
CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer,CVE-2004-0747,100
CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer,CVE-2008-6998,100
CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer,CVE-2010-0663,100
CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer,CVE-2010-3415,100
CWE-121: Stack-based Buffer Overflow,CVE-2008-6998,20
CWE-200: Information Exposure,CVE-2010-0663,20
CVE-2004-0751,Tag: Lesson,12.5
CVE-2004-0751,Tag: Lifetime(1-2 Years),12.5
CVE-2004-0751,Tag: VCC,12.5
CVE-2004-0751,Tag: Fix(Small),12.5
CVE-2004-0751,Tag: Language (C),12.5
CVE-2004-0751,Tag: Discovered Externally,12.5
CVE-2004-0751,Tag: HTTPD Subsystem(modules/ssl/ssl_engine_io.c),12.5
CVE-2004-0751,Tag: Project(HTTPD),12.5
CVE-2004-0747,Tag: Lesson,10
CVE-2004-0747,Tag: Lifetime(2-5 Years),10
CVE-2004-0747,Tag: Fix(Big),10
CVE-2004-0747,Tag: Discovered Externally,10
CVE-2004-0747,Tag: Discovered Manually,10
CVE-2004-0747,Tag: Util,10
CVE-2004-0747,Tag: VCC,10
CVE-2004-0747,Tag: Project(HTTPD),10
CVE-2004-0747,Tag: HTTPD Subsystem(server),10
CVE-2004-0747,Tag: Language (C),10
CVE-2008-6998,Tag: Lesson,14.28
CVE-2008-6998,Tag: Lifetime(30 - 90 Days),14.28
CVE-2008-6998,Tag: Fix(Small),14.28
CVE-2008-6998,Tag: VCC,14.28
CVE-2008-6998,Tag: Project(Chromium),14.28
CVE-2008-6998,Tag: Language (C++),14.28
CVE-2008-6998,Tag: Chromium subsystem(url_elider),14.28
CVE-2010-0663,Tag: Lesson,11.11
CVE-2010-0663,Tag: Lifetime(1-2 Years),11.11
CVE-2010-0663,Tag: Fix(Small),11.11
CVE-2010-0663,Tag: Discovered Externally,11.11
CVE-2010-0663,Tag: Discovered Manually,11.11
CVE-2010-0663,Tag: VCC,11.11
CVE-2010-0663,Tag: Project(Chromium),11.11
CVE-2010-0663,Tag: Chromium subsystem utilities,11.11
CVE-2010-0663,Tag: Language(C++),11.11
CVE-2010-3415,Tag: Lesson,10
CVE-2010-3415,Tag: Lifetime(90 - 180 Days),10
CVE-2010-3415,Tag: Fix(Small),10
CVE-2010-3415,Tag: Discovered Externally,10
CVE-2010-3415,Tag: Discovered Manually,10
CVE-2010-3415,Tag: VCC,10
CVE-2010-3415,Tag: Bounty Awarrded ,10
CVE-2010-3415,Tag: Project(Chromium),10
CVE-2010-3415,Tag: Chromium Subsystem(Geolocation),10
CVE-2010-3415,Tag: Language(C++),10

*/


export default function TagTrends(){

	this.init = function(){
		chart = SankeyChart({
			links : readcsv
		  }, {
			nodeGroup: d => d.id.split(/\W/)[0], // takes first word for color
			nodeAlign,  //set but some button input (sankeyJustify)
			linkColor, //set by some button input ("source" or "target")
			format: (f => d => '${f(d)} TWh')(d3.format(",.1~f")),
			width,
			height : 600
		  })
		return chart;
	}

	
	  
	  //reading in the data
	  readcsv = FileAttachement("vhp.csv").csv({typed: true})
	  console.log("finished Reading csv")

	  function SankeyChart({
		nodes, // array of node objects
		links, // array of link objects
	  },
	  {
		format = ",",  // format specifier for values in titles
		align = "justify", // shorthand for nodeAlign
		nodeID = d => d.id, // given d in nodes, returns a unique identifier (string)
		nodeGroup, // given d in (computed) nodes, text to label associated rect
		nodeGroups, // array of ordinal values representing node groups
		nodeLabel, // given d, text to label the associated rect
		nodeTitle = d => '${d.id}\n${format(d.value)}', //given d in (computed) nodes, hover text
		nodeAlign = align, // Node alignment strategy (left, right, justify, center)
		nodeWidth = 15, // width of node rects
		nodePadding = 10, // vertical separation between adjacent nodes
		nodeLabelPadding = 6, // horizontal separation betweem mpde and label
		nodeStroke = "CurrentColor", // stroke color for node rects
		nodeStrokeWidth, // width of stroke around node rects (in pixels)
		nodeStrokeOpacity, // opacity of stroke around node rects
		nodeStrokeLinejoin, //line join for stroke around node rects
		linkSource = ({source}) => source, // given d in links, returns a node to identifier string
		linkTarget = ({target}) => target, // given d in links, returns a node to identifier string
		linkValue = ({value}) => value, // given d in links, returns a numeric value
		linkPath = d3.Sankey.sankeyLinkHorizontal(), // given d in (computed) links, returns svg path
		linkTitle = d => '${d.source.id} â†’ ${d.target.id}\n${format(d.value)}', // given d in (computed) links
		linkColor = "source-target", //source, target, source-target, or static color
		linkStrokeOpacity = 0.5, // link stroke opacity
		linkMixBlendMode = "multiply", // link blending mode
		colors = d3.schemeTableau10, // array of colors
		width = 640, // outer width, in pixels
		height = 400, // outer height, in pixels
		marginTop = 5, // top margin, in pixels
		marginRight = 1, // right margin, in pixels
		marginBottom = 5, // bottom margin, in pixels
		marginLeft = 1, // left margin, in pixels
	  } = {}) {
		// Convert nodeAlign to a function (d3-sankey is not part of core d3)
		if (typeof nodeAlign !== "function") nodeAlign = {
		  left: d3Sankey.sankeyLeft,
		  right: d3Sankey.sankeyRight,
		  center: d3Sankey.sankeyCenter,
		}[nodeAlign] ?? d3Sankey.sankeyJustify;

		//computing values??
		const LS = d3.map(links, linkSource).map(intern);
		const LT = d3.map(links, linkTarget).map(intern);
		const LV = d3.map(links, linkValue);
		if (nodes == undefined) nodes = Array.from(d3.union(LS, LT), id => ({id}));
		const N = d3.map(nodes, nodeID).map(intern);
		const G = nodeGroup == null ? null : d3.map(nodes, nodeGroup).map(intern);

		//replacing the input nodes and links with mutable objects for the simulation
		nodes = d3.map(nodes, (_, i) => ({id: N[i]}));
		links = d3.map(links, (_, i) => ({source: LS[i], target: LT[i], value: LV[i]}));

		//ignoring group-based link color option if no groups are specified
		if (!G && ["source", "target", "source-target"].includes(linkColor)) linkColor = "CurrentColor";

		//computing default domains
		if (G && nodeGroups == undefined) nodeGroups = G;

		//constructing the color scales
		const color = nodeGroup == null ? null : d3.scaleOrdinal(nodeGroups, colors);

		//Computing sankey layout
		d3Sankey.sankey()
		  .nodeID(({index: i}) => N[i])
		  .nodeAlign(nodeAlign)
		  .nodeWidth(nodeWidth)
		  .nodePadding(nodePadding)
		  .extent([[marginLeft, marginTop], [width - marginRight, height - marginBottom]])
		  ({nodes, links});

		  //computing titles and labels using layout nodes, to access aggregate values.
		  if(typeof format !== "function") format = d3.format(format);
		  const Tl = nodeLabel == undefined ? N : nodeLabel == null ? null : d3.map(nodes, nodeLabel);
		  const Tt = nodeTitle == null ? null : d3.map(nodes, nodeTitle);
		  const Lt = linkTitle == null ? null : d3.map(links, linkTitle);

		  //unique identifier for clip path to avoid conflixts
		  const uid = '0-${Math.random().toString(16).slice(2)}';
		  console.log("Made it to sankey chart v1")

		  const svg = d3.select("#tag-trends-svg")
		  	console.log("Made it to sankey svg")	
			  .attr("width", width)
			  .attr("height", height)
			  .attr("viewBox", [0, 0, width, height])
			  .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

		  const node = svg.append("g")
			  .attr("stroke", nodeStroke)
			  .attr("stroke-width", nodeStrokeWidth)
			  .attr("stroke-opacity", nodeStrokeOpacity)
			  .attr("stroke-linejoin", nodeStrokeLinejoin)
			.selectAll("rect")
			.data(nodes)
			.join("rect")
			  .attr("x", d => d.x0)
			  .attr("y", d => d.y0)
			  .attr("height", d => d.y1 - d.y0)
			  .attr("width", d => d.x1 - d.x0)

		  if (G) node.attr("fill", ({index: i}) => color(G[i]));
		  if (Tt) node.append("title").text(({index: i}) => Tt[i]);

		  const link = svg.append("g")
			  .attr("fill", "none")
			  .attr("stroke-opacity", linkStrokeOpacity)
			.selectAll("g")
			.data(links)
			.join("g")
			  .style("mix-blend-mode", linkMixBlendMode);

		  if (linkColor === "source-target") link.append("linearGradient")
			  .attr("id", d => '${uid}-link-${d.index}')
			  .attr("gradientUnits", "userSpaceOnUse")
			  .attr("x1", d => d.source.x1)
			  .attr("x2", d => d.target.x0)
			  .call(gradient => gradient.append("stop")
				  .attr("offset", "0%")
				  .attr("stop-color", ({source: {index: i}}) => color(G[i])))
			  .call(gradient => gradient.append("stop")
				  .attr("offset", "100%")
				  .attr("stop-color", ({target: {index: i}}) => color(G[i])));

		  link.append("path")
			  .attr("d", linkPath)
			  .attr("stroke", linkColor === "source-target" ? ({index: i}) => 'url(#${uid}-link-${i}))'
				  : linkColor === "source" ? ({source: {index: i}}) => color(G[i])
				  : linkColor === "target" ? ({target: {index: i}}) => color(G[i])
				  : linkColor)
			  .attr("stroke-width", ({width}) => Math.max(1, width))
			  .call(Lt ? path => path.append("title").text(({index: i}) => Lt[i]) : () => {});

		  if (Tl) svg.append("g")
			  .attr("font-family", "sans-serif")
			  .attr("font-size", 10)
			.selectAll("text")
			.data(nodes)
			.join("text")
			  .attr("x", d => d.x0 < width / 2 ? d.x1 + nodeLabelPadding : d.x0 - nodeLabelPadding)
			  .attr("y", d => (d.y1 + d.y0) / 2)
			  .attr("dy", "0.35em")
			  .attr("text-anchor", d => d.x0 < width / 2 ? "start" : "end")
			  .text(({index: i}) => Tl[i]);

		  function intern(value) {
			return value !== nul && typeof value === "object" ? value.valueOf() : {value};
		  }

		  return Object.assign(svg.node(), {scales: {color}});
	  }


  }

export function onInsightsTagTrends(){
	console.log("Hello, tag trends!")
	console.log("entering sankey chart init")
	const sankeyChart = new TagTrends().init();
	d3.select('#tag-trends').append("p").html("I'm in d3!")
}





