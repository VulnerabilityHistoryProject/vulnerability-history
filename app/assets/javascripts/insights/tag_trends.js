import * as d3 from 'd3'
import * as anychart from 'anychart'


/* Data from CSV
Vulnerabilities,CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer,100
Vulnerabilities,CWE-121: Stack-based Buffer Overflow,20
Vulnerabilities,CWE-200: Information Exposure,20
CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer,CVE-2004-0751,100
CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer,CVE-2004-0747,100
CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer,CVE-2008-6998,100
CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer,CVE-2010-0663,100
CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer,CVE-2010-3415,100
CWE-121: Stack-based Buffer Overflow,CVE-2008-6998,20
CWE-200: Information Exposure,CVE-2010-0663,20
CVE-2004-0751,Tag: Lesson,12.5
CVE-2004-0751,Tag: Lifetime(1-2 Years),12.5
CVE-2004-0751,Tag: VCC,12.5
CVE-2004-0751,Tag: Fix(Small),12.5
CVE-2004-0751,Tag: Language (C),12.5
CVE-2004-0751,Tag: Discovered Externally,12.5
CVE-2004-0751,Tag: HTTPD Subsystem(modules/ssl/ssl_engine_io.c),12.5
CVE-2004-0751,Tag: Project(HTTPD),12.5
CVE-2004-0747,Tag: Lesson,10
CVE-2004-0747,Tag: Lifetime(2-5 Years),10
CVE-2004-0747,Tag: Fix(Big),10
CVE-2004-0747,Tag: Discovered Externally,10
CVE-2004-0747,Tag: Discovered Manually,10
CVE-2004-0747,Tag: Util,10
CVE-2004-0747,Tag: VCC,10
CVE-2004-0747,Tag: Project(HTTPD),10
CVE-2004-0747,Tag: HTTPD Subsystem(server),10
CVE-2004-0747,Tag: Language (C),10
CVE-2008-6998,Tag: Lesson,14.28
CVE-2008-6998,Tag: Lifetime(30 - 90 Days),14.28
CVE-2008-6998,Tag: Fix(Small),14.28
CVE-2008-6998,Tag: VCC,14.28
CVE-2008-6998,Tag: Project(Chromium),14.28
CVE-2008-6998,Tag: Language (C++),14.28
CVE-2008-6998,Tag: Chromium subsystem(url_elider),14.28
CVE-2010-0663,Tag: Lesson,11.11
CVE-2010-0663,Tag: Lifetime(1-2 Years),11.11
CVE-2010-0663,Tag: Fix(Small),11.11
CVE-2010-0663,Tag: Discovered Externally,11.11
CVE-2010-0663,Tag: Discovered Manually,11.11
CVE-2010-0663,Tag: VCC,11.11
CVE-2010-0663,Tag: Project(Chromium),11.11
CVE-2010-0663,Tag: Chromium subsystem utilities,11.11
CVE-2010-0663,Tag: Language(C++),11.11
CVE-2010-3415,Tag: Lesson,10
CVE-2010-3415,Tag: Lifetime(90 - 180 Days),10
CVE-2010-3415,Tag: Fix(Small),10
CVE-2010-3415,Tag: Discovered Externally,10
CVE-2010-3415,Tag: Discovered Manually,10
CVE-2010-3415,Tag: VCC,10
CVE-2010-3415,Tag: Bounty Awarrded ,10
CVE-2010-3415,Tag: Project(Chromium),10
CVE-2010-3415,Tag: Chromium Subsystem(Geolocation),10
CVE-2010-3415,Tag: Language(C++),10

*/


export default function TagTrends() {
	//d3Sankey = require.alias({ "d3-array": d3, "d3-shape": d3, "d3-sankey": "d3-sankey@0.12.3/dist/d3-sankey.min.js" })("d3-sankey")

	this.works = function () {

		//reading in the data
		anychart.onDocumentReady(function () {
			anychart.data.loadCsvFile("https://raw.githubusercontent.com/VulnerabilityHistoryProject/vulnerability-history/sankey_diagram/app/assets/javascripts/insights/vhp.csv", function (data) {


				var sankey_chart = anychart.sankey();

				//putting the data into the chart
				sankey_chart.data(data);

				//setting the chart padding
				sankey_chart.padding(20, 40);

				//custom color palette
				sankey_chart.palette(
					[
						'#f44336',
						'#e91e63',
						'#9c27b0',
						'#673ab7',
						'#3f51b5',
						'#2196f3',
						'#03a9f4',
						'#00bcd4',
						'#009688',
						'#4caf50',
						'#8bc34a',
						'#cddc39',
						'#ffeb3b',
						'#ffc107',
						'#ff9800',
						'#ff5722',
						'#795548',
						'#9e9e9e',
						'#607d8b'
					]);

				//customizing the nodes

				//setting the width
				sankey_chart.nodeWidth("40%");

				//setting the padding
				sankey_chart.nodePadding(30);

				//customize the labels


				sankey_chart.node().labels().fontSize(14);
				sankey_chart.node().labels()
					.format("{%name} {%value}");

				//customize the links
				sankey_chart.flow({
					normal: {
						fill: function () {
							return this.sourceColor + " " + 0.8;
						}
					}
				});

				//adding title and customizing it
				sankey_chart
					.title()
					// .enabled(true)
					// .useHTML(true)
					.text('<span style= "color: #2b2b2b; font-size:20px;">Tag Trends Test - 1</span>');

				//setting container id
				sankey_chart.container("tag-trends2");

				//drawing the chart
				sankey_chart.draw();
			});
		});

	};

	d3.sankey = function () {
		var sankey = {},
			nodeWidth = 24,
			nodePadding = 8,
			size = [1, 1],
			nodes = [],
			links = [];

		sankey.nodeWidth = function (_) {
			if (!arguments.length) return nodeWidth;
			nodeWidth = +_;
			return sankey;
		};

		sankey.nodePadding = function (_) {
			if (!arguments.length) return nodePadding;
			nodePadding = +_;
			return sankey;
		};

		sankey.nodes = function (_) {
			if (!arguments.length) return nodes;
			nodes = _;
			return sankey;
		};

		sankey.links = function (_) {
			if (!arguments.length) return links;
			links = _;
			return sankey;
		};

		sankey.size = function (_) {
			if (!arguments.length) return size;
			size = _;
			return sankey;
		};

		sankey.layout = function (iterations) {
			computeNodeLinks();
			computeNodeValues();
			computeNodeBreadths();
			computeNodeDepths(iterations);
			computeLinkDepths();
			return sankey;
		};

		sankey.relayout = function () {
			computeLinkDepths();
			return sankey;
		};

		sankey.link = function () {
			var curvature = .5;

			function link(d) {
				var x0 = d.source.x + d.source.dx,
					x1 = d.target.x,
					xi = d3.interpolateNumber(x0, x1),
					x2 = xi(curvature),
					x3 = xi(1 - curvature),
					y0 = d.source.y + d.sy + d.dy / 2,
					y1 = d.target.y + d.ty + d.dy / 2;
				return "M" + x0 + "," + y0
					+ "C" + x2 + "," + y0
					+ " " + x3 + "," + y1
					+ " " + x1 + "," + y1;
			}

			link.curvature = function (_) {
				if (!arguments.length) return curvature;
				curvature = +_;
				return link;
			};

			return link;
		};

		// Populate the sourceLinks and targetLinks for each node.
		// Also, if the source and target are not objects, assume they are indices.
		function computeNodeLinks() {
			nodes.forEach(function (node) {
				node.sourceLinks = [];
				node.targetLinks = [];
			});
			links.forEach(function (link) {
				var source = link.source,
					target = link.target;
				if (typeof source === "number") source = link.source = nodes[link.source];
				if (typeof target === "number") target = link.target = nodes[link.target];
				source.sourceLinks.push(link);
				target.targetLinks.push(link);
			});
		}

		// Compute the value (size) of each node by summing the associated links.
		function computeNodeValues() {
			nodes.forEach(function (node) {
				node.value = Math.max(
					d3.sum(node.sourceLinks, value),
					d3.sum(node.targetLinks, value)
				);
			});
		}

		// Iteratively assign the breadth (x-position) for each node.
		// Nodes are assigned the maximum breadth of incoming neighbors plus one;
		// nodes with no incoming links are assigned breadth zero, while
		// nodes with no outgoing links are assigned the maximum breadth.
		function computeNodeBreadths() {
			var remainingNodes = nodes,
				nextNodes,
				x = 0;

			while (remainingNodes.length) {
				nextNodes = [];
				remainingNodes.forEach(function (node) {
					node.x = x;
					node.dx = nodeWidth;
					node.sourceLinks.forEach(function (link) {
						if (nextNodes.indexOf(link.target) < 0) {
							nextNodes.push(link.target);
						}
					});
				});
				remainingNodes = nextNodes;
				++x;
			}

			//
			moveSinksRight(x);
			scaleNodeBreadths((size[0] - nodeWidth) / (x - 1));
		}

		function moveSourcesRight() {
			nodes.forEach(function (node) {
				if (!node.targetLinks.length) {
					node.x = d3.min(node.sourceLinks, function (d) { return d.target.x; }) - 1;
				}
			});
		}

		function moveSinksRight(x) {
			nodes.forEach(function (node) {
				if (!node.sourceLinks.length) {
					node.x = x - 1;
				}
			});
		}

		function scaleNodeBreadths(kx) {
			nodes.forEach(function (node) {
				node.x *= kx;
			});
		}

		function computeNodeDepths(iterations) {
			var nodesByBreadth = d3.nest()
				.key(function (d) { return d.x; })
				.sortKeys(d3.ascending)
				.entries(nodes)
				.map(function (d) { return d.values; });

			//
			initializeNodeDepth();
			resolveCollisions();
			for (var alpha = 1; iterations > 0; --iterations) {
				relaxRightToLeft(alpha *= .99);
				resolveCollisions();
				relaxLeftToRight(alpha);
				resolveCollisions();
			}

			function initializeNodeDepth() {
				var ky = d3.min(nodesByBreadth, function (nodes) {
					return (size[1] - (nodes.length - 1) * nodePadding) / d3.sum(nodes, value);
				});

				nodesByBreadth.forEach(function (nodes) {
					nodes.forEach(function (node, i) {
						node.y = i;
						node.dy = node.value * ky;
					});
				});

				links.forEach(function (link) {
					link.dy = link.value * ky;
				});
			}

			function relaxLeftToRight(alpha) {
				nodesByBreadth.forEach(function (nodes, breadth) {
					nodes.forEach(function (node) {
						if (node.targetLinks.length) {
							var y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);
							node.y += (y - center(node)) * alpha;
						}
					});
				});

				function weightedSource(link) {
					return center(link.source) * link.value;
				}
			}

			function relaxRightToLeft(alpha) {
				nodesByBreadth.slice().reverse().forEach(function (nodes) {
					nodes.forEach(function (node) {
						if (node.sourceLinks.length) {
							var y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);
							node.y += (y - center(node)) * alpha;
						}
					});
				});

				function weightedTarget(link) {
					return center(link.target) * link.value;
				}
			}

			function resolveCollisions() {
				nodesByBreadth.forEach(function (nodes) {
					var node,
						dy,
						y0 = 0,
						n = nodes.length,
						i;

					// Push any overlapping nodes down.
					nodes.sort(ascendingDepth);
					for (i = 0; i < n; ++i) {
						node = nodes[i];
						dy = y0 - node.y;
						if (dy > 0) node.y += dy;
						y0 = node.y + node.dy + nodePadding;
					}

					// If the bottommost node goes outside the bounds, push it back up.
					dy = y0 - nodePadding - size[1];
					if (dy > 0) {
						y0 = node.y -= dy;

						// Push any overlapping nodes back up.
						for (i = n - 2; i >= 0; --i) {
							node = nodes[i];
							dy = node.y + node.dy + nodePadding - y0;
							if (dy > 0) node.y -= dy;
							y0 = node.y;
						}
					}
				});
			}

			function ascendingDepth(a, b) {
				return a.y - b.y;
			}
		}

		function computeLinkDepths() {
			nodes.forEach(function (node) {
				node.sourceLinks.sort(ascendingTargetDepth);
				node.targetLinks.sort(ascendingSourceDepth);
			});
			nodes.forEach(function (node) {
				var sy = 0, ty = 0;
				node.sourceLinks.forEach(function (link) {
					link.sy = sy;
					sy += link.dy;
				});
				node.targetLinks.forEach(function (link) {
					link.ty = ty;
					ty += link.dy;
				});
			});

			function ascendingSourceDepth(a, b) {
				return a.source.y - b.source.y;
			}

			function ascendingTargetDepth(a, b) {
				return a.target.y - b.target.y;
			}
		}

		function center(node) {
			return node.y + node.dy / 2;
		}

		function value(link) {
			return link.value;
		}

		return sankey;
	};




	this.init = function () {

		//margins of graph
		var margin = { top: 10, right: 10, bottom: 10, left: 10 },
			width = 450 - margin.left - margin.right,
			height = 480 - margin.top - margin.bottom;

		//appending svg object to the body of the page
		var svg = d3.select("#tag-trends").append("svg")
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom)
			.append("g")
			.attr("transform",
				"translate(" + margin.left + "," + margin.top + ")");

		// Color scaled used
		var color = d3.scaleOrdinal(d3.schemeCategory20);

		//Set sankey diagram properties
		var sankey = d3.sankey()
			.nodeWidth(36)
			.nodePadding(290)
			.size([width, height]);

		//loading the data
		d3.json("https://raw.githubusercontent.com/VulnerabilityHistoryProject/vulnerability-history/sankey_diagram/app/assets/javascripts/insights/test.json", function (error, graph) {
			sankey
				.nodes(graph.nodes)
				.links(graph.links)
				.layout(3);

			// add in the links
			var link = svg.append("g")
				.selectAll(".link")
				.data(graph.links)
				.enter()
				.append("path")
				.attr("class", "link")
				.attr("d", sankey.link())
				.style("stroke-width", function (d) { return Math.max(1, d.dy); })
				.sort(function (a, b) { return b.dy - a.dy; });

			// add in the nodes
			var node = svg.append("g")
				.selectAll(".node")
				.data(graph.nodes)
				.enter().append("g")
				.attr("class", "node")
				.attr("transform", function (d) { return "translate(" + d.x + "," + d.y + ")"; })
				.call(d3.drag()
					.subject(function (d) { return d; })
					.on("start", function () { this.parentNode.appendChild(this); }
					.on("drag", dragmove)));
			//add the rectangles for the nodes
			node
				.append("rect")
				.attr("height", function (d) { return d.dy; })
				.attr("width", sankey.nodeWidth())
				.style("fill", function (d) { return d.color = color(d.name.replace(/ .*/, "")); })
				.style("stroke", function (d) { return d3.rgb(d.color).darker(2); })
				//add the hover text
				.append("title")
				.text(function (d) { return d.name + "\n" + "Total: " + d.value; });

			// add in the title for the nodes
			node
				.append("text")
				.attr("x", -6)
				.attr("y", function (d) { return d.dy / 2; })
				.attr("dy", ".35em")
				.attr("text-anchor", "end")
				.attr("transform", null)
				.text(function (d) { return d.name; })
				.filter(function (d) { return d.x < width / 2; })
				.attr("x", 6 + sankey.nodeWidth())
				.attr("text-anchor", "start");

			//function for moving the nodes
			function dragmove(d) {
				d3.select(this)
					.attr("transform",
						"translate("
						+ d.x + ","
						+ (d.y = Math.max(
							0, Math.min(height - d.dy, d3.event.y))
						) + ")");
				sankey.relayout();
				link.attr("d", sankey.link());
			}
		});




	};

	// 	chart = SankeyChart({
	// 		links: readcsv
	// 	}, {
	// 		nodeGroup: d => d.id.split(/\W/)[0], // takes first word for color
	// 		nodeAlign: "justify",  //set but some button input (sankeyJustify)
	// 		//linkColor: "red", //set by some button input ("source" or "target")
	// 		format: (f => d => '${f(d)} TWh')(d3.format(",.1~f")),
	// 		width: 640,
	// 		height: 600
	// 	})




	// 	function SankeyChart({
	// 		nodes, // array of node objects
	// 		links, // array of link objects
	// 	},
	// 		{
	// 			format = ",",  // format specifier for values in titles
	// 			//align = "justify", // shorthand for nodeAlign
	// 			nodeID = d => d.id, // given d in nodes, returns a unique identifier (string)
	// 			nodeGroup, // given d in (computed) nodes, text to label associated rect
	// 			nodeGroups, // array of ordinal values representing node groups
	// 			nodeLabel, // given d, text to label the associated rect
	// 			nodeTitle = d => '${d.id}\n${format(d.value)}', //given d in (computed) nodes, hover text
	// 			//nodeAlign = align, // Node alignment strategy (left, right, justify, center)
	// 			nodeWidth = 15, // width of node rects
	// 			nodePadding = 10, // vertical separation between adjacent nodes
	// 			nodeLabelPadding = 6, // horizontal separation betweem mpde and label
	// 			nodeStroke = "CurrentColor", // stroke color for node rects
	// 			nodeStrokeWidth, // width of stroke around node rects (in pixels)
	// 			nodeStrokeOpacity, // opacity of stroke around node rects
	// 			nodeStrokeLinejoin, //line join for stroke around node rects
	// 			linkSource = ({ source }) => source, // given d in links, returns a node to identifier string
	// 			linkTarget = ({ target }) => target, // given d in links, returns a node to identifier string
	// 			linkValue = ({ value }) => value, // given d in links, returns a numeric value
	// 			linkPath = d3.Sankey.sankeyLinkHorizontal(), // given d in (computed) links, returns svg path
	// 			linkTitle = d => '${d.source.id} â†’ ${d.target.id}\n${format(d.value)}', // given d in (computed) links
	// 			linkColor = "source-target", //source, target, source-target, or static color
	// 			linkStrokeOpacity = 0.5, // link stroke opacity
	// 			linkMixBlendMode = "multiply", // link blending mode
	// 			colors = d3.schemeTableau10, // array of colors
	// 			width = 640, // outer width, in pixels
	// 			height = 400, // outer height, in pixels
	// 			marginTop = 5, // top margin, in pixels
	// 			marginRight = 1, // right margin, in pixels
	// 			marginBottom = 5, // bottom margin, in pixels
	// 			marginLeft = 1, // left margin, in pixels
	// 		} = {}) {

	// 		// Convert nodeAlign to a function (d3-sankey is not part of core d3)
	// 		if (typeof nodeAlign !== "function") nodeAlign = {
	// 			left: d3Sankey.sankeyLeft,
	// 			right: d3Sankey.sankeyRight,
	// 			center: d3Sankey.sankeyCenter,
	// 		}[nodeAlign] ?? d3Sankey.sankeyJustify;

	// 		//computing values??
	// 		const LS = d3.map(links, linkSource).map(intern);
	// 		const LT = d3.map(links, linkTarget).map(intern);
	// 		const LV = d3.map(links, linkValue);
	// 		if (nodes == undefined) nodes = Array.from(d3.union(LS, LT), id => ({ id }));
	// 		const N = d3.map(nodes, nodeID).map(intern);
	// 		const G = nodeGroup == null ? null : d3.map(nodes, nodeGroup).map(intern);

	// 		//replacing the input nodes and links with mutable objects for the simulation
	// 		nodes = d3.map(nodes, (_, i) => ({ id: N[i] }));
	// 		links = d3.map(links, (_, i) => ({ source: LS[i], target: LT[i], value: LV[i] }));

	// 		//ignoring group-based link color option if no groups are specified
	// 		if (!G && ["source", "target", "source-target"].includes(linkColor)) linkColor = "CurrentColor";

	// 		//computing default domains
	// 		if (G && nodeGroups == undefined) nodeGroups = G;

	// 		//constructing the color scales
	// 		const color = nodeGroup == null ? null : d3.scaleOrdinal(nodeGroups, colors);

	// 		//Computing sankey layout
	// 		d3Sankey.sankey()
	// 			.nodeID(({ index: i }) => N[i])
	// 			.nodeAlign(nodeAlign)
	// 			.nodeWidth(nodeWidth)
	// 			.nodePadding(nodePadding)
	// 			.extent([[marginLeft, marginTop], [width - marginRight, height - marginBottom]])
	// 			({ nodes, links });

	// 		//computing titles and labels using layout nodes, to access aggregate values.
	// 		if (typeof format !== "function") format = d3.format(format);
	// 		const Tl = nodeLabel == undefined ? N : nodeLabel == null ? null : d3.map(nodes, nodeLabel);
	// 		const Tt = nodeTitle == null ? null : d3.map(nodes, nodeTitle);
	// 		const Lt = linkTitle == null ? null : d3.map(links, linkTitle);

	// 		//unique identifier for clip path to avoid conflixts
	// 		const uid = '0-${Math.random().toString(16).slice(2)}';
	// 		console.log("Made it to sankey chart v1")

	// 		const svg = d3.select("#tag-trends-svg")
	// 		console.log("Made it to sankey svg")
	// 			.attr("width", width)
	// 			.attr("height", height)
	// 			.attr("viewBox", [0, 0, width, height])
	// 			.attr("style", "max-width: 100%; height: auto; height: intrinsic;");

	// 		const node = svg.append("g")
	// 			.attr("stroke", nodeStroke)
	// 			.attr("stroke-width", nodeStrokeWidth)
	// 			.attr("stroke-opacity", nodeStrokeOpacity)
	// 			.attr("stroke-linejoin", nodeStrokeLinejoin)
	// 			.selectAll("rect")
	// 			.data(nodes)
	// 			.join("rect")
	// 			.attr("x", d => d.x0)
	// 			.attr("y", d => d.y0)
	// 			.attr("height", d => d.y1 - d.y0)
	// 			.attr("width", d => d.x1 - d.x0)

	// 		if (G) node.attr("fill", ({ index: i }) => color(G[i]));
	// 		if (Tt) node.append("title").text(({ index: i }) => Tt[i]);

	// 		const link = svg.append("g")
	// 			.attr("fill", "none")
	// 			.attr("stroke-opacity", linkStrokeOpacity)
	// 			.selectAll("g")
	// 			.data(links)
	// 			.join("g")
	// 			.style("mix-blend-mode", linkMixBlendMode);

	// 		if (linkColor === "source-target") link.append("linearGradient")
	// 			.attr("id", d => '${uid}-link-${d.index}')
	// 			.attr("gradientUnits", "userSpaceOnUse")
	// 			.attr("x1", d => d.source.x1)
	// 			.attr("x2", d => d.target.x0)
	// 			.call(gradient => gradient.append("stop")
	// 				.attr("offset", "0%")
	// 				.attr("stop-color", ({ source: { index: i } }) => color(G[i])))
	// 			.call(gradient => gradient.append("stop")
	// 				.attr("offset", "100%")
	// 				.attr("stop-color", ({ target: { index: i } }) => color(G[i])));

	// 		link.append("path")
	// 			.attr("d", linkPath)
	// 			.attr("stroke", linkColor === "source-target" ? ({ index: i }) => 'url(#${uid}-link-${i}))'
	// 				: linkColor === "source" ? ({ source: { index: i } }) => color(G[i])
	// 					: linkColor === "target" ? ({ target: { index: i } }) => color(G[i])
	// 						: linkColor)
	// 			.attr("stroke-width", ({ width }) => Math.max(1, width))
	// 			.call(Lt ? path => path.append("title").text(({ index: i }) => Lt[i]) : () => { });

	// 		if (Tl) svg.append("g")
	// 			.attr("font-family", "sans-serif")
	// 			.attr("font-size", 10)
	// 			.selectAll("text")
	// 			.data(nodes)
	// 			.join("text")
	// 			.attr("x", d => d.x0 < width / 2 ? d.x1 + nodeLabelPadding : d.x0 - nodeLabelPadding)
	// 			.attr("y", d => (d.y1 + d.y0) / 2)
	// 			.attr("dy", "0.35em")
	// 			.attr("text-anchor", d => d.x0 < width / 2 ? "start" : "end")
	// 			.text(({ index: i }) => Tl[i]);

	// 		function intern(value) {
	// 			return value !== nul && typeof value === "object" ? value.valueOf() : { value };
	// 		}
	// 		return Object.assign(svg.node(), { scales: { color } });
	// 	}



}



export function onInsightsTagTrends() {
	//const sankeyChart = new TagTrends().works();
	const sankeyChart = new TagTrends().init();
	d3.select('#tag-trends').append("p").html("I'm in d3!")
}





