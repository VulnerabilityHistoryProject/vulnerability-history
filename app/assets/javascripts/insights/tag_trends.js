import * as d3 from "d3";
import $ from "jquery";
import { vulnTable as vulnTable } from "../vulnerabilities/vulnTable";

export default function TagTrends() {
  var testTagMap = null;
  this.setData = function () {
    getJsonData();
  };

  this.init = function () {
    //get the map of all tags
    $.ajax({
      type: "GET",
      url: `/api/tags?map=true`,
      dataType: "json",
      success: function (response) {
        testTagMap = response;
      },
      error: function (response) {
        console.log("error");
      },
    });

    //Adding family listners
    document
      .getElementById("family1")
      .addEventListener("change", getJsonData, false);

    document
      .getElementById("family2")
      .addEventListener("change", getJsonData, false);

    document
      .getElementById("family3")
      .addEventListener("change", getJsonData, false);

    document
      .getElementById("family4")
      .addEventListener("change", getJsonData, false);
  };

  const getJsonData = function () {
    var firstFamily = document.getElementById("family1").value;
    var secondFamily = document.getElementById("family2").value;
    var thirdFamily = document.getElementById("family3").value;
    var fourthFamily = document.getElementById("family4").value;

    //make sure all families are selected
    if (
      firstFamily != "-- Select a Family --" &&
      secondFamily != "-- Select a Family --" &&
      thirdFamily != "-- Select a Family --" &&
      fourthFamily != "-- Select a Family --"
    ) {
      //if the same family is selected more than once warn the user
      if (
        firstFamily == secondFamily ||
        firstFamily == thirdFamily ||
        firstFamily == fourthFamily ||
        secondFamily == thirdFamily ||
        secondFamily == fourthFamily ||
        thirdFamily == fourthFamily
      ) {
        alert("Please select distict families in each dropdown");
      } else {
        $.ajax({
          type: "GET",
          url: "http://localhost:3000/api/insights/tag-trends",
          data: {
            family1: firstFamily,
            family2: secondFamily,
            family3: thirdFamily,
            family4: fourthFamily,
          },
          dataType: "json",
          success: function (response) {
            removeDiagram();
            createDiagram(response);
          },
          error: function (response) {
            createDiagram(response);
          },
        });
      }
    }
  };

  const removeDiagram = function () {
    //removing the current diagram
    var diagram = document.getElementById("tag-trends");
    diagram.parentNode.removeChild(diagram);

    //find the tag tends description for the placement of the new diagram below
    const tagDescription = document.getElementById("diagramDescription");

    //create the new diagram div
    const div = document.createElement("div");
    div.setAttribute("id", "tag-trends");

    //place new diagram
    tagDescription.parentNode.insertBefore(div, tagDescription.nextSibling);

    //if the diagram changes the vuln table must as well
    removeVulnTable();
  };

  const removeVulnTable = function () {
    //hide the vulntable label
    document.getElementById("vulnTableDescription").style.display = "none";

    //removing the current vulnerability table
    var vulnTableWrapper = document.getElementById("vulndatatable_wrapper");
    if (vulnTableWrapper) {
      vulnTableWrapper.parentNode.removeChild(vulnTableWrapper);
    }

    //find the vulnerability table discription for the placement of the new table below
    const vulnDescription = document.getElementById("vulnTableDescription");

    //create the new vulnerability table
    const table = document.createElement("table");
    table.setAttribute("id", "vulndatatable");
    table.setAttribute("class", "display");
    table.setAttribute("width", "100%");

    //place new vulnerability table
    vulnDescription.parentNode.insertBefore(table, vulnDescription.nextSibling);
  };

  const createDiagram = function (jsonData) {
    //make the diagram label visable
    document.getElementById("diagramDescription").style.display = "block";

    var margin = { top: 10, right: 10, bottom: 10, left: 10 },
      width = 750 - margin.left - margin.right,
      height = 780 - margin.top - margin.bottom;

    var d3Sankey = require("d3-sankey");
    var d3 = require("d3");

    //color for selected nodes and links
    const colorWhenSelected = "#000";
    //minumum width for links
    const minimumLinkWidth = 3;

    //Selected Nodes
    var selectedNodes = [];

    var svg = d3
      .select("#tag-trends")
      .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    //Color scale
    var color = d3.scaleOrdinal(d3.schemeCategory10);

    //Scaling of the diagram itself
    var scale = d3
      .scaleLinear()
      .domain([0, 1]) //input
      .range([0, 1]); //output

    var sankey_diagram = d3Sankey
      .sankey()
      .nodeId(function (d) {
        return d.name;
      })
      .nodeWidth(scale(30))
      .nodePadding(scale(10))
      .size([scale(width), scale(height)]);

    var graph = sankey_diagram(jsonData);

    sankey_diagram.nodes(graph.nodes).links(graph.links);

    // add in the links
    var link = svg
      .append("g")
      .selectAll(".link")
      .data(graph.links)
      .enter()
      .append("path")
      .attr("class", "link")
      .attr("d", d3Sankey.sankeyLinkHorizontal())
      .attr("id", function (d, i) {
        d.id = i;
        return "link-" + i;
      })
      .style("stroke-width", ({ width }) => Math.max(minimumLinkWidth, width))
      .style("fill", "none")
      .style("stroke", (d, i) => {
        // making unique gradient ids
        const gradientID = `gradient${i}`;

        var startColor = colorConverter(d.source.name);
        const stopColor = colorConverter(d.target.name);

        const defs = svg.append("defs");
        const linearGradient = defs
          .append("linearGradient")
          .attr("id", gradientID);
        linearGradient
          .attr("gradientUnits", "userSpaceOnUse")
          .attr("x1", d.source.x1)
          .attr("x2", d.target.x0)
          .call((gradient) =>
            gradient
              .append("stop")
              .attr("offset", "0%")
              .attr("stop-color", stopColor)
          )
          .call((gradient) =>
            gradient
              .append("stop")
              .attr("offset", "100%")
              .attr("stop-color", startColor)
          );
        return `url(#${gradientID})`;
      })
      .style("stroke-opacity", 0.4)
      .on("mouseover", function (d) {
        d3.select(this).style("stroke-opacity", 0.2);
      })
      .on("mouseout", function (d) {
        d3.select(this).style("stroke-opacity", 0.4);
      })
      .sort(function (a, b) {
        return b.y1 - b.y0 - (a.y1 - a.y0);
      })
      .append("title")
      .text(function (d) {
        return (
          d.source.name +
          " â†’ " +
          d.target.name +
          "\n" +
          "Total Vulnerabilities: " +
          d.value
        );
      });

    //add in the nodes
    var node = svg
      .append("g")
      .selectAll(".node")

      .data(graph.nodes)
      .enter()
      .append("g")
      .attr("class", "node")
      .attr("transform", function (d) {
        return "translate(" + d.x0 + "," + d.y0 + ")";
      });

    // add the rectangles for the nodes
    node
      .append("rect")
      .attr("height", function (d) {
        return scale(d.y1 - d.y0);
      })
      .attr("width", sankey_diagram.nodeWidth())
      .style("fill", function (d) {
        return (d.color = color(d.name.replace(/ .*/, "")));
      })
      .style("stroke", function (d) {
        return d3.rgb(d.color).darker(2);
      })
      .style("cursor", "move")
      .style("fill-opacity", 0.9)
      .style("shape-rendering", "crispEdges")
      .on("mouseover", function (d) {
        d3.select(this).style("fill-opacity", 0.4);
      })
      .on("mouseout", function (d) {
        d3.select(this).style("fill-opacity", 0.8);
      })
      .on("click", function (d) {
        //add/remove node
        let added = haddleSelectedNode(d3.select(this).property("__data__"));

        //change node color
        if (added) {
          d3.select(this).style("fill", colorWhenSelected);
        } else {
          d3.select(this).style(
            "fill",
            colorConverter(d3.select(this).property("__data__").name)
          );
        }

        //change link color
        haddleSelectedLinksColor(d3.select(this).property("__data__"));

        //update vuln table
        discriptionGenerator();
      })
      //hover text
      .append("title")
      .text(function (d) {
        return d.name + "\n" + "Total: " + d.value;
      })
      .style("select", "none")
      .style("text", "none")
      .style("text-shadow", "0 10000px 0 #fff");

    // add in the title for the nodes
    node
      .append("text")
      .attr("x", -6)
      .attr("y", function (d) {
        return Math.abs((d.y1 - d.y0) / 2);
      })
      .attr("dy", ".35em")
      .attr("text-anchor", "end")
      .attr("transform", null)
      .text(function (d) {
        return d.name;
      })
      .filter(function (d) {
        return d.x0 < width / 2;
      })
      .attr("x", 6 + sankey_diagram.nodeWidth())
      .attr("text-anchor", "start");

    // the function for moving the nodes but this doesn't work
    function dragmove(d) {
      d3.select(this).attr(
        "transform",
        "translate(" +
          d.x0 +
          "," +
          (d.y0 = Math.max(0, Math.min(height - (d.y1 - d.y0), d3.event.y))) +
          ")"
      );
      sankey.relayout();
      link.attr("d", d3Sankey.sankeyLinkHorizontal());
    }

    //haddles adding or removing a node from the selected node array and returns true if added false if removed
    function haddleSelectedNode(node) {
      var newNode = true;

      for (let i = 0; i < selectedNodes.length && newNode; i++) {
        if (selectedNodes[i].index == node.index) {
          newNode = false;
          selectedNodes.splice(i, 1);
        }
      }

      if (newNode) {
        selectedNodes.push(node);
      }

      return newNode;
    }

    function haddleSelectedLinksColor(node) {
      var found = false;

      //if the node is selected check for link paths, else deselect all links
      if (selectedNodes.some((e) => e.name == node.name)) {
        //check source links
        for (let i = 0; i < node.sourceLinks.length; i++) {
          for (let j = 0; j < selectedNodes.length && !found; j++) {
            found = node.sourceLinks[i].target.index == selectedNodes[j].index;
          }
          setLinkColor(node.sourceLinks[i].id, found, node.sourceLinks[i]);
          found = false;
        }

        //check target links
        for (let i = 0; i < node.targetLinks.length; i++) {
          for (let j = 0; j < selectedNodes.length && !found; j++) {
            found = node.targetLinks[i].source.index == selectedNodes[j].index;
          }
          setLinkColor(node.targetLinks[i].id, found, node.targetLinks[i]);
          found = false;
        }
      } else {
        //clear source links
        for (let i = 0; i < node.sourceLinks.length; i++) {
          setLinkColor(node.sourceLinks[i].id, found, node.sourceLinks[i]);
        }

        //clear target links
        for (let i = 0; i < node.targetLinks.length; i++) {
          setLinkColor(node.targetLinks[i].id, found, node.targetLinks[i]);
        }
      }
    }

    function setLinkColor(id, selected, link) {
      if (selected) {
        d3.select("#link-" + id).style("stroke", colorWhenSelected);
        d3.select("#link-" + id).style("stroke-opacity", 1);
        d3.select("#link-" + id)
          .on("mouseover", function (d) {
            d3.select(this).style("stroke-opacity", 0.5);
          })
          .on("mouseout", function (d) {
            d3.select(this).style("stroke-opacity", 1);
          });
      } else {
        d3.select("#link-" + id).style("stroke-opacity", 0.4);
        d3.select("#link-" + id).style("stroke", `url(#gradient${link.index})`);
        d3.select("#link-" + id)
          .on("mouseover", function (d) {
            d3.select(this).style("stroke-opacity", 0.2);
          })
          .on("mouseout", function (d) {
            d3.select(this).style("stroke-opacity", 0.4);
          });
      }
    }

    function discriptionGenerator() {
      let discription = [];

      for (let i = 0; i < selectedNodes.length; i++) {
        discription.push(selectedNodes[i].name);
      }

      removeVulnTable();

      if (discription.length > 0) {
        getTagOverlaps(discription);
      }
    }

    function getTagOverlaps(namesArray) {
      $.ajax({
        type: "GET",
        url: "http://localhost:3000/api/tags/overlaps",
        data: {
          shortnames_arr: namesArray,
        },
        dataType: "json",
        success: function (response) {
          //parse the returned json data so it is not just a string
          response.forEach((item) => {
            item.tag_json = JSON.parse(item.tag_json);
          });

          //make the label visable again
          document.getElementById("vulnTableDescription").style.display =
            "block";

          vulnTable(response, testTagMap, "#vulndatatable");
        },
        error: function (response) {
          console.log("error");
        },
      });
    }

    function colorConverter(colorName) {
      return color(colorName.replace(/ .*/, ""));
    }
  };
}
export function onInsightsTagTrends() {
  const sankeyChart = new TagTrends().init();
}
