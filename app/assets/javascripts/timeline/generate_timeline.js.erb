/**
 * Created by ekbos on 10/6/2016.
 */

/*
/**
 * Function used to animate the loading of the horizontal timeline
 *
jQuery(document).ready(function ($) {
  var timelineBlocks = $('.cd-timeline-block'),
      offset = 0.8;

  //hide timeline blocks which are outside the viewport
  hideBlocks(timelineBlocks, offset);

  //on scolling, show/animate timeline blocks when enter the viewport
  $(window).on('scroll', function () {
    (!window.requestAnimationFrame)
        ? setTimeout(function () {
      showBlocks(timelineBlocks, offset);
    }, 100)
        : window.requestAnimationFrame(function () {
      showBlocks(timelineBlocks, offset);
    });
  });

  function hideBlocks(blocks, offset) {
    blocks.each(function () {
      ( $(this).offset().top > $(window).scrollTop() + $(window).height() * offset ) && $(this).find('.cd-timeline-img, .cd-timeline-content').addClass('is-hidden');
    });
  }

  function showBlocks(blocks, offset) {
    blocks.each(function () {
      ( $(this).offset().top <= $(window).scrollTop() + $(window).height() * offset && $(this).find('.cd-timeline-img').hasClass('is-hidden') ) && $(this).find('.cd-timeline-img, .cd-timeline-content').removeClass('is-hidden').addClass('bounce-in');
    });
  }
});
*/

/**
 * Timeline functions for horizontal timeline
 */

/**
 * Given a string d, create a date
 * @param d - json format date string
 * @returns {Date} a JS date item
 */
function getDate(d) {
  return new Date(d);
}

/**
 * Adds a number of days to a given date
 * @param date - the starting date
 * @param days - the number of days to add
 * @returns {Date} A date + days
 */
function addDays(date, days) {
  var result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
}

/**
 * Calculates the range between two dates
 * @param a - the start date
 * @param b - the end date
 * @returns {number} the difference (absolute) between the dates
 */
function calculateDateRange(a, b) {

  var utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
  var utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());

  return Math.abs(Math.floor((utc2 - utc1) / (86400000)));
}

/**
 * Get the date groups given a number of slots and the bins (for computing range)
 * @param startDate - the start date
 * @param endDate - the end date
 * @param slots - the total number of bunches to make
 * @returns {Array} the dates to place items around
 */
function getDatePadLocations(startDate, endDate, slots) {
  var timespan = calculateDateRange(startDate, endDate);
  var increment = (timespan / slots);
  var days = [];
  for (var i = 0; i < slots; i++) {
    days.push(addDays(startDate, i * increment))
  }
  days.push(endDate);
  return days;
}

/**
 * Go through a list of dates and find the date closest to the provided date
 * @param daysList - the list of dates to look through
 * @param date - a js date object
 * @returns {*} the date closest to the date provided in the js object
 */
function getClosestDate(daysList, date) {
  var closestDate = daysList[0];
  for (i = 0; i < daysList.length - 1; i++) {
    if (calculateDateRange(daysList[i], date) < calculateDateRange(closestDate, daysList[i])) {
      closestDate = daysList[i];
    }
  }
  return closestDate;
}

/**
 * Get the y coordinate to place the vulnerability item
 * @param date - the date to check the y coordinate for
 * @param occupiedSlots - a dictionary containing dates and number of items at that date
 * @returns number y coordinate to place tile at
 */
function getY(date, occupiedSlots) {
  if (occupiedSlots[date] == null) {
    occupiedSlots[date] = 1;
    return 1;
  }
  else {
    occupiedSlots[date] = occupiedSlots[date] += 1;
    return occupiedSlots[date];
  }
}

/**
 * Given a type (string) either v,p,b,or x, return a hex color string
 * @param type - a string that specifies the type of vulnerability, a single character
 * @returns {*} the color for that vulnerability
 */
function getColor(type) {
  <% EventStyle.all.each do |es| %>
    if (type == "<%= es.event_type %>") {
      return "<%= es.color %>";
    }
  <% end %>
    return "#888888";
}

/**
 * Gets correct img url and CSS tags given a vulnerability type
 * @param vType the vulnerability to look up
 */
function getCssURL(vType) {
  switch (vType) {
    case ('vulnerability'):
      return [('<%=image_path('timeline/cd-icon-vulnerability.svg') %>'), 'cd-vulnerability'];
      break;
    case('fix'):
      return [('<%=image_path('timeline/cd-icon-patch.svg') %>'), 'cd-patch'];
      break;
    case('patch'):
      return [('<%=image_path('timeline/cd-icon-bug.svg') %>'), 'cd-bug'];
      break;
    default:
      return [('<%=image_path('timeline/cd-icon-vulnerability.svg') %>'), 'cd-vulnerability'];
      break;
  }
}


/**
 * Temporary function to remove the svg on draw in order to update it, will eventually be replaced with actual update
 * methods.
 */
function removeSVG() {
  var svg = d3.select("svg");
  svg.selectAll("*").remove();
  d3.select("#hTimeline").remove();
}

/**
 * Data filtering function checks if the data sent in should be shown
 * @return boolean data_type is visible
 */
function is_visible(data_type) {
  var types = [];
  var valid_types = ["vulnerability", "patch", "fix"];
  if ($('#cmn-toggle-vulnerabilities').is(':checked')) {
    types.push("vulnerability");
  }
  if ($('#cmn-toggle-fixes').is(':checked')) {
    types.push("fix");
  }
  if ($('#cmn-toggle-patches').is(':checked')) {
    types.push("patch");
  }

  if (types.length == 0) {
    return true;
  }
  if (($.inArray(data_type, types) > -1) || (!($.inArray(data_type, valid_types) > -1))) {
    return true;
  }
  else {
    return false;
  }
}


function getMinDate(date, minDate) {
  if (date < minDate) {
    return date;
  }
  else {
    return minDate;
  }
}


function getMaxDate(date, maxDate) {
  if (date > maxDate) {
    return date;
  }
  else {
    return maxDate;
  }
}

/**
 * Called on filter update, removes all of the timeline items when filters are changed
 */
function deleteVerticalTimeline() {
  $(".cd-timeline-block").remove();
}



function generateTimeline(dataset) {
  removeSVG();
  deleteVerticalTimeline();

  var toAdd = document.createDocumentFragment();
  var margin = {top: 10, right: 20, bottom: 30, left: 60},
      width = 960 - margin.left - margin.right,
      height = 500 - margin.top - margin.bottom;

  var x = d3.scaleTime().range([0, width]);
  var y = d3.scaleLinear().range([height, 0]);


  var svg = d3.select('#horizontal-timeline').append("svg")
      .attr("width", "100%")
      .attr("viewBox", "0 0 960 500")
      .attr("id", "hTimeline")
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var minDate = getDate(Date.now()),
      maxDate = getDate('0');


  $(".event").each(function () { //TODO eventually switch this over to using the passed in dataset
    var updated_at = $(this).find("#date").text().trim();
    minDate = getMinDate(getDate(updated_at), minDate);
    maxDate = getMaxDate(getDate(updated_at), maxDate);
  });
  // Set the scale domains.
  x.domain([minDate, maxDate]);
  y.domain([0, 30]);
  getDatePadLocations(minDate, maxDate);

  var slots = 25; // number of different date slots
  var datePadLocations = getDatePadLocations(minDate, maxDate, slots);
  var occupiedXYValues = {};

  //TODO right now using two loops, the previous loop will eventually use indexing instead
  $(".event").each(function () {
    var id = $(this).find("#id").text().trim();
    var name = $(this).find("#title").text().replace(/ /g, '');
    var description = $(this).find("#description").text().trim();
    var date = $(this).find("#date").text().trim();
    var data_type = $(this).find("#type").text().trim();
    data_type = data_type || "no_type";
    if (is_visible(data_type)) {

      // Define the div for the tooltip
      var div = d3.select("body").append("div")
          .attr("class", "tooltip")
          .style("opacity", 0);

      date = getDate(date);
      // On each item in the object list, append a rectangle to the horizontal timeline
      svg.append("svg:rect")
          .attr("class", "bin")
          .attr("x", function () {
            return x(getClosestDate(datePadLocations, date));
          })
          .attr("y", function () {
            return y(getY(getClosestDate(datePadLocations, date), occupiedXYValues));
          })
          .attr("width", 20)
          .attr("height", 15)
          .attr("rx", 3)
          .attr("ry", 3)
          .attr("fill", function (d) {
            return getColor(data_type)
          })
          .on('click', function (d) {
            window.location.href = '#' + id;
            d3.select(this).attr("stroke", "#00FF00")
          })
          .on("mouseover", function (d) {
            d3.select(this).attr("stroke", "#00FF00");
            /*div.transition()
                .duration(200)
                .style("opacity", .9);
            div.html(name + "<br/>")
                .style("left", (d3.event.pageX) + "px")
                .style("top", (d3.event.pageY - 28) + "px"); */
          })
          .on("mouseout", function () {
            d3.select(this).attr("stroke", "");
            /* div.transition()
                .duration(500)
                .style("opacity", 0); */
          });


      /**
       *  The following code is used to generate the vertical timeline
       */

      var newDiv = document.createElement('div');
      newDiv.id = name;
      newDiv.className = 'cd-timeline-block';
      newDiv.innerHTML = $('#hiddenArea').html();

      newDiv.innerHTML = newDiv.innerHTML.replace("$TIMESTAMP$", date);
      newDiv.innerHTML = newDiv.innerHTML.replace("$DESCRIPTION$", description);
      newDiv.innerHTML = newDiv.innerHTML.replace("$TITLE$", name);
      newDiv.innerHTML = newDiv.innerHTML.replace("$NAME$", id);
      newDiv.innerHTML = newDiv.innerHTML.replace("<%=image_path('timeline/cd-icon-default.svg') %>", function () {
        return getCssURL(data_type)[0];
      });
      newDiv.innerHTML = newDiv.innerHTML.replace("$HREFURL$", '');
      newDiv.innerHTML = newDiv.innerHTML.replace("cd-default", function () {
        return getCssURL(data_type)[1];
      });
      toAdd.appendChild(newDiv);
    }
  });
  // Append the x-axis to the horizontal timeline
  svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x));

  document.getElementById('cd-timeline').appendChild(toAdd);
}
