/**
 * Given a string d, create a date
 * @param d - json format date string
 * @returns {Date} a JS date item
 */
function getDate(d) {
    return new Date(d);
}

/**
 * Adds a number of days to a given date
 * @param date - the starting date
 * @param days - the number of days to add
 * @returns {Date} A date + days
 */
function addDays(date, days) {
    var result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
}

/**
 * Calculates the range between two dates
 * @param a - the start date
 * @param b - the end date
 * @returns {number} the difference (absolute) between the dates
 */
function calculateDateRange(a, b) {

    var utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
    var utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());

    return Math.abs(Math.floor((utc2 - utc1) / (86400000)));
}

/**
 * Get the date groups given a number of slots and the bins (for computing range)
 * @param startDate - the start date
 * @param endDate - the end date
 * @param slots - the total number of bunches to make
 * @returns {Array} the dates to place items around
 */
function getDatePadLocations(startDate, endDate, slots) {
    var timeSpan = calculateDateRange(startDate, endDate);
    var increment = (timeSpan / slots);
    var days = [];
    for (var i = 0; i < slots; i++) {
        days.push(addDays(startDate, i * increment))
    }
    days.push(endDate);
    return days;
}

/**
 * Go through a list of dates and find the date closest to the provided date
 * @param daysList - the list of dates to look through
 * @param date - a js date object
 * @returns Date - the date closest to the date provided in the js object
 */
function getClosestDate(daysList, date) {

    var closestDate = daysList[0];
    for (var i = 0; i < daysList.length - 1; i++) {
        if (calculateDateRange(daysList[i], date) < calculateDateRange(closestDate, daysList[i])) {
            closestDate = daysList[i];
        }
    }
    return closestDate;
}

/**
 * Get the y coordinate to place the vulnerability item
 * @param date - the date to check the y coordinate for
 * @param occupiedSlots - a dictionary containing dates and number of items at that date
 * @returns Integer - y coordinate to place tile
 */
function getY(date, occupiedSlots) {
    if (occupiedSlots[date] == null) {
        occupiedSlots[date] = 1;
        return 1;
    }
    else {
        occupiedSlots[date] = occupiedSlots[date] += 1;
        return occupiedSlots[date];
    }
}

/**
 * Given a type (string) either v,p,b,or x, return a hex color string
 * @param type - a string that specifies the type of vulnerability
 * @returns {*} the color for that vulnerability
 */
function getColor(type) {
    <% EventStyle.all.each do |es| %>
    if (type == "<%= es.event_type %>") {
        return "<%= es.color %>";
    }
    <% end %>
    return "#888888";
}

/**
 * Gets correct img name given a vulnerability type
 * @param type - a string that specifies the type of vulnerability
 */
function getImageName(type) {
    <% EventStyle.all.each do |es| %>
    if (type == "<%= es.event_type %>") {
        return "<%= es.icon %>";
    }
    <% end %>
    return 'bug_report';
}


/**
 * Temporary function to remove the svg on draw in order to update it, will eventually be replaced with actual update
 * methods.
 */
function removeSVG() {
    var svg = d3.select("svg");
    svg.selectAll("*").remove();
    d3.select("#hTimeline").remove();
}

/**
 * Given a type, check if it is contained in types dictionary, and add it if not
 * @param type - the data_type of the current data point
 * @param types - a type dictionary, containing some (or all) data_types
 */
function update_types(type, types) {
    if (types.indexOf(type) == -1) {
        types.push(type)
    }
    return types
}


/**
 * Title casing function
 * @param str - string to title case
 * @returns String - title cased string
 */
function toTitleCase(str) {
    return str.replace(/\w\S*/g, function (txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
}


/**
 * Given types, generate toggle switches for them for filtering
 * @param types - a type dictionary, containing all data_types
 */
function generate_type_switches(types) {
    var container = document.createDocumentFragment();
    for (var i = 0; i < types.length; i++) {
        // generate checkbox
        var checkbox = document.createElement('input');
        checkbox.id = types[i] + "-toggle";
        checkbox.type = "checkbox";
        // generate label for checkbox
        var label = document.createElement('label');
        label.htmlFor = types[i] + "-toggle";
        label.appendChild(document.createTextNode(toTitleCase(types[i])));
        container.appendChild(checkbox);
        container.appendChild(label);

    }
    document.getElementById('toggle-block').appendChild(container);
}

/**
 * Data filtering function checks if the data sent in should be shown
 * @return boolean data_type is visible
 */
function is_visible(data_type) {
    var types = visibleTypes(valid_types);

    if (types.length == valid_types.length) {
        return true;
    }

    return ($.inArray(data_type, types) > -1) || (!($.inArray(data_type, valid_types) > -1));
}


/**
 * Returns the visible types, given the valid types list
 * @global valid_types
 * @returns Array - the visible types
 */
function visibleTypes() {
    var types = [];
    for (var i = 0; i < valid_types.length; i++) {
        if ($('#' + valid_types[i] + '-toggle').is(':checked')) {
            types.push(valid_types[i])
        }
    }

    if (types.length == 0) {
        return valid_types;
    }
    else return types;

}

/**
 * Given a date, check if it is greater than the minimum date, and return it instead if it is
 * @param date - the date to validate
 * @param minDate - the date that is the current minimum
 * @returns Date - smaller of two values
 */
function getMinDate(date, minDate) {
    if (date < minDate) {
        return date;
    }
    else {
        return minDate;
    }
}

/**
 * Given a date, check if it is greater than the maximum date, and return it instead if it is
 * @param date - the date to validate
 * @param maxDate - the date that is the current maximum
 * @returns Date - larger of two values
 */
function getMaxDate(date, maxDate) {
    if (date > maxDate) {
        return date;
    }
    else {
        return maxDate;
    }
}

/**
 * Called on filter update, removes all of the timeline items when filters are changed
 */
function deleteVerticalTimeline() {
    $(".cd-timeline-block").remove();
}

/**
 * Global Variable to contain data types, used for filtering
 * @type {Array}
 */
var valid_types = [];
/**
 * Global variables used to store the minimum and maximum date, computed by initialize timeline and used
 * when the timeline is drawn
 * @type {Date}
 */
var minDate = getDate(Date.now()),
    maxDate = getDate('0');


var margin = {top: 10, right: 20, bottom: 30, left: 60},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

var iconWidth = 20,
    iconHeight = 15,
    iconCornerRadius = 3;

var slots = width / iconWidth; // number of different date slots

var datePadLocations;


/**
 * Javascript dictionary object, stores the timeline data as a dictionary object
 * @type {{}}
 */
var timelineData = {};

/**
 * Variable that sets the minimum number of items required in a column to begin grouping
 * @type {number} the number of items in the date column to start grouping
 */
var minimumGroupingLength = 30;
var groupSize = 5;
/**
 * Function to create the dictionary of timeline data, basically doing what getClosestDate does, but creating an object
 * This is incredibly complicated because I'm nesting data types like crazy - it looks like this:
 * dict(dateGroup: dict(data_type: list(eventAsDict)))
 * Expanded that looks like:
 *
 * {
 *  dateGroup: {
 *              data_type: [
 *                          {
 *                            "id": id,
 *                            "name": name,
 *                            "description": description,
 *                            "date": date,
 *                            "data_type": data_type
 *                           }
 *                          ]
 *             }
 * }
 *
 */
function createTimelineData() {
    $(".event").each(function () {
        var id = $(this).find("#id").text().trim();
        var name = $(this).find("#title").text().replace(/ /g, '');
        var description = $(this).find("#description").text().trim();
        var string_date = $(this).find("#date").text().trim();
        var date = getDate(string_date);
        var data_type = $(this).find("#type").text().trim();
        if (data_type == 'commit_filepath') {
            data_type = 'edit'
        }
        var eventAsDict = {
            "id": id,
            "name": name,
            "description": description,
            "date": date,
            "data_type": data_type
        };
        var closestDate = getClosestDate(datePadLocations, date);
        if (timelineData[closestDate]) {
            var dataTypeDict = timelineData[closestDate];
            if (dataTypeDict[data_type]) {
                var listOfEvents = dataTypeDict[data_type];
                listOfEvents.push(eventAsDict);
                dataTypeDict[data_type] = listOfEvents;
            }
            else {
                dataTypeDict[data_type] = [eventAsDict];
            }
        }
        else {
            var dict = {};
            dict[data_type] = [eventAsDict];
            timelineData[closestDate] = dict;
        }
    });
}

/**
 * @global timelineData
 * @global timelineDataKeys
 * Function to run through all items in the timelineData dictionary monster, and update items that aren't grouped to use
 * grouping
 */
function createGroupedObjects() {

    var timelineDataKeys = Object.keys(timelineData); // timelineDataKeys represents the date groups
    for (var i = 0; i < timelineDataKeys.length; i++) {
        if (timelineData[timelineDataKeys[i]]) {
            var timelineTypeDict = timelineData[timelineDataKeys[i]];
            var timelineTypeKeys = Object.keys(timelineTypeDict);
            // iterate through second level dictionary and check lengths of items
            for (var j = 0; j < timelineTypeKeys.length; j++) {
                var eventsInGroup = timelineTypeDict[timelineTypeKeys[j]];
                eventsInGroup = createGroups(eventsInGroup);
                timelineTypeDict[timelineTypeKeys[j]] = eventsInGroup;

            }
            timelineData[timelineDataKeys[i]] = timelineTypeDict;
        }
    }

}

/**
 * Function to group the items into the groupSize specified globally
 * @param eventsInGroup - a list of all events (filtered by type) in the date span
 * @global groupSize - the size of groups to create
 */
function createGroups(eventsInGroup) {
    var oldArray = eventsInGroup;
    var newArray = [];
    var j = 0;
    for (var i = 0; i < oldArray.length; i++) {
        if (i % groupSize === 0) {
            j++
        }
        if (!newArray[j]) newArray[j] = [];
        newArray[j].push(oldArray[i])
    }
    return newArray;

}



/**
 * Function to first find minimum and maximum dates, append the checkboxes, and finally draw the timeline
 * Called on the timeline's first run
 */
function initializeTimeline() {
    $(".event").each(function () { // Read events for the first time and find min / max date
        var string_date = $(this).find("#date").text().trim();
        var date = getDate(string_date);
        minDate = getMinDate(date, minDate);
        maxDate = getMaxDate(date, maxDate);

        var data_type = $(this).find("#type").text().trim();
        if (data_type == 'commit_filepath') {
            data_type = 'edit'
        }
        valid_types = update_types(data_type, valid_types)
    });


    datePadLocations = getDatePadLocations(minDate, maxDate, slots);
    generate_type_switches(valid_types);

    createTimelineData();
    createGroupedObjects();
    console.log(timelineData);
    generateTimeline();
}

/**
 * @global valid_types - the valid data types
 * @param timelineTypeKeys
 */
function removeFilteredTypes(timelineTypeKeys) {
    timelineTypeKeys = $(timelineTypeKeys).filter(visibleTypes());
    return timelineTypeKeys;
}


/**
 * Function to draw the timeline - draws both the horizontal and vertical timeline
 */
function generateTimeline() {
    removeSVG();
    deleteVerticalTimeline();
    var toAdd = document.createDocumentFragment();


    var x = d3.scaleTime();
    var y = d3.scaleLinear();
    var svg = d3.select('#horizontal-timeline').append("svg")
        .attr("width", "100%")
        .attr("viewBox", "0 0 960 " + 500)
        .attr("id", "hTimeline")
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Set the scale domains.
    x.domain([minDate, maxDate]).range([0, width]);
    y.domain([0, 30]).range([height, 0]);

    var occupiedXYValues = {};
    var timelineDataKeys = Object.keys(timelineData); // timelineDataKeys represents the date groups
    for (var i = 0; i < timelineDataKeys.length; i++) {
        var timelineTypeDict = timelineData[timelineDataKeys[i]];
        var timelineTypeKeys = Object.keys(timelineTypeDict); // remove Filtered types here
        timelineTypeKeys = removeFilteredTypes(timelineTypeKeys);
        for (var j = 0; j < timelineTypeKeys.length; j++) {
            var timelineGroupsObject = timelineTypeDict[timelineTypeKeys[j]];
            timelineGroupsObject.forEach(function (group) {
                if (group && group.length < groupSize) { // plot all items in groups smaller than groupSize
                    group.forEach(function (event) {
                        if (event && typeof event === 'object') {
                            svg.append("svg:rect")
                                .attr("class", "bin")
                                .attr("x", function () {
                                    return x(getClosestDate(datePadLocations, event['date']));
                                })
                                .attr("y", function () {
                                    return y(getY(getClosestDate(datePadLocations, event['date']), occupiedXYValues));
                                })
                                .attr("width", iconWidth)
                                .attr("height", iconHeight)
                                .attr("rx", iconCornerRadius)
                                .attr("ry", iconCornerRadius)
                                .attr("fill", function () {
                                    return getColor(event['data_type'])
                                })
                                .on('click', function () {
                                    window.location.href = '#' + event['id'];
                                    d3.select(this).attr("stroke", "#00FF00")
                                })
                                .on("mouseover", function () {
                                    d3.select(this).attr("stroke", "#00FF00");
                                  /*div.transition()
                                   .duration(200)
                                   .style("opacity", .9);
                                   div.html(name + "<br/>")
                                   .style("left", (d3.event.pageX) + "px")
                                   .style("top", (d3.event.pageY - 28) + "px"); */
                                })
                                .on("mouseout", function () {
                                    d3.select(this).attr("stroke", "");
                                  /* div.transition()
                                   .duration(500)
                                   .style("opacity", 0); */
                                });

                        }

                    });
                }
                else if (group) { // plot the groups as single blocks
                    var objOne = group[0];
                    var objOneDate = objOne['date'];
                    var div = d3.select("body").append("div")
                        .attr("class", "tooltip right")
                        .style("opacity", 0).style("pointer-events", "none");
                    var iconX = getClosestDate(datePadLocations, objOneDate),
                        iconY = getY(getClosestDate(datePadLocations, objOneDate), occupiedXYValues);
                    var offset = $('#horizontal-timeline').find('svg').children('g').offset(),
                        left = offset.left, top = offset.top;
                    var groupIcon = svg.append("svg:g")
                        .attr("transform", "translate(" + x(iconX) + "," + y(iconY) + ")")
                        .on('click', function () {
                            window.location.href = '#' + objOne['id'];
                            d3.select(this).attr("stroke", "#FFFFFF");
                        })
                        .on("mouseover", function () {
                            d3.select(this).attr("stroke", "#FFFFFF");
                            div.transition()
                                .duration(200)
                                .style("opacity", .9);
                            div.html(group.length + "<br/>" + group[0]['data_type'])
                                .style("left", x(iconX) + left + "px")
                                .style("top", y(iconY) + top + "px");
                        })
                        .on("mouseout", function () {
                            d3.select(this).attr("stroke", "");
                            div.transition()
                                .duration(25)
                                .style("opacity", 0);
                        });
                    groupIcon
                        .append("rect")
                        .attr("class", "bin")
                        .attr("width", iconWidth)
                        .attr("height", iconHeight)
                        .attr("rx", iconCornerRadius)
                        .attr("ry", iconCornerRadius)
                        .attr("stroke-width", 0.5)
                        .attr("stroke", "#000000")
                        .attr("fill", function () {
                            return getColor(objOne['data_type'])
                        });
                    groupIcon.append("svg:line")
                        .attr("x1", function () {
                            return 0;
                        })
                        .attr("y1", function () {
                            return iconHeight / 2 - iconHeight / 8;
                        })
                        .attr("x2", function () {
                            return iconWidth
                        })
                        .attr("y2", function () {
                            return iconHeight / 2 - iconHeight / 8;
                        })
                        .attr("stroke-width", 0.5)
                        .attr("stroke", "#000000");
                    groupIcon.append("svg:line")
                        .attr("x1", function () {
                            return 0;
                        })
                        .attr("y1", function () {
                            return iconHeight / 2;
                        })
                        .attr("x2", function () {
                            return iconWidth
                        })
                        .attr("y2", function () {
                            return iconHeight / 2;
                        })
                        .attr("stroke-width", 0.5)
                        .attr("stroke", "#000000");
                    groupIcon.append("svg:line")
                        .attr("x1", function () {
                            return 0;
                        })
                        .attr("y1", function () {
                            return iconHeight / 2 + iconHeight / 8;
                        })
                        .attr("x2", function () {
                            return iconWidth
                        })
                        .attr("y2", function () {
                            return iconHeight / 2 + iconHeight / 8;
                        })
                        .attr("stroke-width", 0.5)
                        .attr("stroke", "#000000");

                }
            });
        }

    }


    $(".event").each(function () { // Read events for the second time, and create the timeline given the data

        var id = $(this).find("#id").text().trim();
        var name = $(this).find("#title").text().replace(/ /g, '');
        var description = $(this).find("#description").text().trim();
        var string_date = $(this).find("#date").text().trim();
        var date = getDate(string_date);
        var data_type = $(this).find("#type").text().trim();
        data_type = data_type || "no_type";
        if (data_type == 'commit_filepath') {
            data_type = 'edit'
        }
        if (is_visible(data_type)) {
          /*
           // Define the div for the tooltip
           var div = d3.select("body").append("div")
           .attr("class", "tooltip")
           .style("opacity", 0);

           var date = getDate(string_date);
           // On each item in the object list, append a rectangle to the horizontal timeline
           svg.append("svg:rect")
           .attr("class", "bin")
           .attr("x", function () {
           return x(getClosestDate(datePadLocations, date));
           })
           .attr("y", function () {
           return y(getY(getClosestDate(datePadLocations, date), occupiedXYValues));
           })
           .attr("width", iconWidth)
           .attr("height", iconHeight)
           .attr("rx", iconCornerRadius)
           .attr("ry", iconCornerRadius)
           .attr("fill", function () {
           return getColor(data_type)
           })
           .on('click', function () {
           window.location.href = '#' + id;
           d3.select(this).attr("stroke", "#00FF00")
           })
           .on("mouseover", function () {
           d3.select(this).attr("stroke", "#00FF00");
           /*div.transition()
           .duration(200)
           .style("opacity", .9);
           div.html(name + "<br/>")
           .style("left", (d3.event.pageX) + "px")
           .style("top", (d3.event.pageY - 28) + "px");
           })
           .on("mouseout", function () {
           d3.select(this).attr("stroke", "");
           /* div.transition()
           .duration(500)
           .style("opacity", 0);
           });

           */
            /**
             *  The following code is used to generate the vertical timeline
             */
            var newDiv = document.createElement('div');
            newDiv.id = name;
            newDiv.className = 'cd-timeline-block';
            newDiv.innerHTML = $('#hiddenBlock').html();

            newDiv.innerHTML = newDiv.innerHTML.replace("$TIMESTAMP$", date.toUTCString());
            newDiv.innerHTML = newDiv.innerHTML.replace("$DESCRIPTION$", description);
            newDiv.innerHTML = newDiv.innerHTML.replace("$TITLE$", name);
            newDiv.innerHTML = newDiv.innerHTML.replace("$NAME$", id);
            newDiv.innerHTML = newDiv.innerHTML.replace("bug_report", function () {
                return getImageName(data_type);
            });
            newDiv.innerHTML = newDiv.innerHTML.replace("$HREFURL$", '');
            newDiv.innerHTML = newDiv.innerHTML.replace("red", function () {
                return getColor(data_type);
            });
            toAdd.appendChild(newDiv);
        }
    });

// Append the x-axis to the horizontal timeline
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x));

    document.getElementById('cd-timeline').appendChild(toAdd);
}
