/**
 * Given a string d, create a date
 * @param d - json format date string
 * @returns {Date} a JS date item
 */
function getDate(d) {
    return new Date(d);
}

/**
 * Adds a number of days to a given date
 * @param date - the starting date
 * @param days - the number of days to add
 * @returns {Date} A date + days
 */
function addDays(date, days) {
    var result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
}

/**
 * Calculates the range between two dates
 * @param a - the start date
 * @param b - the end date
 * @returns {number} the difference (absolute) between the dates
 */
function calculateDateRange(a, b) {

    var utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
    var utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());

    return Math.abs(Math.floor((utc2 - utc1) / (86400000)));
}

/**
 * Get the date groups given a number of slots and the bins (for computing range)
 * @param startDate - the start date
 * @param endDate - the end date
 * @param slots - the total number of bunches to make
 * @returns {Array} the dates to place items around
 */
function getDatePadLocations(startDate, endDate, slots) {
    var timeSpan = calculateDateRange(startDate, endDate);
    var increment = (timeSpan / slots);
    var days = [];
    for (var i = 0; i < slots; i++) {
        days.push(addDays(startDate, i * increment))
    }
    days.push(endDate);
    return days;
}

/**
 * Go through a list of dates and find the date closest to the provided date
 * @param daysList - the list of dates to look through
 * @param date - a js date object
 * @returns Date - the date closest to the date provided in the js object
 */
function getClosestDate(daysList, date) {
    var closestDate = daysList[0];
    for (var i = 0; i < daysList.length - 1; i++) {
        if (calculateDateRange(daysList[i], date) < calculateDateRange(closestDate, daysList[i])) {
            closestDate = daysList[i];
        }
    }
    return closestDate;
}

/**
 * Get the y coordinate to place the vulnerability item
 * @param date - the date to check the y coordinate for
 * @param occupiedSlots - a dictionary containing dates and number of items at that date
 * @returns Integer - y coordinate to place tile
 */
function getY(date, occupiedSlots) {
    if (occupiedSlots[date] == null) {
        occupiedSlots[date] = 1;
        return 1;
    }
    else {
        occupiedSlots[date] = occupiedSlots[date] += 1;
        return occupiedSlots[date];
    }
}

/**
 * Given a type (string) either v,p,b,or x, return a hex color string
 * @param type - a string that specifies the type of vulnerability
 * @returns {*} the color for that vulnerability
 */
function getColor(type) {
    <% EventStyle.all.each do |es| %>
    if (type == "<%= es.event_type %>") {
        return "<%= es.color %>";
    }
    <% end %>
    return "#888888";
}

/**
 * Gets correct img name given a vulnerability type
 * @param type - a string that specifies the type of vulnerability
 */
function getImageName(type) {
    <% EventStyle.all.each do |es| %>
    if (type == "<%= es.event_type %>") {
        return "<%= es.icon %>";
    }
    <% end %>
    return 'bug_report';
}


/**
 * Temporary function to remove the svg on draw in order to update it, will eventually be replaced with actual update
 * methods.
 */
function removeSVG() {
    var svg = d3.select("svg");
    svg.selectAll("*").remove();
    d3.select("#hTimeline").remove();
}

/**
 * Given a type, check if it is contained in types dictionary, and add it if not
 * @param type - the data_type of the current data point
 * @param types - a type dictionary, containing some (or all) data_types
 */
function update_types(type, types) {
    if (types.indexOf(type) == -1) {
        types.push(type)
    }
    return types
}


/**
 * Title casing function
 * @param str - string to title case
 * @returns String - title cased string
 */
function toTitleCase(str) {
    return str.replace(/\w\S*/g, function (txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
}


/**
 * Given types, generate toggle switches for them for filtering
 * @param types - a type dictionary, containing all data_types
 */
function generate_type_switches(types) {
    var container = document.createDocumentFragment();
    for (var i = 0; i < types.length; i++) {
        // generate checkbox
        var checkbox = document.createElement('input');
        checkbox.id = types[i] + "-toggle";
        checkbox.type = "checkbox";
        // generate label for checkbox
        var label = document.createElement('label');
        label.htmlFor = types[i] + "-toggle";
        label.appendChild(document.createTextNode(toTitleCase(types[i])));
        container.appendChild(checkbox);
        container.appendChild(label);

    }
    document.getElementById('toggle-block').appendChild(container);
}

/**
 * Data filtering function checks if the data sent in should be shown
 * @return boolean data_type is visible
 */
function is_visible(data_type, valid_types) {
    var types = [];
    for (var i = 0; i < valid_types.length; i++) {
        if ($('#' + valid_types[i] + '-toggle').is(':checked')) {
            types.push(valid_types[i])
        }
    }

    if (types.length == 0) {
        return true;
    }

    return ($.inArray(data_type, types) > -1) || (!($.inArray(data_type, valid_types) > -1));
}

/**
 * Given a date, check if it is greater than the minimum date, and return it instead if it is
 * @param date - the date to validate
 * @param minDate - the date that is the current minimum
 * @returns Date - smaller of two values
 */
function getMinDate(date, minDate) {
    if (date < minDate) {
        return date;
    }
    else {
        return minDate;
    }
}

/**
 * Given a date, check if it is greater than the maximum date, and return it instead if it is
 * @param date - the date to validate
 * @param maxDate - the date that is the current maximum
 * @returns Date - larger of two values
 */
function getMaxDate(date, maxDate) {
    if (date > maxDate) {
        return date;
    }
    else {
        return maxDate;
    }
}

/**
 * Called on filter update, removes all of the timeline items when filters are changed
 */
function deleteVerticalTimeline() {
    $(".cd-timeline-block").remove();
}

/**
 * Global Variable to contain data types, used for filtering
 * @type {Array}
 */
var valid_types = [];
/**
 * Global variables used to store the minimum and maximum date, computed by initialize timeline and used
 * when the timeline is drawn
 * @type {Date}
 */
var minDate = getDate(Date.now()),
    maxDate = getDate('0');

/**
 * Function to first find minimum and maximum dates, append the checkboxes, and finally draw the timeline
 * Called on the timeline's first run
 */
function initializeTimeline() {
    $(".event").each(function () { // Read events for the first time and find min / max date
        var updated_at = $(this).find("#date").text().trim();
        minDate = getMinDate(getDate(updated_at), minDate);
        maxDate = getMaxDate(getDate(updated_at), maxDate);
        var data_type = $(this).find("#type").text().trim();
        if (data_type == 'commit_filepath') {
            data_type = 'edit'
        }
        valid_types = update_types(data_type, valid_types)
    });
    generate_type_switches(valid_types);
    generateTimeline();
}


/**
 * Function to draw the timeline - draws both the horizontal and vertical timeline
 */
function generateTimeline() {
    removeSVG();
    deleteVerticalTimeline();

    var toAdd = document.createDocumentFragment();
    var margin = {top: 10, right: 20, bottom: 30, left: 60},
        width = 960 - margin.left - margin.right,
        height = 500 - margin.top - margin.bottom;

    var x = d3.scaleTime().range([0, width]);
    var y = d3.scaleLinear().range([height, 0]);


    var svg = d3.select('#horizontal-timeline').append("svg")
        .attr("width", "100%")
        .attr("viewBox", "0 0 960 500")
        .attr("id", "hTimeline")
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Set the scale domains.
    x.domain([minDate, maxDate]);
    y.domain([0, 30]);
    getDatePadLocations(minDate, maxDate);

    var slots = width / 20; // number of different date slots
    var datePadLocations = getDatePadLocations(minDate, maxDate, slots);
    var occupiedXYValues = {};


    $(".event").each(function () { // Read events for the second time, and create the timeline given the data
        var id = $(this).find("#id").text().trim();
        var name = $(this).find("#title").text().replace(/ /g, '');
        var description = $(this).find("#description").text().trim();
        var string_date = $(this).find("#date").text().trim();
        var data_type = $(this).find("#type").text().trim();
        data_type = data_type || "no_type";
        if (data_type == 'commit_filepath') {
            data_type = 'edit'
        }
        if (is_visible(data_type, valid_types)) {

            // Define the div for the tooltip
            var div = d3.select("body").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);

            var date = getDate(string_date);
            // On each item in the object list, append a rectangle to the horizontal timeline
            svg.append("svg:rect")
                .attr("class", "bin")
                .attr("x", function () {
                    return x(getClosestDate(datePadLocations, date));
                })
                .attr("y", function () {
                    return y(getY(getClosestDate(datePadLocations, date), occupiedXYValues));
                })
                .attr("width", 20)
                .attr("height", 15)
                .attr("rx", 3)
                .attr("ry", 3)
                .attr("fill", function () {
                    return getColor(data_type)
                })
                .on('click', function () {
                    window.location.href = '#' + id;
                    d3.select(this).attr("stroke", "#00FF00")
                })
                .on("mouseover", function () {
                    d3.select(this).attr("stroke", "#00FF00");
                  /*div.transition()
                   .duration(200)
                   .style("opacity", .9);
                   div.html(name + "<br/>")
                   .style("left", (d3.event.pageX) + "px")
                   .style("top", (d3.event.pageY - 28) + "px"); */
                })
                .on("mouseout", function () {
                    d3.select(this).attr("stroke", "");
                  /* div.transition()
                   .duration(500)
                   .style("opacity", 0); */
                });


            /**
             *  The following code is used to generate the vertical timeline
             */
            var newDiv = document.createElement('div');
            newDiv.id = name;
            newDiv.className = 'cd-timeline-block';
            newDiv.innerHTML = $('#hiddenBlock').html();

            newDiv.innerHTML = newDiv.innerHTML.replace("$TIMESTAMP$", date.toUTCString());
            newDiv.innerHTML = newDiv.innerHTML.replace("$DESCRIPTION$", description);
            newDiv.innerHTML = newDiv.innerHTML.replace("$TITLE$", name);
            newDiv.innerHTML = newDiv.innerHTML.replace("$NAME$", id);
            newDiv.innerHTML = newDiv.innerHTML.replace("bug_report", function () {
                return getImageName(data_type);
            });
            newDiv.innerHTML = newDiv.innerHTML.replace("$HREFURL$", '');
            newDiv.innerHTML = newDiv.innerHTML.replace("red", function () {
                return getColor(data_type);
            });
            toAdd.appendChild(newDiv);
        }
    });
    // Append the x-axis to the horizontal timeline
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x));

    document.getElementById('cd-timeline').appendChild(toAdd);
}
