/**
 * Created by ekbos on 10/6/2016.
 */

/**
 * Timeline functions for horizontal timeline
 */

/**
 * Given a string d, create a date
 * @param d - json format date string
 * @returns {Date} a JS date item
 */
function getDate(d) {
  return new Date(d);
}

/**
 * Adds a number of days to a given date
 * @param date - the starting date
 * @param days - the number of days to add
 * @returns {Date} A date + days
 */
function addDays(date, days) {
  var result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
}

/**
 * Calculates the range between two dates
 * @param a - the start date
 * @param b - the end date
 * @returns {number} the difference (absolute) between the dates
 */
function calculateDateRange(a, b) {
  var utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
  var utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());

  return Math.abs(Math.floor((utc2 - utc1) / (86400000)));
}

/**
 * Get the date groups given a number of slots and the bins (for computing range)
 * @param startDate - the start date
 * @param endDate - the end date
 * @param slots - the total number of bunches to make
 * @returns {Array} the dates to place items around
 */
function getDatePadLocations(startDate, endDate, slots) {
  var timespan = calculateDateRange(startDate, endDate);
  var increment = (timespan / slots);
  var days = [];
  for (var i = 0; i < slots; i++) {
    days.push(addDays(startDate, i * increment))
  }
  days.push(endDate);
  return days;
}

/**
 * Go through a list of dates and find the date closest to the provided date
 * @param daysList - the list of dates to look through
 * @param date - a js date object
 * @returns {*} the date closest to the date provided in the js object
 */
function getClosestDate(daysList, date) {
  var closestDate = daysList[0];
  for (i = 0; i < daysList.length - 1; i++) {
    if (calculateDateRange(daysList[i], date) < calculateDateRange(closestDate, daysList[i])) {
      closestDate = daysList[i];
    }
  }
  return closestDate;
}

/**
 * Get the y coordinate to place the vulnerability item
 * @param date - the date to check the y coordinate for
 * @param occupiedSlots - a dictionary containing dates and number of items at that date
 * @returns number y coordinate to place tile at
 */
function getY(date, occupiedSlots) {
  if (occupiedSlots[date] == null) {
    occupiedSlots[date] = 1;
    return 1;
  }
  else {
    occupiedSlots[date] = occupiedSlots[date] += 1;
    return occupiedSlots[date];
  }
}

/**
 * Given a type (string) either v,p,b,or x, return a hex color string
 * @param type - a string that specifies the type of vulnerability, a single character
 * @returns {*} the color for that vulnerability
 */
function getColor(type) {
  if (type == 'v') { // vulnerability
    // pink
    return "#E91E63";
  }
  else if (type == 'p') { // patch
    // blue
    return "#1E88E5";
  }
  else if (type == 'b') { // bug
    // orange
    return "#FB8C00";
  }
  else {
    // white
    return "#FFFFFF";
  }
}

/**
 * Gets correct img url and CSS tags given a vulnerability type
 * @param vType the vulnerability to look up
 */
function getCssURL(vType) {
  switch (vType) {
    case ('v'):
      return [('<%=image_path('timeline/cd-icon-vulnerability.svg') %>'), 'cd-vulnerability'];
      break;
    case('p'):
      return [('<%=image_path('timeline/cd-icon-patch.svg') %>'), 'cd-patch'];
      break;
    case('b'):
      return [('<%=image_path('timeline/cd-icon-bug.svg') %>'), 'cd-bug'];
      break;
  }
}


/**
 * Temporary function to remove the svg on draw in order to update it, will eventually be replaced with actual update
 * methods.
 */
function removeSVG() {
  var svg = d3.select("svg");
  svg.selectAll("*").remove();
  d3.select("#hTimeline").remove();
}

/**
 * Data filtering function to remove bins with filtered-out data
 * @param bins - the data to filter
 * @return bins - array after filtering
 */
function filterData(bins) {
  var types = [];
  $('.cmn-toggle').each(function (toggle) {
    if (toggle.checked) {
      console.log(toggle);
      types.append("hi");
    }
  });
  console.log(types);
  var filter = $('#data_types').val();


  return bins;
}


function getMinDate(date, minDate) {
  if (date < minDate) {
    return date;
  }
  else {
    return minDate;
  }
}


function getMaxDate(date, maxDate) {
  if (date > maxDate) {
    return date;
  }
  else {
    return maxDate;
  }
}

/**
 * Called on filter update, removes all of the timeline items when filters are changed
 */
function deleteVerticalTimeline() {
  $(".cd-timeline-block").remove();
}



function generateTimeline(dataset) {
  removeSVG();
  deleteVerticalTimeline();

  var toAdd = document.createDocumentFragment();
  var margin = {top: 10, right: 20, bottom: 30, left: 60},
      width = 960 - margin.left - margin.right,
      height = 500 - margin.top - margin.bottom;

  var x = d3.scaleTime().range([0, width]);
  var y = d3.scaleLinear().range([height, 0]);


  var svg = d3.select('#horizontal-timeline').append("svg")
      .attr("width", "100%")
      .attr("viewBox", "0 0 960 500")
      .attr("id", "hTimeline")
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var minDate = Date.now(),
      maxDate = 0;

  $("#object").each(function () { //TODO eventually switch this over to using the passed in dataset
    var updated_at = $(this).find("#updated_at").text().trim();
    minDate = getMinDate(getDate(updated_at), minDate);
    maxDate = getMaxDate(getDate(updated_at), maxDate);
  });
  filterData();
  // Set the scale domains.
  x.domain([minDate, maxDate]);
  y.domain([0, 30]);
  getDatePadLocations(minDate, maxDate);

  var slots = 25; // number of different date slots
  var datePadLocations = getDatePadLocations(minDate, maxDate, slots);
  var occupiedXYValues = {};

  //TODO right now using two loops, the previous loop will eventually use indexing instead
  $("#object").each(function () {
    var name = $(this).find("#title").text().replace(/ /g, '');
    var commit = $(this).find("#description").text().trim();
    var updated_at = $(this).find("#date").text().trim();
    updated_at = getDate(updated_at);
    // On each item in the object list, append a rectangle to the horizontal timeline
    svg.append("svg:rect")
        .attr("class", "bin")
        .attr("x", function () {
          return x(getClosestDate(datePadLocations, updated_at));
        })
        .attr("y", function () {
          return y(getY(getClosestDate(datePadLocations, updated_at), occupiedXYValues));
        })
        .attr("width", 20)
        .attr("height", 15)
        .attr("rx", 3)
        .attr("ry", 3)
        .attr("fill", function (d) {
          return "#00FF00"
        })
        .on('click', function (d) {
          window.location.href = '#' + name;
          d3.select(this).attr("stroke", "#00FF00")
        })
        .on("mouseover", function () {
          d3.select(this).attr("stroke", "#00FF00")
        })
        .on("mouseout", function () {
          d3.select(this).attr("stroke", "")
        });


    /**
     *  The following code is used to generate the vertical timeline
     */

    var newDiv = document.createElement('div');
    newDiv.id = name;
    newDiv.className = 'cd-timeline-block';
    newDiv.innerHTML = $('#hiddenArea').html();

    newDiv.innerHTML = newDiv.innerHTML.replace("$TIMESTAMP$", updated_at);
    newDiv.innerHTML = newDiv.innerHTML.replace("$DESCRIPTION$", commit);
    newDiv.innerHTML = newDiv.innerHTML.replace("$TITLE$", name);
    newDiv.innerHTML = newDiv.innerHTML.replace("$NAME$", name);
    newDiv.innerHTML = newDiv.innerHTML.replace("<%=image_path('timeline/cd-icon-default.svg') %>", function () {
      return getCssURL('v')[0];
    });
    newDiv.innerHTML = newDiv.innerHTML.replace("$HREFURL$", '');
    newDiv.innerHTML = newDiv.innerHTML.replace("cd-default", function () {
      return getCssURL('v')[1];
    });
    toAdd.appendChild(newDiv);
  });
  // Append the x-axis to the horizontal timeline
  svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x));

  document.getElementById('cd-timeline').appendChild(toAdd);
}
