/**
 * Timeline functions for horizontal timeline
 */

/**
 * Given a string d, create a date
 * @param d - json format date string
 * @returns {Date} a JS date item
 */
function getDate(d) {
    return new Date(d);
}

/**
 * Adds a number of days to a given date
 * @param date - the starting date
 * @param days - the number of days to add
 * @returns {Date} A date + days
 */
function addDays(date, days) {
    var result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
}

/**
 * Calculates the range between two dates
 * @param a - the start date
 * @param b - the end date
 * @returns {number} the difference (absolute) between the dates
 */
function calculateDateRange(a, b) {
    var utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
    var utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());

    return Math.abs(Math.floor((utc2 - utc1) / (86400000)));
}

/**
 * Get the date groups given a number of slots and the bins (for computing range)
 * @param bins - the data values to use, in order by date
 * @param slots - the total number of bunches to make
 * @returns {Array} the dates to place items around
 */
function getGroups(bins, slots) {
    var startDate = getDate(bins[0].jsonDate);
    var endDate = getDate(bins[bins.length - 1].jsonDate);
    var timespan = calculateDateRange(startDate, endDate);
    var increment = (timespan / slots);
    var days = [];
    for (var i = 0; i < slots; i++) {
        days.push(addDays(startDate, i * increment))
    }
    days.push(endDate);
    return days;
}

/**
 * Go through a list of dates and find the date closest to the provided date
 * @param daysList - the list of dates to look through
 * @param date - a js date object
 * @returns {*} the date closest to the date provided in the js object
 */
function getClosestDate(daysList, date) {
    var closestDate = daysList[0];
    for (i = 0; i < daysList.length - 1; i++) {
        if (calculateDateRange(daysList[i], date) < calculateDateRange(closestDate, daysList[i])) {
            closestDate = daysList[i];
        }
    }
    return closestDate;
}

/**
 * Get the y coordinate to place the vulnerability item
 * @param date - the date to check the y coordinate for
 * @param occupiedSlots - a dictionary containing dates and number of items at that date
 * @returns the y coordinate to place tile at
 */
function getY(date, occupiedSlots) {
    if (occupiedSlots[date] == null) {
        occupiedSlots[date] = 1;
        return 1;
    }
    else {
        occupiedSlots[date] = occupiedSlots[date] += 1;
        return occupiedSlots[date];
    }
}

/**
 * Given a type (string) either v,p,b,or x, return a hex color string
 * @param type - a string that specifies the type of vulnerability, a single character
 * @returns {*} the color for that vulnerability
 */
function getColor(type) {
    if (type == 'v') { // vulnerability
        // pink
        return "#E91E63";
    }
    else if (type == 'p') { // patch
        // blue
        return "#1E88E5";
    }
    else if (type == 'b') { // bug
        // orange
        return "#FB8C00";
    }
    else if (type == 'x') {
        // white
        return "#FFFFFF";
    }
}
