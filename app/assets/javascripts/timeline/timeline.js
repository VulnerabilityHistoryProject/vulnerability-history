/**
 * bind event listeners to the filters
 */
function bindDataToggleCallback(h, sEvents, cLowerLim, cUpperLim, minChicHeight, maxChicHeight, chicWidth, zoom,
                                minDate, maxDate, eVcc, eVuln, lFix, height, width, margin) {
    $(document).on("change", ".data-toggles", function () {
        var zoom;
        if ($('#zoom-bool').val() == "true") {
            zoom = true;
        } else {
            zoom = false;
        }
        h = {};
        h = new HorizontalTimeline(
            sEvents,
            cLowerLim,
            cUpperLim,
            minChicHeight,
            maxChicHeight,
            chicWidth,
            zoom,
            minDate,
            maxDate,
            eVcc,
            eVuln,
            lFix,
            height,
            width,
            margin,
            []
        );
        h.setup();
        h.generate();
    });
}

/**
 * bind event listeners to '#zoom-button'
 */
function bindZoomEvents(h, sEvents, cLowerLim, cUpperLim, minChicHeight, maxChicHeight, chicWidth, minDate, maxDate,
    eVcc, eVuln, lFix, height, width, margin) {
    $('#zoom-button').click(function() {
        var zoom = $('#zoom-bool').val();
        if ($('#zoom-bool').val() == "true") {
            $('#zoom-bool').val("false");
            $('#zoom-button').text('zoom_in');
            zoom = false;
        } else {
            $('#zoom-bool').val("true");
            $('#zoom-button').text('zoom_out');
            zoom = true;
        }
        var hiddenTypes = getFilterState();
        $('#toggle-block').empty();
        h = {};
        h = new HorizontalTimeline(
            sEvents,
            cLowerLim,
            cUpperLim,
            minChicHeight,
            maxChicHeight,
            chicWidth,
            zoom,
            minDate,
            maxDate,
            eVcc,
            eVuln,
            lFix,
            height,
            width,
            margin,
            hiddenTypes
        );
        h.setup();
        h.generate();
    });
}

/**
 * bind event listeners to '#cd-timeline'
 */
function bindCdTimelineEvents() {
    var $wrapper = $('#cd-timeline');
    $wrapper.find('.cd-timeline-block').sort(function (a, b) {
        date1 = new Date(a.dataset.id);
        date2 = new Date(b.dataset.id);
        return +date2 - +date1;
    })
        .appendTo( $wrapper );

    $('#cd-timeline').on('click', 'a', function (event) {
        event.preventDefault();

        $('html, body').animate({
            scrollTop: $(event.target).offset().top
        }, 500);
    });
}

/**
 * bind event listeners to 'window'
 */
function bindWindowEvents() {
    //Check to see if the window is top if not then display button
    $(window).scroll(function () {
        if ($(this).scrollTop() > 100) {
            $('.scroll-to-top').fadeIn();
        } else {
            $('.scroll-to-top').fadeOut();
        }
    });
}

/**
 * bind event listeners to '.scroll-to-top'
 */
function bindScrollEvents() {
    //Click event to scroll to top
    $('.scroll-to-top').click(function () {
        $('html, body').animate({scrollTop: 0}, 600);
        return false;
    });
}

/**
 * return an array of all the unchecked filters
 * @returns {Array}
 */
function getFilterState() {
    var hiddenTypes = [];
    $('#toggle-block').children('span').each(function() {
        if (!($(this).children("input[type='checkbox']:first").is(":checked")
            )) {
            var type = $(this).children("input[type='checkbox']:first").attr('id');
            type = type.split('-')[0];
            hiddenTypes.push(type);
        }
    });

    return hiddenTypes;
}

/**
 * Given a string d, create a date
 * @param d - json format date string
 * @returns {Date} a JS date item
 */
function getDate(d) {
    if (!Number.isInteger(d)) {
        d = d.toString().replace(/\s[A-Za-z]{3}/g, "Z").replace(/ /g, "T");

    }
    return new Date(d);
}

/**
 * Given a date, check if it is greater than the minimum date, and return it instead if it is
 * @param date - the date to validate
 * @param minDate - the date that is the current minimum
 * @returns Date - smaller of two values
 */
function getMinDate(date, minDate) {
    if (date < minDate) {
        return date;
    } else {
        return minDate;
    }
}

/**
 * Given a date, check if it is greater than the maximum date, and return it instead if it is
 * @param date - the date to validate
 * @param maxDate - the date that is the current maximum
 * @returns Date - larger of two values
 */
function getMaxDate(date, maxDate) {
    if (date > maxDate) {
        return date;
    } else {
        return maxDate;
    }
}

/**
 * loop through cd-timeline-blocks to create Event1 objects and populate an array.
 * @returns {Array} - containing Event1 objects
 */
function collectEvents() {
    var eArr = []
    $(".cd-timeline-block").each(function () {
        var id = $(this).find("a").attr('id');
        var title = $(this).find("#title").text();
        var description = $(this).find("#description").text().trim();
        var string_date = $(this).find("#isodate").text().trim();
        var date = getDate(string_date);
        var type = $(this).attr('id').toLowerCase();
        var eObj = new Event1(id, title, description, date, type);
        eArr.push(eObj);
    });

    return eArr;
}

/**
 * sort the events by date oldest to newest
 * @param events - array of Event1 objects
 * @returns {*} - array of sorted Event1 objects
 */
function sortEvents(events) {
    events.sort(function(a, b) {
        return a.date - b.date;
    });

    return events;
}

/**
 * get all of the valid types and create array of Filters
 * @param e (event)
 */
function createGlobalFilters(e) {
    var exists = false;
    window.filters.forEach(function(filter) {
        if(filter.type === e.type) {
            exists = true;
        }
    });
    if(!exists) {
        var newFilter = new Filter(e.type, true);
        window.filters.push(newFilter);
    }
}

/**
 * get the Dates for the earliest vcc, earliest vulnerability, and latest fix
 * @param events
 * @returns {{minDate: Date, maxDate: Date, eVcc: *, eVuln: *, lFix: *}}
 *  - if Vcc, eVuln, lFix will be undefined if there isn't actualy an event of that type
 */
function getImportantDates(events) {
    var minDate = new Date();
    var maxDate = new Date(0);
    var eVcc;
    var eVuln;
    var lFix;
    var numVcc = 0;
    var numVuln = 0;
    var numFix = 0;
    events.forEach(function(e) {
        minDate = getMinDate(e.date, minDate);
        maxDate = getMaxDate(e.date, maxDate);
        createGlobalFilters(e);
        if (e.type == 'vcc') {
            if (numVcc == 0 ) {
                eVcc = e.date;
            } else {
                eVcc = getMinDate(e.date, eVcc);
            }
            numVcc += 1;
        } else if (e.type == 'vulnerability') {
            if (numVuln == 0) {
                eVuln = e.date;
            } else {
                eVuln = getMinDate(e.date, eVuln);
            }
            numVuln += 1;
        } else if (e.type == 'fix') {
            if (numFix == 0) {
                lFix = e.date;
            } else {
                lFix = getMaxDate(e.date, lFix);
            }
            numFix += 1;
        }
    });

    return {
        minDate: minDate,
        maxDate: maxDate,
        eVcc: eVcc,
        eVuln: eVuln,
        lFix: lFix,
    };
}

$(document).ready(function () {
    window.filters = [];
    var eArray = collectEvents();
    var sEvents = sortEvents(eArray);
    var impDates = getImportantDates(sEvents);
    var minDate = impDates.minDate;
    var maxDate = impDates.maxDate;
    var eVcc = impDates.eVcc;
    var eVuln = impDates.eVuln;
    var lFix = impDates.lFix;

    var margin = {top: 10, right: 20, bottom: 30, left: 60};
    var width = 960 - margin.left - margin.right;
    var height = 270 - margin.top - margin.bottom;

    var minChicHeight = 10;
    var maxChicHeight = 15;
    var chicWidth = 20;
    var cLowerLim = 15;
    var cUpperLim = 25;
    var zoom = true;
    var hiddenTypes = [];

    var h = new HorizontalTimeline(
        sEvents,
        cLowerLim,
        cUpperLim,
        minChicHeight,
        maxChicHeight,
        chicWidth,
        zoom,
        minDate,
        maxDate,
        eVcc,
        eVuln,
        lFix,
        height,
        width,
        margin,
        hiddenTypes
    );

    h.setup();
    h.generate();

    bindDataToggleCallback(h, sEvents, cLowerLim, cUpperLim, minChicHeight, maxChicHeight, chicWidth, zoom,
        minDate, maxDate, eVcc, eVuln, lFix, height, width, margin);
    bindCdTimelineEvents();
    bindWindowEvents();
    bindScrollEvents();
    bindZoomEvents(h, sEvents, cLowerLim, cUpperLim, minChicHeight, maxChicHeight, chicWidth, minDate, maxDate,
        eVcc, eVuln, lFix, height, width, margin);
});
