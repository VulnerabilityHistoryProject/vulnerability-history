/**
 * Timeline functions for horizontal timeline
 */

/**
 * Given a string d, create a date
 * @param d - json format date string
 * @returns {Date} a JS date item
 */
function getDate(d) {
    return new Date(d);
}

/**
 * Adds a number of days to a given date
 * @param date - the starting date
 * @param days - the number of days to add
 * @returns {Date} A date + days
 */
function addDays(date, days) {
    var result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
}

/**
 * Calculates the range between two dates
 * @param a - the start date
 * @param b - the end date
 * @returns {number} the difference (absolute) between the dates
 */
function calculateDateRange(a, b) {
    var utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
    var utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());

    return Math.abs(Math.floor((utc2 - utc1) / (86400000)));
}

/**
 * Get the date groups given a number of slots and the bins (for computing range)
 * @param bins - the data values to use, in order by date
 * @param slots - the total number of bunches to make
 * @returns {Array} the dates to place items around
 */
function getGroups(bins, slots) {
    var startDate = getDate(bins[0].jsonDate);
    var endDate = getDate(bins[bins.length - 1].jsonDate);
    var timespan = calculateDateRange(startDate, endDate);
    var increment = (timespan / slots);
    var days = [];
    for (var i = 0; i < slots; i++) {
        days.push(addDays(startDate, i * increment))
    }
    days.push(endDate);
    return days;
}

/**
 * Go through a list of dates and find the date closest to the provided date
 * @param daysList - the list of dates to look through
 * @param date - a js date object
 * @returns {*} the date closest to the date provided in the js object
 */
function getClosestDate(daysList, date) {
    var closestDate = daysList[0];
    for (i = 0; i < daysList.length - 1; i++) {
        if (calculateDateRange(daysList[i], date) < calculateDateRange(closestDate, daysList[i])) {
            closestDate = daysList[i];
        }
    }
    return closestDate;
}

/**
 * Get the y coordinate to place the vulnerability item
 * @param date - the date to check the y coordinate for
 * @param occupiedSlots - a dictionary containing dates and number of items at that date
 * @returns the y coordinate to place tile at
 */
function getY(date, occupiedSlots) {
    if (occupiedSlots[date] == null) {
        occupiedSlots[date] = 1;
        return 1;
    }
    else {
        occupiedSlots[date] = occupiedSlots[date] += 1;
        return occupiedSlots[date];
    }
}

/**
 * Given a type (string) either v,p,b,or x, return a hex color string
 * @param type - a string that specifies the type of vulnerability, a single character
 * @returns {*} the color for that vulnerability
 */
function getColor(type) {
    if (type == 'v') { // vulnerability
        // pink
        return "#E91E63";
    }
    else if (type == 'p') { // patch
        // blue
        return "#1E88E5";
    }
    else if (type == 'b') { // bug
        // orange
        return "#FB8C00";
    }
    else if (type == 'x') {
        // white
        return "#FFFFFF";
    }
}

/**
 * Gets correct img url and CSS tags given a vulnerability type
 * @param vType the vulnerability to look up
 */
function getCssURL(vType) {
  switch (vType) {
    case ('v'):
      return [('<%=image_path('timeline/cd-icon-vulnerability.svg') %>'), 'cd-vulnerability'];
      break;
    case('p'):
      return [('<%=image_path('timeline/cd-icon-patch.svg') %>'), 'cd-patch'];
      break;
    case('b'):
      return [('<%=image_path('timeline/cd-icon-bug.svg') %>'), 'cd-bug'];
      break;
  }
}


/**
 * Timeline generation script
 * @type {DocumentFragment} Stores timeline elements before adding to the HTML page
 */
var toAdd = document.createDocumentFragment();

d3.csv('<%= ENV["RAILS_RELATIVE_URL_ROOT"] %>/vulnerability-test-data.csv', function (error, bins) {
  if (error) throw error;
  bins.forEach(function (bin) {
    var newDiv = document.createElement('div');
    newDiv.id = bin.name;

    newDiv.className = 'cd-timeline-block';
    newDiv.innerHTML = $('#hiddenArea').html();

    newDiv.innerHTML = newDiv.innerHTML.replace("$TIMESTAMP$", bin.jsonDate);
    newDiv.innerHTML = newDiv.innerHTML.replace("$DESCRIPTION$", bin.description);
    newDiv.innerHTML = newDiv.innerHTML.replace("$TITLE$", bin.name);
    newDiv.innerHTML = newDiv.innerHTML.replace("$NAME$", bin.name);
    newDiv.innerHTML = newDiv.innerHTML.replace("<%=image_path('timeline/cd-icon-default.svg') %>", function () {
      return getCssURL(bin.vType)[0];
    });
    newDiv.innerHTML = newDiv.innerHTML.replace("$HREFURL$", '');
    newDiv.innerHTML = newDiv.innerHTML.replace("cd-default", function () {
      return getCssURL(bin.vType)[1];
    });
    toAdd.appendChild(newDiv);
  });


  document.getElementById('cd-timeline').appendChild(toAdd);

});