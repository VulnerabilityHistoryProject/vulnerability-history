/**
 * Created by ekbos on 10/6/2016.
 */

/**
 * Timeline functions for horizontal timeline
 */

/**
 * Given a string d, create a date
 * @param d - json format date string
 * @returns {Date} a JS date item
 */
function getDate(d) {
  return new Date(d);
}

/**
 * Adds a number of days to a given date
 * @param date - the starting date
 * @param days - the number of days to add
 * @returns {Date} A date + days
 */
function addDays(date, days) {
  var result = new Date(date);
  result.setDate(result.getDate() + days);
  return result;
}

/**
 * Calculates the range between two dates
 * @param a - the start date
 * @param b - the end date
 * @returns {number} the difference (absolute) between the dates
 */
function calculateDateRange(a, b) {
  var utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
  var utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());

  return Math.abs(Math.floor((utc2 - utc1) / (86400000)));
}

/**
 * Get the date groups given a number of slots and the bins (for computing range)
 * @param bins - the data values to use, in order by date
 * @param slots - the total number of bunches to make
 * @returns {Array} the dates to place items around
 */
function getGroups(bins, slots) {
  var startDate = getDate(bins[0].jsonDate);
  var endDate = getDate(bins[bins.length - 1].jsonDate);
  var timespan = calculateDateRange(startDate, endDate);
  var increment = (timespan / slots);
  var days = [];
  for (var i = 0; i < slots; i++) {
    days.push(addDays(startDate, i * increment))
  }
  days.push(endDate);
  return days;
}

/**
 * Go through a list of dates and find the date closest to the provided date
 * @param daysList - the list of dates to look through
 * @param date - a js date object
 * @returns {*} the date closest to the date provided in the js object
 */
function getClosestDate(daysList, date) {
  var closestDate = daysList[0];
  for (i = 0; i < daysList.length - 1; i++) {
    if (calculateDateRange(daysList[i], date) < calculateDateRange(closestDate, daysList[i])) {
      closestDate = daysList[i];
    }
  }
  return closestDate;
}

/**
 * Get the y coordinate to place the vulnerability item
 * @param date - the date to check the y coordinate for
 * @param occupiedSlots - a dictionary containing dates and number of items at that date
 * @returns the y coordinate to place tile at
 */
function getY(date, occupiedSlots) {
  if (occupiedSlots[date] == null) {
    occupiedSlots[date] = 1;
    return 1;
  }
  else {
    occupiedSlots[date] = occupiedSlots[date] += 1;
    return occupiedSlots[date];
  }
}

/**
 * Given a type (string) either v,p,b,or x, return a hex color string
 * @param type - a string that specifies the type of vulnerability, a single character
 * @returns {*} the color for that vulnerability
 */
function getColor(type) {
  if (type == 'v') { // vulnerability
    // pink
    return "#E91E63";
  }
  else if (type == 'p') { // patch
    // blue
    return "#1E88E5";
  }
  else if (type == 'b') { // bug
    // orange
    return "#FB8C00";
  }
  else if (type == 'x') {
    // white
    return "#FFFFFF";
  }
}

/**
 * Gets correct img url and CSS tags given a vulnerability type
 * @param vType the vulnerability to look up
 */
function getCssURL(vType) {
  switch (vType) {
    case ('v'):
      return [('<%=image_path('timeline/cd-icon-vulnerability.svg') %>'), 'cd-vulnerability'];
      break;
    case('p'):
      return [('<%=image_path('timeline/cd-icon-patch.svg') %>'), 'cd-patch'];
      break;
    case('b'):
      return [('<%=image_path('timeline/cd-icon-bug.svg') %>'), 'cd-bug'];
      break;
  }
}


/**
 * Temporary function to remove the svg on draw in order to update it, will eventually be replaced with actual update
 * methods.
 */
function removeSVG() {
  var svg = d3.select("svg");
  svg.selectAll("*").remove();
  d3.select("#hTimeline").remove();
}


/**
 * Data filtering function to remove bins with filtered-out data
 * @param bins - the data to filter
 * @return bins - array after filtering
 */
function filterData(bins) {
  var filter = $('#data_types').val();
  for (var i = 0; i < bins.length; i++) {

    if ($.inArray(bins[i].vType, filter) == -1) {
      bins.splice(i, 1);
      i--;
    }
  }

  return bins;
}



function generateHorizontalTimeline(dataset) {
  removeSVG();

  var data = document.getElementById(dataset);
  //console.log($("#object"));
  var divObjects = $("#object");
  for (var i = 0; i < divObjects.length; i++) {
    console.log($(divObjects[i]).find("#name").text());
    //console.log(divObjects[i].children("#name"));
  }
  var margin = {top: 10, right: 20, bottom: 30, left: 60},
      width = 960 - margin.left - margin.right,
      height = 500 - margin.top - margin.bottom;


  var svg = d3.select('#horizontal-timeline').append("svg")
      .attr("width", "100%")
      .attr("viewBox", "0 0 960 500")
      .attr("id", "hTimeline")
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


  d3.csv('<%= ENV['RAILS_RELATIVE_URL_ROOT'] %>/MOCK_DATA_500LINES_ONEYEAR.csv', function (error, bins) {
    if (error) throw error;

    var minDate = getDate(bins[0].jsonDate),
        maxDate = getDate(bins[bins.length - 1].jsonDate);

    var x = d3.scaleTime().range([0, width]);
    var y = d3.scaleLinear().range([height, 0]);
    // Set the scale domains.
    x.domain([minDate, maxDate]);
    y.domain([0, 30]);

    var slots = 25; // number of different
    var datePadLocations = getGroups(bins, slots);
    var occupiedXYValues = {};
    // Add the bins.
    bins = filterData(bins);
    svg.selectAll(".bin")
        .data(bins)
        .enter().append("svg:rect")
        .attr("class", "bin")
        .attr("x", function (d) {
          return x(getClosestDate(datePadLocations, getDate(d.jsonDate)));
        })
        .attr("y", function (d) {
          return y(getY(getClosestDate(datePadLocations, getDate(d.jsonDate)), occupiedXYValues));
        })
        .attr("width", 20)
        .attr("height", 15)
        .attr("rx", 3)
        .attr("ry", 3)
        .attr("fill", function (d) {
          return getColor(d.vType)
        })
        .on('click', function (d) {
          window.location.href = '#' + d.name;
          d3.select(this).attr("stroke", "#00FF00")
        })
        .on("mouseover", function () {
          d3.select(this).attr("stroke", "#00FF00")
        })
        .on("mouseout", function () {
          d3.select(this).attr("stroke", "")
        });

    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x));
  });

}