/**
 * Object representation of the horizontal timeline
 *
 * USAGE: initialize HorizontalTimeline instance, call this.setup(), call this.generate(),
 * optionally call this.generateFilters()
 *
 * @param events - collection of events from backend
 * @param cLowerLim (int) - max number of events in a column with maxChicHeight
 * @param cUpperLim (int) - max number of events in col with minChicHeight
 * @param minChicHeight (int) - min height of a chiclet
 * @param maxChicHeight (int) - max height of a chiclet
 * @param chicWidth (int) - width of a chiclet
 * @param zoom (boolean) - zoomed in or out view of horizontal timeline
 * @param eDict (Dict<Date, Array<Event1>>) - dict representing the columns
 *  of the horizontal timeline
 * @param minDate (Date) - absolute minimum date from all events
 * @param maxDate (Date) - absolute maximum date from all events
 * @param eVcc (Date) - date of earliest VCC
 * @param eVuln (Date) - date of earliest vulnerability
 * @param lFix (Date) - date of latest fix
 * @param svgHeight (int) - height of svg
 * @param svgWidth (int) - width of svg
 * @param svgMargin (object) - margins for svg
 * @param hiddenTypes (array) - data-toggles that have been unchecked
 * @constructor
 */
function HorizontalTimeline(events, cLowerLim, cUpperLim, minChicHeight, maxChicHeight, chicWidth, zoom, minDate,
                            maxDate, eVcc, eVuln, lFix, svgHeight, svgWidth, svgMargin, hiddenTypes) {
    //instance variables
    this.events = events;
    this.cLowerLim = cLowerLim;
    this.cUpperLim = cUpperLim;
    this.cLim = cLowerLim;
    this.minChicHeight = minChicHeight;
    this.maxChicHeight = maxChicHeight;
    this.chicHeight = maxChicHeight;
    this.chicWidth = chicWidth;
    this.iconCornerRadius = 3;
    this.zoom = zoom;
    this.absMinDate = minDate;
    this.absMaxDate = maxDate;
    this.eVcc = eVcc;
    this.eVuln = eVuln;
    this.lFix = lFix;
    this.svgHeight = svgHeight;
    this.svgWidth = svgWidth;
    this.svgMargin = svgMargin;
    this.numCols = svgWidth / chicWidth;
    this.validTypes = [];
    this.eDict = {};
    this.min;
    this.max;
    this.svg;
    this.x;
    this.y;
    this.hiddenTypes = hiddenTypes;

    /**
     * setup sequence. call this.generate after.
     */
    this.setup = function() {
        this.initEDict();
        this.generateData();
        this.generateFilters();
        this.filterEvents();
        this.calcChicHeight();
    };

    /**
     * generate timeline sequence. optionally call this.generateFilters after
     */
    this.generate = function() {
        this.generateTimeline();
        this.updateVerticalTimeline();
        this.filtersGenerated = true;
    };

    //methods
    this.toString = function() {
        return 'Events: ' + this.events;
    };

    /**
     * get the column ids(dates) based on numCols and zoom
     * and add them as keys to eDict
     */
    this.initEDict = function() {
        var zFunc = this.getZoom();
        this.min = zFunc.min;
        this.max= zFunc.max;
        var range = this.calculateDateRange(this.min, this.max);
        var inc = range / this.numCols;
        for (var i = 0; i < this.numCols; i++) {
            this.eDict[this.addDays(this.min, i * inc)] = [];
        }
        this.eDict[this.max] = [];
        this.keys = Object.keys(this.eDict);
    };

    /**
     * add events within date range to eDict column with closest date.
     * add the event's type to validTypes;
     */
    this.generateData = function() {
        var self = this;
        this.events.forEach(function(e) {
            if ((e.date >= self.min) && (e.date <= self.max)) {
                if (self.validTypes.indexOf(e.type) === -1) {
                    self.validTypes.push(e.type);
                }
                var col = self.getCol(e.date);
                if (self.hiddenTypes.indexOf(e.type) === -1) {
                    self.eDict[col].push(e);
                }
            }
        });
    };

    /**
     * determine what the chicHeight and chicLimite will be
     */
    this.calcChicHeight = function() {
        var cols = Object.keys(this.eDict);
        var maxColCount = this.eDict[cols[0]].length;
        var self = this;
        cols.forEach(function(key) {
            var eArr = self.eDict[key];
            var count = eArr.length;
            if (count > maxColCount) {
                maxColCount = count;
            }
        });
        if (maxColCount > this.cLowerLim) {
            this.chicHeight = this.minChicHeight;
            this.cLim = this.cUpperLim;
        }
    };

    /**
     * generate the horizontal timeline
     */
    this.generateTimeline = function() {
        d3.select('#loading').remove();
        this.removeSVG();
        var toAdd = document.createDocumentFragment();
        this.initSVG();
        this.plotEvents();
        this.drawXAxis();
        fade_ms = 700; // ms
        d3.select('#hTimeline').transition().duration(fade_ms).attr('opacity', 1);
        document.getElementById('vtimeline').appendChild(toAdd);
    };

    /**
     * draw filters below horizontal timeline
     */
    this.generateFilters = function() {
        var container = document.createDocumentFragment();
        var self = this;
        window.filters.forEach((function(filter) {
            if (self.validTypes.indexOf(filter.type) !== -1) {
                if(!$('#' + filter.type + '-toggle').length) {
                    //generate checkbox
                    var checkbox_div = document.createElement('span');
                    checkbox_div.classList.toggle('htimeline_filter');
                    checkbox_div.style.backgroundColor = self.getColor(filter.type);
                    var checkbox = document.createElement('input');
                    checkbox.id = filter.type + "-toggle";
                    checkbox.type = "checkbox";
                    checkbox.checked = filter.checked;
                    // generate label for checkbox
                    var label = document.createElement('label');
                    label.htmlFor = filter.type + "-toggle";
                    label.appendChild(document.createTextNode(self.toTitleCase(self.renameTypeLabel(filter.type))));
                    checkbox_div.appendChild(checkbox);
                    checkbox_div.appendChild(label);
                    container.appendChild(checkbox_div);
                }
            }

        }));
        document.getElementById('toggle-block').appendChild(container);
    };

    /**
     * update vertical timeline based on toggled filters
     */
    this.updateVerticalTimeline = function() {
        var self = this;
        $(".vtimeline-block").each(function () {
            var dataType = $(this).attr('id');
            if ($.inArray(dataType, self.hiddenTypes) != -1 || $.inArray(dataType, self.validTypes) == -1) { // if data is not in visible, hide it
                $(this).fadeOut();
            }
            else {
                $(this).fadeIn();
            }
        });
    };

    //helper methods
    /**
     * Adds a number of days to a given date
     * @param date - the starting date
     * @param days - the number of days to add
     * @returns {Date} A date + days
     */
    this.addDays = function(date, days) {
        var result = new Date(date);
        result.setDate(result.getDate() + days);
        return result;
    };

    /**
     * Calculates the range between two dates
     * @param a - the start date
     * @param b - the end date
     * @returns {number} the difference (absolute) between the dates
     */
    this.calculateDateRange = function(a, b) {

        var utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
        var utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());

        return Math.abs(Math.floor((utc2 - utc1) / (86400000)));
    };

    /**
     * Go through columns and pick which column the event goes into based on
     * closest date
     * @param date - a js date object
     * @returns Date - the date closest to the date provided in the js object which
     * corresponds to the key in the eDict
     */
    this.getCol = function(date) {
        var cols = Object.keys(this.eDict);
        var c = new Date(cols[0]);
        if (date && cols) {
            for (var i = 0; i < cols.length - 1; i++) {
                if (this.calculateDateRange(new Date(cols[i]), date) < this.calculateDateRange(c, new Date(cols[i]))) {
                    c = new Date(cols[i]);
                }
            }
        }

        return c;
    };

    /**
     * get the zoom min and max dates or disable zoom if there are no important
     * dates found
     * @returns {{min: *, max: *}} - both Date objects
     */
    this.getZoom = function() {
        var min = this.absMinDate;
        var max = this.absMaxDate;
        if (this.zoom) {
            if (this.eVcc) {
                min = this.eVcc;
            } else if (this.eVuln) {
                min = this.eVuln;
            }
            if (this.lFix) {
                max = this.lFix;
            }
        }
        if (!eVcc && !eVuln && !lFix) {
            $('#zoom-div').hide();
        }

        return {
            min: min,
            max: max
        };
    };

    this.initSVG = function() {
        var self = this;
        this.svg = d3.select('#horizontal-timeline').append("svg")
            // svg width and height NOT set for responsiveness here!!
            // viewBox is the internal coordinate system and then this
            // scales to fit its container
            // .attr("width", "100%")
            // .attr("height", self.svgHeight + self.svgMargin.top + self.svgMargin.bottom)
            .attr("viewBox", "0 0 960 270")
            .attr("id", "hTimeline")
            .attr('opacity', 0)
            .append("g")
            .attr("transform", "translate(" + self.svgMargin.left + "," + self.svgMargin.top + ")");
        this.x = d3.scaleTime();
        this.y = d3.scaleLinear();
        this.x.domain([self.min, self.max]).range([0, self.svgWidth]);
        var v = self.cLim;
        if (self.cLim === self.cUpperLim) {
            v -= 3;
        }
        this.y.domain([0, v]).range([self.svgHeight, 0]);
    };

    this.filterEvents = function() {
        var self = this;
        window.filters.forEach(function(filter) {
            if ($('#toggle-block').children.length > 0) {
                if (self.validTypes.indexOf(filter.type) !== -1) {
                    if (!($('#' + filter.type + '-toggle').is(':checked'))) {
                        self.hiddenTypes.push(filter.type);
                        filter.setChecked(false);
                    } else {
                        filter.setChecked(true);
                    }
                }
            }
        });
        var cols = Object.keys(this.eDict);
        var self = this;
        cols.forEach(function(key) {
            var eArr = self.eDict[key];
            for (var i = 0; i < eArr.length; i++) {
                if (self.hiddenTypes.indexOf(eArr[i].type) != -1) {
                    self.eDict[key].splice(i, 1);
                    i -= 1;
                }
            }
        });
    };

    /**
     * plot the events as chiclets on the horizontal timeline. any events exceeding
     * the column limit will be shown in overflow
     */
    this.plotEvents = function() {
        var cols = Object.keys(this.eDict);
        var tipId = 0;
        var tip;
        var oIndex = 0;
        var oCount = 0;
        var self = this;
        cols.forEach(function(key) {
            var eArr = self.eDict[key];
            var colOverFArr = [];
            var yIndex = 0;
            var releaseIndex = 0;
            for (var i = 0; i < eArr.length; i++) {
                var event = eArr[i];
                tip = self.renderToolTips(tip, tipId);
                tipId += 1;
                if (self.cLim === self.cLowerLim) {
                    var limit = self.cLim;
                } else {
                    var limit = self.cLim - 4;
                }
                if (yIndex < limit) {
                    if (event.type == 'release') {
                        self.drawFlag(tip, new Date(key), releaseIndex, event);
                        releaseIndex++;
                    } else {
                        self.drawChic(tip, new Date(key), yIndex, event);
                        yIndex++;
                    }
                } else {
                    if (oCount === 0) {
                        oIndex = yIndex;
                    }
                    oCount += 1;
                    colOverFArr.push(event);
                }
            }
            if (colOverFArr.length > 0) {
                self.drawOverflow(tip, new Date(key), oIndex, colOverFArr);
            }
        });
    };

    /**
     * Render the tooltips on the horizontal timeline
     *
     * @param tip
     * @param index
     * @returns {*}
     */
    this.renderToolTips = function(tip, index) {
        tip = d3.select("#tooltips").append("div") // render tooltips
            .attr("class", "tooltip")
            .attr("id", index)
            .style("display", "none")
            .on('mouseenter', function () {
                tip.transition().duration(0);
            });

        return tip;
    };

    this.showOverflowHover = function(events) {
        $('#legend-body').html(
            '<p>More Events:</p>'
        );
        events.forEach(function(event, index) {
            $('#legend-body').append(
                '<li>' +
                    event.type + ': ' +
                moment(event.date).format('MMMM Do YYYY, h:mm a') +
                '</li>'
            );
        });
    };

    this.showTooltip = function(tip, event) {
        $('#legend-body').html(
            '<p class="material-icons legend-icon" style="background-color: '+
              event.color + '">' +
              event.icon +
            '</p>' +
            '<p>' + event.title + '</p>' +
            '<p class="date">' +
             moment(event.date).format('MMMM Do YYYY, h:mm a') +
             '</p>'

        );
    };

    this.drawFlag = function(tip, col, releaseIndex, event) {
        var flagHeight = this.chicHeight - 2;
        var flagWidth = 3;
        var thisX = this.x(col);
        var startX = thisX + (releaseIndex * (flagWidth + 1));
        if ((releaseIndex * (flagWidth + 1)) > this.chicWidth - 3) {
            startX = thisX + this.chicWidth - 3;
        }
        var startY = this.svgHeight + flagHeight + 2;
        var self = this;
        this.svg.append("svg:line")
            .attr("class", "link_to_event")
            .attr("x1", startX)
            .attr("y1", startY)
            .attr("x2", startX)
            .attr("y2", startY - flagHeight)
            .attr("stroke-width", flagWidth)
            .attr("stroke", self.getColor(event.type))
            .attr("fill", function () {
                return self.getColor(event.type)
            })
            .on('click', function () { // link to horizontal-timeline
                window.location.href = '#' + event.id;
                d3.select(this).attr("stroke", "#00FF00")
            })
            .on("mouseenter", function () { // show chicklet
                d3.select(this).attr("stroke", "#9933ff")
                    .attr("fill", function () {
                        return "#9933ff"
                    });
                self.showTooltip(tip, event);
            })
            .on("mouseleave", function () { // hide tooltip
                d3.select(this).attr("stroke", self.getColor(event.type))
                    .attr("fill", function () {
                        return self.getColor(event.type)
                    });
                tip.transition()
                    .style("display", "none");
            });
    };

    /**
     * Looks up an event's color in the DOM on the Vertical Timeline
     *
     * Given a type (string) either v,p,b,or x, return a hex color string
     *
     * @param type - a string that specifies the type of vulnerability
     * @returns {*} the color for that vulnerability
     */
    this.getColor = function(type) {
        return $('#' + type + ' div.vtimeline-img')[0].style.backgroundColor;
    };

    this.drawChic = function(tip, event_date, yIndex, event) {
        var self = this;
        this.svg.append("svg:rect") //draw the chicklets
            .attr("class", "bin link_to_event")
            .attr("x", function () {
                // map through d3's scaleTime(), center on chiclet
                return self.x(event_date) - self.chicWidth / 2;
            })
            .attr("y", function () {
                // map through d3's scaleLinear()
                // yIndex + 1 to be above timeline
                // +1px to adjust for a gap
                return self.y(yIndex + 1) + 2;
            })
            .attr("width", self.chicWidth - 1) //adjust for gap
            .attr("height", self.chicHeight - 2) // ajdust for a gap
            .attr("rx", self.iconCornerRadius)
            .attr("ry", self.iconCornerRadius)
            .attr("fill", function () {
                return self.getColor(event.type)
            })
            .on('click', function () { // link to horizontal-timeline
                window.location.href = '#' + event.id;
                d3.select(this).attr("stroke", "#00FF00")
            })
            .on("mouseenter", function () { // show chicklet
                d3.select(this).attr("stroke", "#000000");
                self.showTooltip(tip, event, window, this);
            })
            .on("mouseleave", function () { // hide tooltip
                d3.select(this).attr("stroke", "");
                tip.transition()
                    .style("display", "none");
            });
    };

    this.drawOverflow = function(tip, col, yIndex, events) {
        var startX = this.x(col) + (this.chicWidth / 2);
        var startY = this.y(yIndex + 1);
        var self = this;
        this.svg.append("path")
            .attr("d", "M" + startX + " " + startY + " V " + this.chicHeight + "M" + (startX - (this.chicHeight / 2)) + " " + (startY + (this.chicHeight / 2)) + " H " + (startX + (this.chicHeight/2)) )
            .attr("stroke-width", 3)
            .attr("stroke", "#808080")
            .on('click', function () { // link to horizontal-timeline
                window.location.href = '#' + events[0].id;
                d3.select(this).attr("stroke", "#00FF00")
            })
            .on("mouseenter", function () { // show chicklet
                d3.select(this).attr("stroke", "#9933ff")
                    .attr("fill", function () {
                        return "#9933ff"
                    });
                //self.showTooltip(tip, events[0]);
                self.showOverflowHover(events);
            })
            .on("mouseleave", function () { // hide tooltip
                d3.select(this).attr("stroke", "#808080")
                tip.transition()
                    .style("display", "none");
            });
    };

    /**
     * draw the x axis for the horizontal timeline
     */
    this.drawXAxis = function() {
        this.svg.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + (this.svgHeight + this.chicHeight) + ")")
            .call(d3.axisBottom(this.x));
        var startX = 0;
        var startY = this.svgHeight + this.chicHeight;
        var width = this.svgWidth;
        var height = this.chicHeight - 1;
        var lineData = [
            {"x": startX,         "y": startY},
            {"x": startX,         "y": startY - height},
            {"x": startX + width, "y": startY - height},
            {"x": startX + width, "y": startY}];
        var lineFunction = d3.line()
            .x(function (d) {
                return d.x;
            })
            .y(function (d) {
                return d.y;
            });
        this.svg.append("path")
            .attr("d", lineFunction(lineData))
            .attr("stroke-width", 1)
            .attr("stroke", "#808080")
            .attr("fill", "none");
    };

    /**
     * remove SVG
     */
    this.removeSVG = function() {
        var svg = d3.select("svg");
        d3.select("#hTimeline").remove();
    };

    /**
     * Function used to display type labels as some other type if necessary
     * @param type the current data type
     * @returns {*} a new type, what should be displayed
     */
    this.renameTypeLabel = function(type) {
        switch (type) {
            case "commit_filepath":
                return "edit";
                break;
            default:
                return type.replace('_',' ');
                break;
        }
    };

    /**
     * Title casing function
     * @param str - string to title case
     * @returns String - title cased string
     */
    this.toTitleCase = function(str) {
        return str.replace(/\w\S*/g, function (txt) {
            return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
        });
    }
}
