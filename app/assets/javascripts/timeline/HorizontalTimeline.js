/**
 * Object representation of the horizontal timeline
 *
 * @param events - collection of events from backend
 * @param cLowerLim (int) - max number of events in a column with maxChicHeight
 * @param cUpperLim (int) - max number of events in col with minChicHeight
 * @param minChicHeight (int) - min height of a chiclet
 * @param maxChicHeight (int) - max height of a chiclet
 * @param chicWidth (int) - width of a chiclet
 * @param zoom (boolean) - zoomed in or out view of horizontal timeline
 * @param eDict (Dict<Date, Array<Event1>>) - dict representing the columns
 *  of the horizontal timeline
 * @param minDate (Date) - absolute minimum date from all events
 * @param maxDate (Date) - absolute maximum date from all events
 * @param eVcc (Date) - date of earliest VCC
 * @param eVuln (Date) - date of earliest vulnerability
 * @param lFix (Date) - date of latest fix
 * @param svgHeight (int) - height of svg
 * @param svgWidth (int) - width of svg
 * @param svgMargin (object) - margins for svg
 * @constructor
 */
function HorizontalTimeline(events, cLowerLim, cUpperLim, minChicHeight, maxChicHeight, chicWidth, zoom, minDate,
                            maxDate, eVcc, eVuln, lFix, svgHeight, svgWidth, svgMargin) {
    //instance variables
    this.events = events;
    this.cLowerLim = cLowerLim;
    this.cUpperLim = cUpperLim;
    this.cLim = cUpperLim;
    this.minChicHeight = minChicHeight;
    this.maxChicHeight = maxChicHeight;
    this.chicHeight = maxChicHeight;
    this.chicWidth = chicWidth;
    this.zoom = zoom;
    this.absMinDate = minDate;
    this.absMaxDate = maxDate;
    this.eVcc = eVcc;
    this.eVuln = eVuln;
    this.lFix = lFix;
    this.svgHeight = svgHeight;
    this.svgWidth = svgWidth;
    this.svgMargin = svgMargin;
    this.numCols = width / chicWidth;
    this.validTypes = [];
    this.eDict = {};
    this.min;
    this.max;
    this.svg;

    //methods
    this.toString = function() {
        return 'Events: ' + this.events;
    };

    /**
     * get the column ids(dates) based on numCols and zoom
     * and add them as keys to eDict
     */
    this.initEDict = function() {
        zFunc = this.getZoom();
        this.min = zFunc.min;
        this.max= zFunc.max;
        var range = this.calculateDateRange(this.min, this.max);
        var inc = range / this.numCols;
        for (var i = 0; i < this.numCols; i++) {
            this.eDict[this.addDays(this.min, i * inc)] = [];
        }
        this.eDict[this.max] = [];
        this.keys = Object.keys(this.eDict);
    };

    /**
     * add events within date range to eDict column with closest date.
     * add the event's type to validTypes;
     */
    this.generateData = function() {
        var self = this;
        this.events.forEach(function(e) {
            if ((e.date >= self.min) && (e.date <= self.max)) {
                if (self.validTypes.indexOf(e.type) === -1) {
                    self.validTypes.push(e.type);
                }
                var col = self.getCol(e.date);
                self.eDict[col].push(e.date);
            }
        });
    };

    /**
     * determine what the chicHeight and chicLimite will be
     */
    this.calcChicHeight = function() {
        var cols = Object.keys(this.eDict);
        var maxColCount = cols[0].length;
        var self = this;
        cols.forEach(function(key) {
            var eArr = self.eDict[key];
            var count = eArr.length;
            if (count > maxColCount) {
                maxColCount = count;
            }
        });
        if (maxColCount > this.clowerLim) {
            this.chicHeight = this.minChicHeight;
            this.cLim = this.cLowerLim;
        }
    };


    this.generateTimeline = function() {
        //removeSVG

        //initialize svg
        //var y = d3.scaleLinear();
        //y.domain([0, yIconCount]).range([height, 0]);

        //plot events
            //loop through eDict columns (keys). y in each column is cumulative for each event. x is cumulative for the keys
                //if event type is release
                    //draw flag
                //else
                    //draw rectangle
            //when column limit is reached, draw overflow

        //plot x-axis
        return;
    };

    this.generateFilters = function() {
        //draw filters (see generateTypeSwitches()
        //callback for filters to update horizontal timeline on change
        return;
    };

    this.updateVerticalTimeline = function() {
        //update vertical timeline based on toggled filters
        return;
    };

    this.setup = function() {
        this.initEDict();
        this.generateData();
        this.calcChicHeight();
    };

    this.generate = function() {
        this.generateTimeline();
        this.generateFilters();
        this.updateVerticalTimeline();
    };

    //helper methods
    /**
     * Adds a number of days to a given date
     * @param date - the starting date
     * @param days - the number of days to add
     * @returns {Date} A date + days
     */
    this.addDays = function(date, days) {
        var result = new Date(date);
        result.setDate(result.getDate() + days);
        return result;
    };

    /**
     * Calculates the range between two dates
     * @param a - the start date
     * @param b - the end date
     * @returns {number} the difference (absolute) between the dates
     */
    this.calculateDateRange = function(a, b) {

        var utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
        var utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());

        return Math.abs(Math.floor((utc2 - utc1) / (86400000)));
    };

    this.drawOverflow = function() {
        return;
    };

    /**
     * Go through columns and pick which column the event goes into based on
     * closest date
     * @param date - a js date object
     * @returns Date - the date closest to the date provided in the js object which
     * corresponds to the key in the eDict
     */
    this.getCol = function(date) {
        var cols = Object.keys(this.eDict);
        var c = new Date(cols[0]);
        if (date && cols) {
            for (var i = 0; i < cols.length - 1; i++) {
                if (this.calculateDateRange(new Date(cols[i]), date) < this.calculateDateRange(c, new Date(cols[i]))) {
                    c = new Date(cols[i]);
                }
            }
        }

        return c;
    };

    /**
     * get the zoom min and max dates or disable zoom if there are no important
     * dates found
     * @returns {{min: *, max: *}} - both Date objects
     */
    this.getZoom = function() {
        var min = this.absMinDate;
        var max = this.absMaxDate;
        if (this.zoom) {
            if (this.eVcc) {
                min = this.eVcc;
            } else if (this.eVuln) {
                min = this.eVuln;
            }
            if (this.lFix) {
                max = this.lFix;
            }
        }
        if (!eVcc && !eVuln && !lFix) {
            $('#zoom-div').hide();
        }

        return {
            min: min,
            max: max,
        };
    };

}