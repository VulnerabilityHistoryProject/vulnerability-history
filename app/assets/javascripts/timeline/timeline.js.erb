/**
 * Given a string d, create a date
 * @param d - json format date string
 * @returns {Date} a JS date item
 */
function getDate(d) {
    return new Date(d);
}

/**
 * Adds a number of days to a given date
 * @param date - the starting date
 * @param days - the number of days to add
 * @returns {Date} A date + days
 */
function addDays(date, days) {
    var result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
}

/**
 * Calculates the range between two dates
 * @param a - the start date
 * @param b - the end date
 * @returns {number} the difference (absolute) between the dates
 */
function calculateDateRange(a, b) {

    var utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
    var utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());

    return Math.abs(Math.floor((utc2 - utc1) / (86400000)));
}

/**
 * Get the date groups given a number of slots and the bins (for computing range)
 * @param startDate - the start date
 * @param endDate - the end date
 * @param slots - the total number of bunches to make
 * @returns {Array} the dates to place items around
 */
function getDatePadLocations(startDate, endDate, slots) {
    var timeSpan = calculateDateRange(startDate, endDate);
    var increment = (timeSpan / slots);
    var days = [];
    for (var i = 0; i < slots; i++) {
        days.push(addDays(startDate, i * increment))
    }
    days.push(endDate);
    return days;
}

/**
 * Go through a list of dates and find the date closest to the provided date
 * @param daysList - the list of dates to look through
 * @param date - a js date object
 * @returns Date - the date closest to the date provided in the js object
 */
function getClosestDate(daysList, date) {

    var closestDate = daysList[0];
    if (date && daysList) {
        for (var i = 0; i < daysList.length - 1; i++) {
            if (calculateDateRange(daysList[i], date) < calculateDateRange(closestDate, daysList[i])) {
                closestDate = daysList[i];
            }
        }
    }
    return closestDate;
}

/**
 * Get the y coordinate to place the vulnerability item
 * @param date - the date to check the y coordinate for
 * @param occupiedSlots - a dictionary containing dates and number of items at that date
 * @returns Integer - y coordinate to place tile
 */
function getY(date, occupiedSlots) {
    if (occupiedSlots[date] == null) {
        occupiedSlots[date] = 1;
        return 1;
    }
    else {
        occupiedSlots[date] = occupiedSlots[date] += 1;
        return occupiedSlots[date];
    }
}

/**
 * Given a type (string) either v,p,b,or x, return a hex color string
 * @param type - a string that specifies the type of vulnerability
 * @returns {*} the color for that vulnerability
 */
function getColor(type) {
    <% EventStyle.all.each do |es| %>

    if (type == "<%= es.event_type %>") {
        return "<%= es.color %>";
    }
    <% end %>
    return "#888888";
}

/**
 * Gets correct img name given a vulnerability type
 * @param type - a string that specifies the type of vulnerability
 */
function getImageName(type) {
    <% EventStyle.all.each do |es| %>
    if (type == "<%= es.event_type %>") {
        return "<%= es.icon %>";
    }
    <% end %>
    return 'bug_report';
}


/**
 * Temporary function to remove the svg on draw in order to update it, will eventually be replaced with actual update
 * methods.
 */
function removeSVG() {
    var svg = d3.select("svg");
    d3.select("#hTimeline").remove();
}

/**
 * Given a type, check if it is contained in types dictionary, and add it if not
 * @param type - the data_type of the current data point
 * @param types - a type dictionary, containing some (or all) data_types
 */
function updateTypes(type, types) {
    if (types.indexOf(type) == -1) {
        types.push(type)
    }
    return types
}

/**
 * Title casing function
 * @param str - string to title case
 * @returns String - title cased string
 */
function toTitleCase(str) {
    return str.replace(/\w\S*/g, function (txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
}

/**
 * Given types, generate toggle switches for them for filtering
 * @param types - a type dictionary, containing all data_types
 */
function generateTypeSwitches(types) {
    var container = document.createDocumentFragment();
    for (var i = 0; i < types.length; i++) {
        // generate checkbox
        var checkbox = document.createElement('input');
        checkbox.id = types[i] + "-toggle";
        checkbox.type = "checkbox";
        checkbox.checked = true;
        // generate label for checkbox
        var label = document.createElement('label');
        label.htmlFor = types[i] + "-toggle";
        label.appendChild(document.createTextNode(toTitleCase(renameTypeLabel(types[i]))));
        container.appendChild(checkbox);
        container.appendChild(label);
    }
    document.getElementById('toggle-block').appendChild(container);
}

/**
 * Function used to display type labels as some other type if necessary
 * @param type the current data type
 * @returns {*} a new type, what should be displayed
 */
function renameTypeLabel(type) {
    switch (type) {
        case "commit_filepath":
            return "edit";
            break;
        default:
            return type;
            break;
    }

}

/**
 * Returns the visible types, given the valid types list
 * @global validTypes
 * @returns Array - the visible types
 */
function visibleTypes() {
    var types = [];
    for (var i = 0; i < validTypes.length; i++) {
        if ($('#' + validTypes[i] + '-toggle').is(':checked')) {
            types.push(validTypes[i])
        }
    }

    if (types.length == 0) {
        return validTypes;
    }
    else return types;

}

/**
 * Given a date, check if it is greater than the minimum date, and return it instead if it is
 * @param date - the date to validate
 * @param minDate - the date that is the current minimum
 * @returns Date - smaller of two values
 */
function getMinDate(date, minDate) {
    if (date < minDate) {
        return date;
    }
    else {
        return minDate;
    }
}

/**
 * Given a date, check if it is greater than the maximum date, and return it instead if it is
 * @param date - the date to validate
 * @param maxDate - the date that is the current maximum
 * @returns Date - larger of two values
 */
function getMaxDate(date, maxDate) {
    if (date > maxDate) {
        return date;
    }
    else {
        return maxDate;
    }
}

/**
 * Global Variable to contain data types, used for filtering
 * @type {Array}
 */
var validTypes = [];
/**
 * Global variables used to store the minimum and maximum date, computed by initialize timeline and used
 * when the timeline is drawn
 * @type {Date}
 */
var minDate = getDate(Date.now()),
    maxDate = getDate('0');


var margin = {top: 10, right: 20, bottom: 30, left: 60},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

var iconWidth = 20,
    iconHeight = 15,
    iconCornerRadius = 3;

var slots = width / iconWidth; // number of different date slots

var datePadLocations;
var groupSize = 5;


/**
 * Function to first find minimum and maximum dates, append the checkboxes, and finally draw the timeline
 * Called on the timeline's first run
 */
function initializeTimeline() {
    $(".cd-timeline-block").each(function () { // Read events for the first time and find min / max date
        var string_date = $(this).find("#date").text().trim();
        var date = getDate(string_date);
        minDate = getMinDate(date, minDate);
        maxDate = getMaxDate(date, maxDate);
        var data_type = $(this).attr('id');
        validTypes = updateTypes(data_type, validTypes)
    });
    datePadLocations = getDatePadLocations(minDate, maxDate, slots);
    generateTypeSwitches(validTypes);
    generateTimeline();
}

/**
 * @global validTypes - the valid data types
 * @param timelineTypeKeys
 */
function removeFilteredTypes(timelineTypeKeys) {
    timelineTypeKeys = $(timelineTypeKeys).filter(visibleTypes());
    return timelineTypeKeys;
}


/**
 * Generate an HTML blob that will be used for creating mini-blocks inside of the main timeline groups
 * @param group a group, with size of groupSize, containing dictionary items corresponding to each element in that group
 */
function createTooltipGroupHTML(group) {
    var html = "";
    group.forEach(function (event) {
        if (event && typeof event === 'object') {
            html += '<a onclick="return true" href="#' + event["id"] + '">' + toTitleCase(renameTypeLabel(event.name)) + '</a><br>'
        }
    });
    return html;
}

/**
 * Function to setup the timeline to use correct styling and hide hidden blocks
 */
function setupVerticalTimeline() {
    var visible = visibleTypes();
    var imageName;
    $(".cd-timeline-block").each(function () {
        var dataType = $(this).attr('id');
        if ($.inArray(dataType, visible) == -1) { // if data is not in visible, hide it
            $(this).fadeOut();
        }
        else {
            $(this).find("#timeline-icon").text(function () {
                imageName = getImageName(dataType);
            });
            $(this).find(".cd-timeline-img").attr('style', 'background:' + getColor(dataType));
            $(this).fadeIn();
        }
    });
    return imageName;
}



/**
 * Function to draw the timeline - draws both the horizontal and vertical timeline
 */
function generateTimeline() {
    removeSVG();
    setupVerticalTimeline();
    var timelineData = createTimelineData();
    createGroupedObjects(timelineData);
    var toAdd = document.createDocumentFragment();

    var x = d3.scaleTime();
    var y = d3.scaleLinear();
    var svg = d3.select('#horizontal-timeline').append("svg")
        .attr("width", "100%")
        .attr("viewBox", "0 0 960 " + 500)
        .attr("id", "hTimeline")
        .attr("height", height + margin.top + margin.bottom)
        .attr('opacity', 0)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Set the scale domains.
    x.domain([minDate, maxDate]).range([0, width]);
    y.domain([0, 30]).range([height, 0]);

    var occupiedXYValues = {};
    var timelineDataKeys = Object.keys(timelineData); // timelineDataKeys represents the date groups
    index = 0;
    for (var i = 0; i < timelineDataKeys.length; i++) {
        var timelineTypeDict = timelineData[timelineDataKeys[i]];
        var timelineTypeKeys = Object.keys(timelineTypeDict); // remove Filtered types here
        timelineTypeKeys = removeFilteredTypes(timelineTypeKeys);
        for (var j = 0; j < timelineTypeKeys.length; j++) {
            var timelineGroupsObject = timelineTypeDict[timelineTypeKeys[j]];
            timelineGroupsObject.forEach(function (group) {
                if (group && group.length < groupSize) { // plot all items in groups smaller than groupSize
                    group.forEach(function (event) {
                        if (event && typeof event === 'object') {
                            var tip = d3.select("#tooltips").append("div") // render tooltips
                                .attr("class", "tooltip")
                                .attr("id", index)
                                .style("display", "none")
                                .on('mouseenter', function (d, i) {
                                    tip.transition().duration(0);
                                })
                          index += 1;
                          if (event.data_type == 'release'){ // If it is a release, draw a flag!
                            var closestDate = getClosestDate(datePadLocations, event.date);
                            var startX = x(closestDate) + (iconWidth / 2);
                            var startY = y(getY(closestDate, occupiedXYValues));
                            var flagHeight = 40;
                            var lineData = [
                                { "x": startX,       "y": startY + iconHeight},
                                { "x": startX,       "y": startY - flagHeight},
                                { "x": startX + 25,  "y": startY - flagHeight + 5},
                                { "x": startX,       "y": startY - flagHeight + 10}];
                            var lineFunction = d3.line()
                                .x(function(d) { return d.x; })
                                .y(function(d) { return d.y; });

                            svg.append("path")
                                .attr("d", lineFunction(lineData))
                                .attr("stroke-width", 3)
                                .attr("stroke", getColor(event.data_type))
                                .attr("fill", function () {
                                    return getColor(event.data_type)
                                })
                                .on('click', function () { // link to horizontal-timeline
                                    window.location.href = '#' + event.id;
                                    d3.select(this).attr("stroke", "#00FF00")
                                })
                                .on("mouseenter", function () { // show chicklet
                                    d3.select(this).attr("stroke", "#9933ff");
                                    tip.transition()
                                        .duration(0)
                                        .style("display", "block");
                                    var matrix = this.getScreenCTM()
                                        .translate(+this.getAttribute("x"), +this.getAttribute("y"));
                                    tip.html('<h5>' + event.name + '</h5><p id="date">'
                                        + moment(event.date).format('MMMM Do YYYY, h:mm a')
                                        + '<p>' + event.description + '</p><a href="#' + + event["id"] + '" class="cd-read-more">Read more</a>')
                                        .style("left", (window.pageXOffset + matrix.e) + "px")
                                        .style("top", (window.pageYOffset + matrix.f) + "px") // + 28
                                })
                                .on("mouseleave", function () { // hide chicklet
                                    d3.select(this).attr("stroke", getColor(event.data_type));
                                    tip.transition()
                                        .style("display", "none");
                                });

                          } else {
                            svg.append("svg:rect") //draw the chicklets
                                .attr("class", "bin")
                                .attr("x", function () {
                                    return x(getClosestDate(datePadLocations, event.date));
                                })
                                .attr("y", function () {
                                    return y(getY(getClosestDate(datePadLocations, event.date), occupiedXYValues));
                                })
                                .attr("width", iconWidth)
                                .attr("height", iconHeight)
                                .attr("rx", iconCornerRadius)
                                .attr("ry", iconCornerRadius)
                                .attr("fill", function () {
                                    return getColor(event.data_type)
                                })
                                .on('click', function () { // link to horizontal-timeline
                                    window.location.href = '#' + event.id;
                                    d3.select(this).attr("stroke", "#00FF00")
                                })
                                .on("mouseenter", function () { // show chicklet
                                    d3.select(this).attr("stroke", "#FFFFFF");
                                    tip.transition()
                                        .duration(0)
                                        .style("display", "block");
                                    var matrix = this.getScreenCTM()
                                        .translate(+this.getAttribute("x"), +this.getAttribute("y"));
                                    tip.html('<h5>' + event.name + '</h5><p id="date">'
                                        + moment(event.date).format('MMMM Do YYYY, h:mm a')
                                        + '<p>' + event.description + '</p><a href="#' + + event["id"] + '" class="cd-read-more">Read more</a>')
                                        // .style("left", (window.pageXOffset + matrix.e) + 30 + "px")
                                        // .style("top", (window.pageYOffset + matrix.f) - 75 + "px");
                                        .style("left", (window.pageXOffset + matrix.e) - 90 + "px")
                                        .style("top", (window.pageYOffset + matrix.f) + 40 + "px") // + 28
                                })
                                .on("mouseleave", function () { // hide chicklet
                                    d3.select(this).attr("stroke", "");
                                    tip.transition()
                                        .style("display", "none");
                                });
                             }
                          }

                    });
                }
                else if (group) { // plot the groups as single blocks

                    var eventOne = group[0];
                    var eventOneDate = eventOne.date;
                    var tip = d3.select("#tooltips").append("div")
                        .attr("class", "tooltip bottom")
                        .style("display", "none")
                        .on('mouseenter', function (d, i) {
                            tip.transition().duration(0);
                        })
                        .on('mouseleave', function (d, i) {
                            tip.style('display', 'none');
                        });
                    var iconX = getClosestDate(datePadLocations, eventOneDate),
                        iconY = getY(getClosestDate(datePadLocations, eventOneDate), occupiedXYValues);
                    var groupIcon = svg.append("svg:g")
                        .attr("transform", "translate(" + x(iconX) + "," + y(iconY) + ")")
                        .on("mouseenter", function () {
                            d3.select(this).attr("stroke", "#FFFFFF");
                            tip.transition()
                                .duration(0)
                                .style("display", "block");
                            var matrix = this.getScreenCTM()
                                .translate(+this.getAttribute("x"), +this.getAttribute("y"));
                            tip.html(createTooltipGroupHTML(group))
                            .style("left", (window.pageXOffset + matrix.e) - 90 + "px")
                            .style("top", (window.pageYOffset + matrix.f) + 28 + "px")
                        })
                        .on("mouseleave", function () {
                            d3.select(this).attr("stroke", "");
                            tip.transition()
                                .delay(50)
                                .style("display", "none");
                        });
                    groupIcon
                        .append("rect")
                        .attr("class", "bin")
                        .attr("width", iconWidth)
                        .attr("height", iconHeight)
                        .attr("rx", iconCornerRadius)
                        .attr("ry", iconCornerRadius)
                        .attr("stroke-width", 0.5)
                        .attr("stroke", "#000000")
                        .attr("fill", function () {
                            return getColor(eventOne.data_type)
                        });
                    groupIcon.append("svg:line")
                        .attr("x1", function () {
                            return 0;
                        })
                        .attr("y1", function () {
                            return iconHeight / 2 - iconHeight / 8;
                        })
                        .attr("x2", function () {
                            return iconWidth
                        })
                        .attr("y2", function () {
                            return iconHeight / 2 - iconHeight / 8;
                        })
                        .attr("stroke-width", 0.5)
                        .attr("stroke", "#000000");
                    groupIcon.append("svg:line")
                        .attr("x1", function () {
                            return 0;
                        })
                        .attr("y1", function () {
                            return iconHeight / 2;
                        })
                        .attr("x2", function () {
                            return iconWidth
                        })
                        .attr("y2", function () {
                            return iconHeight / 2;
                        })
                        .attr("stroke-width", 0.5)
                        .attr("stroke", "#000000");
                    groupIcon.append("svg:line")
                        .attr("x1", function () {
                            return 0;
                        })
                        .attr("y1", function () {
                            return iconHeight / 2 + iconHeight / 8;
                        })
                        .attr("x2", function () {
                            return iconWidth
                        })
                        .attr("y2", function () {
                            return iconHeight / 2 + iconHeight / 8;
                        })
                        .attr("stroke-width", 0.5)
                        .attr("stroke", "#000000");

                }
            });
        }

    }

    // Append the x-axis to the horizontal timeline
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x));

    d3.select('#hTimeline').transition().duration(1000).attr('opacity', 1);
    document.getElementById('cd-timeline').appendChild(toAdd);
}

/**
 * Function to create the dictionary of timeline data, basically doing what getClosestDate does, but creating an object
 * This is incredibly complicated because I'm nesting data types like crazy - it looks like this:
 * dict(dateGroup: dict(data_type: list(eventAsDict)))
 * Expanded that looks like:
 *
 * {
 *  dateGroup: {
 *              data_type: [
 *                          {
 *                            "id": id,
 *                            "name": name,
 *                            "description": description,
 *                            "date": date,
 *                            "data_type": data_type
 *                           }
 *                          ]
 *             }
 * }
 *
 */
function createTimelineData() {
    var timelineData = {};
    $(".cd-timeline-block").each(function () {
        var id = $(this).find("a").attr('id');
        var name = $(this).find("#title").text();
        var description = $(this).find("#description").text().trim();
        var string_date = $(this).find("#date").text().trim();
        var date = getDate(string_date);
        var data_type = $(this).attr('id');

        var eventAsDict = {
            "id": id,
            "name": name,
            "description": description,
            "date": date,
            "data_type": data_type
        };
        var closestDate = getClosestDate(datePadLocations, date);
        if (timelineData[closestDate]) {
            var dataTypeDict = timelineData[closestDate];
            if (dataTypeDict[data_type]) {
                var listOfEvents = dataTypeDict[data_type];
                listOfEvents.push(eventAsDict);
                dataTypeDict[data_type] = listOfEvents;
            }
            else {
                dataTypeDict[data_type] = [eventAsDict];
            }
        }
        else {
            var dateGroup = {};
            dateGroup[data_type] = [eventAsDict];
            timelineData[closestDate] = dateGroup;
        }
    });
    return timelineData;
}


/**
 * @global timelineData
 * @global timelineDataKeys
 * Function to run through all items in the timelineData dictionary monster, and update items that aren't grouped to use
 * grouping
 */
function createGroupedObjects(timelineData) {

    var timelineDataKeys = Object.keys(timelineData); // timelineDataKeys represents the date groups
    for (var i = 0; i < timelineDataKeys.length; i++) {
        if (timelineData[timelineDataKeys[i]]) {
            var timelineTypeDict = timelineData[timelineDataKeys[i]];
            var timelineTypeKeys = Object.keys(timelineTypeDict);
            // iterate through second level dictionary and check lengths of items
            for (var j = 0; j < timelineTypeKeys.length; j++) {
                var eventsInGroup = timelineTypeDict[timelineTypeKeys[j]];
                eventsInGroup = createGroups(eventsInGroup);
                timelineTypeDict[timelineTypeKeys[j]] = eventsInGroup;

            }
            timelineData[timelineDataKeys[i]] = timelineTypeDict;
        }
    }

}



/**
 * Function to group an array of items into smaller arrays, the size of the smaller arrays is specified using groupSize
 * @param eventsInGroup - a list of all events (filtered by type) in the date span
 * @global groupSize - the size of groups to create
 */
function createGroups(eventsInGroup) {
    var oldArray = eventsInGroup;
    var newArray = [];
    var j = 0;
    for (var i = 0; i < oldArray.length; i++) {
        if (i % groupSize === 0) {
            j++
        }
        if (!newArray[j]) newArray[j] = [];
        newArray[j].push(oldArray[i])
    }
    return newArray;
}

$(document).ready(function () {
    initializeTimeline();

    var $wrapper = $('#cd-timeline');
    $wrapper.find('.cd-timeline-block').sort(function (a, b) {
        date1 = new Date(a.dataset.id);
        date2 = new Date(b.dataset.id);
        return +date2 - +date1;
    })
        .appendTo( $wrapper );

    $('#cd-timeline').on('click', 'a', function (event) {
        event.preventDefault();

        $('html, body').animate({
            scrollTop: $(event.target).offset().top
        }, 500);
    });

    //Check to see if the window is top if not then display button
    $(window).scroll(function () {
        if ($(this).scrollTop() > 100) {
            $('.scroll-to-top').fadeIn();
        } else {
            $('.scroll-to-top').fadeOut();
        }
    });

    // $(".bin").on('mouseout', function (event) {
    //     $("#tooltips").hide().delay(500);
    // });
    //
    // $(".bin").on('mouseon', function (event) {
    //     $("#tooltips").show();
    // });

    //Click event to scroll to top
    $('.scroll-to-top').click(function () {
        $('html, body').animate({scrollTop: 0}, 600);
        return false;
    });

});
