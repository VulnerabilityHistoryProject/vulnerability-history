/**
 * Given a string d, create a date
 * @param d - json format date string
 * @returns {Date} a JS date item
 */
function getDate(d) {
    return new Date(d);
}

/**
 * Adds a number of days to a given date
 * @param date - the starting date
 * @param days - the number of days to add
 * @returns {Date} A date + days
 */
function addDays(date, days) {
    var result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
}

/**
 * Calculates the range between two dates
 * @param a - the start date
 * @param b - the end date
 * @returns {number} the difference (absolute) between the dates
 */
function calculateDateRange(a, b) {

    var utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
    var utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());

    return Math.abs(Math.floor((utc2 - utc1) / (86400000)));
}

/**
 * Get the date groups given a number of slots and the bins (for computing range)
 * @param startDate - the start date
 * @param endDate - the end date
 * @param slots - the total number of bunches to make
 * @returns {Array} the dates to place items around
 */
function getDatePadLocations(startDate, endDate, slots) {
    var timeSpan = calculateDateRange(startDate, endDate);
    var increment = (timeSpan / slots);
    var days = [];
    for (var i = 0; i < slots; i++) {
        days.push(addDays(startDate, i * increment))
    }
    days.push(endDate);
    return days;
}

/**
 * Go through a list of dates and find the date closest to the provided date
 * @param daysList - the list of dates to look through
 * @param date - a js date object
 * @returns Date - the date closest to the date provided in the js object
 */
function getClosestDate(daysList, date) {

    var closestDate = daysList[0];
    if (date && daysList) {
        for (var i = 0; i < daysList.length - 1; i++) {
            if (calculateDateRange(daysList[i], date) < calculateDateRange(closestDate, daysList[i])) {
                closestDate = daysList[i];
            }
        }
    }
    return closestDate;
}

/**
 * Get the y coordinate to place the vulnerability item
 * @param date - the date to check the y coordinate for
 * @param occupiedSlots - a dictionary containing dates and number of items at that date
 * @returns Integer - y coordinate to place tile
 */
function getY(date, occupiedSlots) {
    if (occupiedSlots[date] == null) {
        occupiedSlots[date] = 1;
        return 1;
    }
    else {
        occupiedSlots[date] = occupiedSlots[date] += 1;
        return occupiedSlots[date];
    }
}

/**
 * Given a type (string) either v,p,b,or x, return a hex color string
 * @param type - a string that specifies the type of vulnerability
 * @returns {*} the color for that vulnerability
 */
function getColor(type) {
    <% EventStyle.all.each do |es| %>

    if (type == "<%= es.event_type %>") {
        return "<%= es.color %>";
    }
    <% end %>
    return "#888888";
}

/**
 * Gets correct img name given a vulnerability type
 * @param type - a string that specifies the type of vulnerability
 */
function getImageName(type) {
    <% EventStyle.all.each do |es| %>
    if (type == "<%= es.event_type %>") {
        return "<%= es.icon %>";
    }
    <% end %>
    return 'bug_report';
}


/**
 * Temporary function to remove the svg on draw in order to update it, will eventually be replaced with actual update
 * methods.
 */
function removeSVG() {
    var svg = d3.select("svg");
    d3.select("#hTimeline").remove();
}

/**
 * Given a type, check if it is contained in types dictionary, and add it if not
 * @param type - the data_type of the current data point
 * @param types - a type dictionary, containing some (or all) data_types
 */
function updateTypes(type, types) {
    if (types.indexOf(type) == -1) {
        types.push(type)
    }
    return types
}

/**
 * Title casing function
 * @param str - string to title case
 * @returns String - title cased string
 */
function toTitleCase(str) {
    return str.replace(/\w\S*/g, function (txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
}

/**
 * Given types, generate toggle switches for them for filtering
 * @param types - a type dictionary, containing all data_types
 */
function generateTypeSwitches(types) {
    var container = document.createDocumentFragment();
    for (var i = 0; i < types.length; i++) {
        // generate checkbox
        var checkbox = document.createElement('input');
        checkbox.id = types[i] + "-toggle";
        checkbox.type = "checkbox";
        checkbox.checked = true
        // generate label for checkbox
        var label = document.createElement('label');
        label.htmlFor = types[i] + "-toggle";
        label.appendChild(document.createTextNode(toTitleCase(renameTypeLabel(types[i]))));
        container.appendChild(checkbox);
        container.appendChild(label);
    }
    document.getElementById('toggle-block').appendChild(container);
}

/**
 * Function used to display type labels as some other type if necessary
 * @param type the current data type
 * @returns {*} a new type, what should be displayed
 */
function renameTypeLabel(type) {
    switch (type) {
        case "commit_filepath":
            return "edit";
            break;
        default:
            return type;
            break;
    }

}

/**
 * Returns the visible types, given the valid types list
 * @global validTypes
 * @returns Array - the visible types
 */
function visibleTypes() {
    var types = [];
    for (var i = 0; i < validTypes.length; i++) {
        if ($('#' + validTypes[i] + '-toggle').is(':checked')) {
            types.push(validTypes[i])
        }
    }

    if (types.length == 0) {
        return validTypes;
    }
    else return types;

}

/**
 * gets the start and stop dates for the horizontal timeline
 *
 * @param zoom - the view state of the horizontal timeline
 * @constructor
 */
function GetDateRange(zoom) {
    this.minDate = getDate(Date.now());
    this.maxDate = getDate('0');
    this.absMinDate = getDate(Date.now());
    this.absMaxDate = getDate('0');
    this.numVcc = 0;
    this.numFix = 0;
    this.zoom = zoom;
    var rangeFinder = this;
    $(".cd-timeline-block").each(function () { // Read events for the first time and find min / max date
        var string_date = $(this).find("#date").text().trim();
        var date = getDate(string_date);
        var data_type = $(this).attr('id');
        var type = data_type.toLowerCase();
        validTypes = updateTypes(data_type, validTypes);
        rangeFinder.absMinDate = getMinDate(date, rangeFinder.absMinDate);
        rangeFinder.absMaxDate = getMaxDate(date, rangeFinder.absMaxDate);
        if (type == 'vcc') {
            rangeFinder.numVcc += 1;
            if (rangeFinder.zoom) {
                rangeFinder.minDate = getMinDate(date, rangeFinder.minDate);
            }

        }
        if (type == 'fix') {
            rangeFinder.numFix += 1;
            if (rangeFinder.zoom) {
                rangeFinder.maxDate = getMaxDate(date, rangeFinder.maxDate);
            }
        }
    });
    if (rangeFinder.numVcc == 0 && rangeFinder.numFix == 0) {
        $('#zoom-div').hide();
    }
    if ((rangeFinder.zoom && (rangeFinder.numVcc == 0)) || !rangeFinder.zoom ) {
        rangeFinder.minDate = rangeFinder.absMinDate;
    }
    if ((rangeFinder.zoom && (rangeFinder.numFix == 0)) || !rangeFinder.zoom) {
        rangeFinder.maxDate = rangeFinder.absMaxDate;
    }

}

/**
 * Given a date, check if it is greater than the minimum date, and return it instead if it is
 * @param date - the date to validate
 * @param minDate - the date that is the current minimum
 * @returns Date - smaller of two values
 */
function getMinDate(date, minDate) {
    if (date < minDate) {
        return date;
    } else {
        return minDate;
    }
}

/**
 * Given a date, check if it is greater than the maximum date, and return it instead if it is
 * @param date - the date to validate
 * @param maxDate - the date that is the current maximum
 * @returns Date - larger of two values
 */
function getMaxDate(date, maxDate) {
    if (date > maxDate) {
        return date;
    } else {
        return maxDate;
    }
}

/**
 * Check if the given date is within the min and max dates
 *
 * @param min
 * @param max
 * @param date
 * @returns {boolean}
 */
function dateInRange(min, max, date){
    var start = new Date(min.getTime());
    var end = new Date(max.getTime());
    start.setHours(0,0,0,0);
    end.setHours(23,59,59,999);
    return (date >= start && date <= end);
}

var validTypes = [];
/**
 * Global variables used to store the minimum and maximum date, computed by initialize timeline and used
 * when the timeline is drawn
 * @type {Date}
 */

var margin = {top: 10, right: 20, bottom: 30, left: 60},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

var iconWidth = 20,
    iconHeight = 15,
    iconCornerRadius = 3;

var slots = width / iconWidth; // number of different date slots

var datePadLocations;
var groupSize = 5;

/**
 * Function to first find minimum and maximum dates, append the checkboxes, and finally draw the timeline
 * Called on the timeline's first run
 */
function initializeTimeline(zoom) {
    var dates = new GetDateRange(zoom);
    var minDate = dates.minDate;
    var maxDate = dates.maxDate;
    datePadLocations = getDatePadLocations(minDate, maxDate, slots);
    generateTypeSwitches(validTypes);
    generateTimeline(minDate, maxDate);
    dataToggleCallback(minDate, maxDate);
}

function dataToggleCallback(minDate, maxDate) {
    $(document).on("change", ".data-toggles", function () {
        generateTimeline(minDate, maxDate);
    });
}

/**
 * @global validTypes - the valid data types
 * @param timelineTypeKeys
 */
function removeFilteredTypes(timelineTypeKeys) {
    timelineTypeKeys = $(timelineTypeKeys).filter(visibleTypes());
    return timelineTypeKeys;
}


/**
 * Generate an HTML blob that will be used for creating mini-blocks inside of the main timeline groups
 * @param group a group, with size of groupSize, containing dictionary items corresponding to each element in that group
 */
function createTooltipGroupHTML(group) {
    var html = "";
    group.forEach(function (event) {
        if (event && typeof event === 'object') {
            html += '<a onclick="return true" href="#' + event["id"] + '">' + toTitleCase(renameTypeLabel(event.name)) + '</a><br>'
        }
    });
    return html;
}

/**
 * Function to setup the timeline to use correct styling and hide hidden blocks
 */
function setupVerticalTimeline() {
    var visible = visibleTypes();
    $(".cd-timeline-block").each(function () {
        var dataType = $(this).attr('id');
        if ($.inArray(dataType, visible) == -1) { // if data is not in visible, hide it
            $(this).fadeOut();
        }
        else {
            $(this).find("#timeline-icon").text(function () {
                return getImageName(dataType)
            });
            $(this).find(".cd-timeline-img").attr('style', 'background:' + getColor(dataType));
            $(this).fadeIn();
        }
    });
}

/**
 * Function to draw the timeline - draws both the horizontal and vertical timeline
 */
function generateTimeline(minDate, maxDate) {
    removeSVG();
    setupVerticalTimeline();
    var timelineDataObj = new  CreateTimelineData(minDate, maxDate);
    var timelineData = timelineDataObj.timelineData;
    createGroupedObjects(timelineData);
    var toAdd = document.createDocumentFragment();

    var x = d3.scaleTime();
    var y = d3.scaleLinear();
    var svg = d3.select('#horizontal-timeline').append("svg")
        .attr("width", "100%")
        .attr("viewBox", "0 0 960 " + 500)
        .attr("id", "hTimeline")
        .attr("height", height + margin.top + margin.bottom)
        .attr('opacity', 0)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Set the scale domains.
    x.domain([minDate, maxDate]).range([0, width]);
    y.domain([0, 30]).range([height, 0]);

    var occupiedXYValues = {};
    var timelineDataKeys = Object.keys(timelineData); // timelineDataKeys represents the date groups
    for (var i = 0; i < timelineDataKeys.length; i++) {
        var timelineTypeDict = timelineData[timelineDataKeys[i]];
        var timelineTypeKeys = Object.keys(timelineTypeDict); // remove Filtered types here
        timelineTypeKeys = removeFilteredTypes(timelineTypeKeys);
        for (var j = 0; j < timelineTypeKeys.length; j++) {
            var timelineGroupsObject = timelineTypeDict[timelineTypeKeys[j]];
            timelineGroupsObject.forEach(function (group) {
                if (group && group.length < groupSize) { // plot all items in groups smaller than groupSize
                    group.forEach(function (event) {
                        if (event && typeof event === 'object') {
                            var tip = d3.select("#tooltips").append("div")
                                .attr("class", "tooltip right")
                                .style("display", "none")
                                .on('mouseenter', function (d, i) {
                                    tip.transition().duration(0);
                                })
                                .on('mouseleave', function (d, i) {
                                    tip.style('display', 'none');
                                });
                            svg.append("svg:rect")
                                .attr("class", "bin")
                                .attr("x", function () {
                                    return x(getClosestDate(datePadLocations, event.date));
                                })
                                .attr("y", function () {
                                    return y(getY(getClosestDate(datePadLocations, event.date), occupiedXYValues));
                                })
                                .attr("width", iconWidth)
                                .attr("height", iconHeight)
                                .attr("rx", iconCornerRadius)
                                .attr("ry", iconCornerRadius)
                                .attr("fill", function () {
                                    return getColor(event.data_type)
                                })
                                .on('click', function () {
                                    window.location.href = '#' + event.id;
                                    d3.select(this).attr("stroke", "#00FF00")
                                })
                                .on("mouseenter", function () {
                                    d3.select(this).attr("stroke", "#FFFFFF");
                                    tip.transition()
                                        .duration(0)
                                        .style("display", "block");
                                    var matrix = this.getScreenCTM()
                                        .translate(+this.getAttribute("x"), +this.getAttribute("y"));
                                    tip.html('<h5>' + event.name + '</h5><p id="date">'
                                        + moment(event.date).format('MMMM Do YYYY, h:mm a')
                                        + '<p>' + event.description + '</p><a href="#' + + event["id"] + '" class="cd-read-more">Read more</a>')
                                        .style("left", (window.pageXOffset + matrix.e + 30) + "px")
                                        .style("top", (window.pageYOffset + matrix.f) - 75 + "px");
                                })
                                .on("mouseleave", function () {
                                    d3.select(this).attr("stroke", "");
                                    tip.transition()
                                        .delay(50)
                                        .style("display", "none");
                                });

                        }

                    });
                }
                else if (group) { // plot the groups as single blocks

                    var eventOne = group[0];
                    var eventOneDate = eventOne.date;
                    var tip = d3.select("#tooltips").append("div")
                        .attr("class", "tooltip right")
                        .style("display", "none")
                        .on('mouseenter', function (d, i) {
                            tip.transition().duration(0);
                        })
                        .on('mouseleave', function (d, i) {
                            tip.style('display', 'none');
                        });
                    var iconX = getClosestDate(datePadLocations, eventOneDate),
                        iconY = getY(getClosestDate(datePadLocations, eventOneDate), occupiedXYValues);
                    var groupIcon = svg.append("svg:g")
                        .attr("transform", "translate(" + x(iconX) + "," + y(iconY) + ")")
                        .on("mouseenter", function () {
                            d3.select(this).attr("stroke", "#FFFFFF");
                            tip.transition()
                                .duration(0)
                                .style("display", "block");
                            var matrix = this.getScreenCTM()
                                .translate(+this.getAttribute("x"), +this.getAttribute("y"));
                            tip.html(createTooltipGroupHTML(group))
                                .style("left", (window.pageXOffset + matrix.e + 30) + "px")
                                .style("top", (window.pageYOffset + matrix.f) - 50 + "px");
                        })
                        .on("mouseleave", function () {
                            d3.select(this).attr("stroke", "");
                            tip.transition()
                                .delay(50)
                                .style("display", "none");
                        });
                    groupIcon
                        .append("rect")
                        .attr("class", "bin")
                        .attr("width", iconWidth)
                        .attr("height", iconHeight)
                        .attr("rx", iconCornerRadius)
                        .attr("ry", iconCornerRadius)
                        .attr("stroke-width", 0.5)
                        .attr("stroke", "#000000")
                        .attr("fill", function () {
                            return getColor(eventOne.data_type)
                        });
                    groupIcon.append("svg:line")
                        .attr("x1", function () {
                            return 0;
                        })
                        .attr("y1", function () {
                            return iconHeight / 2 - iconHeight / 8;
                        })
                        .attr("x2", function () {
                            return iconWidth
                        })
                        .attr("y2", function () {
                            return iconHeight / 2 - iconHeight / 8;
                        })
                        .attr("stroke-width", 0.5)
                        .attr("stroke", "#000000");
                    groupIcon.append("svg:line")
                        .attr("x1", function () {
                            return 0;
                        })
                        .attr("y1", function () {
                            return iconHeight / 2;
                        })
                        .attr("x2", function () {
                            return iconWidth
                        })
                        .attr("y2", function () {
                            return iconHeight / 2;
                        })
                        .attr("stroke-width", 0.5)
                        .attr("stroke", "#000000");
                    groupIcon.append("svg:line")
                        .attr("x1", function () {
                            return 0;
                        })
                        .attr("y1", function () {
                            return iconHeight / 2 + iconHeight / 8;
                        })
                        .attr("x2", function () {
                            return iconWidth
                        })
                        .attr("y2", function () {
                            return iconHeight / 2 + iconHeight / 8;
                        })
                        .attr("stroke-width", 0.5)
                        .attr("stroke", "#000000");

                }
            });
        }

    }

    // Append the x-axis to the horizontal timeline
    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x));

    d3.select('#hTimeline').transition().duration(1000).attr('opacity', 1);
    document.getElementById('cd-timeline').appendChild(toAdd);
}

/**
 * Function to create the dictionary of timeline data, basically doing what getClosestDate does, but creating an object
 * This is incredibly complicated because I'm nesting data types like crazy - it looks like this:
 * dict(dateGroup: dict(data_type: list(eventAsDict)))
 * Expanded that looks like:
 *
 * {
 *  dateGroup: {
 *              data_type: [
 *                          {
 *                            "id": id,
 *                            "name": name,
 *                            "description": description,
 *                            "date": date,
 *                            "data_type": data_type
 *                           }
 *                          ]
 *             }
 * }
 *
 */
function CreateTimelineData(minDate, maxDate) {
    this.minDate = minDate;
    this.maxDate = maxDate;
    this.timelineData = {};
    var creator = this;
    $(".cd-timeline-block").each(function () {
        var string_date = $(this).find("#date").text().trim();
        var date = getDate(string_date);
        if (dateInRange(creator.minDate, creator.maxDate, date)) {
            var id = $(this).find("a").attr('id');
            var name = $(this).find("#title").text();
            var description = $(this).find("#description").text().trim();


            var data_type = $(this).attr('id');

            var eventAsDict = {
                "id": id,
                "name": name,
                "description": description,
                "date": date,
                "data_type": data_type
            };
            var closestDate = getClosestDate(datePadLocations, date);
            if (creator.timelineData[closestDate]) {
                var dataTypeDict = creator.timelineData[closestDate];
                if (dataTypeDict[data_type]) {
                    var listOfEvents = dataTypeDict[data_type];
                    listOfEvents.push(eventAsDict);
                    dataTypeDict[data_type] = listOfEvents;
                }
                else {
                    dataTypeDict[data_type] = [eventAsDict];
                }
            }
            else {
                var dateGroup = {};
                dateGroup[data_type] = [eventAsDict];
                creator.timelineData[closestDate] = dateGroup;
            }
        }
    });
}


/**
 * @global timelineData
 * @global timelineDataKeys
 * Function to run through all items in the timelineData dictionary monster, and update items that aren't grouped to use
 * grouping
 */
function createGroupedObjects(timelineData) {

    var timelineDataKeys = Object.keys(timelineData); // timelineDataKeys represents the date groups
    for (var i = 0; i < timelineDataKeys.length; i++) {
        if (timelineData[timelineDataKeys[i]]) {
            var timelineTypeDict = timelineData[timelineDataKeys[i]];
            var timelineTypeKeys = Object.keys(timelineTypeDict);
            // iterate through second level dictionary and check lengths of items
            for (var j = 0; j < timelineTypeKeys.length; j++) {
                var eventsInGroup = timelineTypeDict[timelineTypeKeys[j]];
                eventsInGroup = createGroups(eventsInGroup);
                timelineTypeDict[timelineTypeKeys[j]] = eventsInGroup;

            }
            timelineData[timelineDataKeys[i]] = timelineTypeDict;
        }
    }

}



/**
 * Function to group an array of items into smaller arrays, the size of the smaller arrays is specified using groupSize
 * @param eventsInGroup - a list of all events (filtered by type) in the date span
 * @global groupSize - the size of groups to create
 */
function createGroups(eventsInGroup) {
    var oldArray = eventsInGroup;
    var newArray = [];
    var j = 0;
    for (var i = 0; i < oldArray.length; i++) {
        if (i % groupSize === 0) {
            j++
        }
        if (!newArray[j]) newArray[j] = [];
        newArray[j].push(oldArray[i])
    }
    return newArray;
}

$(document).ready(function () {
    initializeTimeline(true);

    var $wrapper = $('#cd-timeline');
    $wrapper.find('.cd-timeline-block').sort(function (a, b) {
        date1 = new Date(a.dataset.id);
        date2 = new Date(b.dataset.id);
        return +date2 - +date1;
    })
        .appendTo( $wrapper );

    $('#zoom-button').click(function() {
        var zoom = $('#zoom-bool').val();
        if ($('#zoom-bool').val() == "true") {
            $('#zoom-bool').val("false");
            $('#zoom-button').text('zoom in');
            zoom = false;
        } else {
            $('#zoom-bool').val("true");
            $('#zoom-button').text('zoom out');
            zoom = true;
        }
        $('#toggle-block').empty();
        initializeTimeline(zoom);
    });

    $('#cd-timeline').on('click', 'a', function (event) {
        event.preventDefault();

        $('html, body').animate({
            scrollTop: $(event.target).offset().top
        }, 500);
    });

    //Check to see if the window is top if not then display button
    $(window).scroll(function () {
        if ($(this).scrollTop() > 100) {
            $('.scroll-to-top').fadeIn();
        } else {
            $('.scroll-to-top').fadeOut();
        }
    });

    //Click event to scroll to top
    $('.scroll-to-top').click(function () {
        $('html, body').animate({scrollTop: 0}, 600);
        return false;
    });

});
