function parentify(apiData) {
    const parents = { '/': '' } // init with root directory
    apiData.forEach(entry => {
        let filepath = entry.filepath
        while (filepath.indexOf('/') > 0) {
            filepath = filepath.substring(0, filepath.lastIndexOf('/'))
            parents[filepath] = parents[filepath] || '' // Ruby ||=
        }
    })
    for(let parent in parents) {
        apiData.push({
            'filepath': parent,
            'id': null
        })
    }
    apiData.sort((a, b) => (a.filepath > b.filepath) ? 1 : ((b.filepath > a.filepath) ? -1 : 0))
    return apiData
}

// Given filepath data with parents, generate a cluster hierarchy
// Also: add up the values of each parent
function clusterify(data) {
    const stratify = d3.stratify()
        .parentId(d => {
            if (d.filepath === '/') return null
            return d.filepath.indexOf('/') > 0
                ? d.filepath.substring(0, d.filepath.lastIndexOf('/')) // not root file
                : '/' // root file
        })
        .id(d => d.filepath)
    return stratify(data)
        .sum(d => d.id || d.is_cve ? 1 : 0)
        .sort((a, b) => b.height - a.height || b.value - a.value)
}

function hashCode(str) {
    // based off of Java's String #hashCode method
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash)
        hash |= 0
    }
    return Math.abs(hash)
}


$.ajax({
    url: "/api/filepaths?offenders=true",
    dataType: 'json',
    success: function (apiData) {
        const currentFilePath = FILE_PATH
        const parent = currentFilePath.substring(0, currentFilePath.indexOf('/')) || currentFilePath
        const isChildOf = (child, parent) => {
            if (child === parent && parent === currentFilePath) return true;
            if (child === parent) return false;
            const parentTokens = parent.split('/')
            const childTokens = child.split('/')
            if (childTokens.length < parentTokens) return false
            return parentTokens.every((t, i) => childTokens[i] === t)
        }

        // filter out unneeded filepaths
        const reducedData = apiData.filter(d => isChildOf(d.filepath, parent))

        const parentData = parentify(reducedData)

        const cveData = []

        parentData.map(d => {
            if (d.id) {
                d.cves.split(",").forEach(cve => {
                    cveData.push({
                        ...d,
                        filepath: d.filepath + "/" + cve,
                        is_cve: true,
                        id: null
                    })
                })
            }
            return d
        })

        const root = clusterify([...parentData, ...cveData])

        const height = 40 * root.value
        const width = 200 * (root.height+1)

        // select the svg to display the pedigree at
        const svg = d3.select("#pedigree-partition")
            .attr('height', height)
            .attr('width', width)

        // switch color helper function
        const cveColor = d3.scaleSequential()
            .domain([0, root.value])
            .interpolator(d3.interpolateRainbow)

        const fileColor = d3.scaleOrdinal(d3.schemeCategory10)

        // partition helper function
        const partition = d3.partition()
            .size([height, width])
            .padding(2)

        partition(root)

        // customized and configure each cell
        const cell = svg
            .selectAll(".node")
            .data(root.descendants())
            .enter()
            .append("g")
            .filter(d => {
                if(d.id === "/") return false
                const len = d.children ? d.children.length : 0
                return d.data.id || d.data.is_cve || len >= 1
            })
            .attr("class", d => "node" + (d.data.id != null ? " node--leaf" : " node--internal"))
            .attr("transform", d => "translate(" + d.y0 + "," + d.x0 + ")")
            .append("a")
            .attr("href", d => d.data.id ? "/filepaths/" + d.data.id + "#pedigree" : null)
            .attr("class", "rect-link")

        cell.append("rect")
            .attr("id", d => "rect-" + d.data.filepath)
            .attr("width", d => d.y1 - d.y0)
            .attr("height", d => d.x1 - d.x0)
            .filter(d => d.data.id != null || d.data.is_cve)
            .style("fill", d => {
                return d.data.is_cve
                    ? cveColor(hashCode(d.data.filepath.split("/").slice(-1)[0])%(root.value))
                    : fileColor(d.data.filepath.split(".").slice(-1)[0])
            })
            .filter(d => d.data.is_cve)
            .attr("class", "rect-cve")
            .attr("rx", 10)
            .attr("ry", 10)

        cell.append("text")
            .attr("x", 16)
            .selectAll("tspan")
            .data(d => {
                const path = d.data.filepath.split("/").slice(-1)[0]
                return d.data.id
                    ? path
                    : d.data.is_cve ? path : path + "/"
            })
            .enter().append("tspan")
            .attr("y", 13)
            .text(d => d)

        cell.append("text")
            .attr('font-family', 'FontAwesome')
            .attr("x", 4)
            .selectAll("tspan")
            .data(d => {
                if (d.data.id) {
                    return '\uf15b'
                } else if (d.data.is_cve) {
                    return '\uf188'
                } else {
                    return '\uf07b'
                }
            })
            .enter().append("tspan")
            .attr("y", 13)
            .text(d => d)

        $('#loading_map').remove()
    }
})