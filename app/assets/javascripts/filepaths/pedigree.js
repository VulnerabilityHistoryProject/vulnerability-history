function parentify(apiData, p) {
    const parents = {} // init with root directory
    parents[p] = ''
    apiData.forEach(entry => {
        let filepath = entry.filepath
        while (filepath.indexOf('/') > 0) {
            filepath = filepath.substring(0, filepath.lastIndexOf('/'))
            parents[filepath] = parents[filepath] || '' // Ruby ||=
        }
    })
    for (let parent in parents) {
        apiData.push({
            'filepath': parent,
            'id': null
        })
    }
    apiData.sort(function (a, b) {
        return (a.filepath > b.filepath) ? 1 : ((b.filepath > a.filepath) ? -1 : 0)
    })
    return apiData
}

// Given filepath data with parents, generate a cluster hierarchy
// Also: add up the values of each parent
function clusterify(data, p) {
    const stratify = d3.stratify()
        .parentId(function (d) {
            if (d.filepath === p) return null
            if (d.filepath.indexOf('/') > 0) { // non-root file
                return d.filepath.substring(0, d.filepath.lastIndexOf('/'))
            } else { //root file
                return p
            }
        })
        .id(function (d) {
            return d.filepath
        })
    return stratify(data)
        .sum(d => d.id ? 1 : 0)
        .sort((a, b) => b.height - a.height || b.value - a.value)
}

$.ajax({
    url: "/api/filepaths",
    dataType: 'json',
    success: function (apiData) {
        const currentFilePath = FILE_PATH
        // const parent = currentFile.split("/")[0]
        const parent = currentFilePath.substring(0, currentFilePath.lastIndexOf('/'))

        const isChildOf = (child, parent) => {
            if (child === parent) return false;
            const parentTokens = parent.split('/')
            const childTokens = child.split('/')
            if (childTokens.length < parentTokens) return false
            return parentTokens.every((t, i) => childTokens[i] === t)
        }

        // filter out not needed filepaths
        const reducedData = apiData.filter(d => isChildOf(d.filepath, parent))
        // console.log(reducedData)

        const parentData = parentify(reducedData, parent)
        const root = clusterify(parentData, parent)

        const height = 200 * root.height
        const width = 1000

// selecting the svg to display the pedigree at
        const svg = d3.select("svg")
            .attr('height', height)
            .attr('width', width)

        // switch color helper function
        const color = d3.scaleOrdinal(d3.schemeCategory10)

        // partition helper function
        const partition = d3.partition()
            .size([height, width])
            .padding(1)
            .round(true)

        partition(root)
        // customized and configure each cell
        const cell = svg
            .selectAll(".node")
            .data(root.descendants())
            .enter().append("g")
            .attr("class", d => "node" + (d.children ? " node--internal" : " node--leaf"))
            .attr("transform", d => "translate(" + d.y0 + "," + d.x0 + ")")

        cell.append("rect")
            .attr("id", d => "rect-" + d.data.filepath)
            .attr("width", d => d.y1 - d.y0)
            .attr("height", d => d.x1 - d.x0)
            .filter(d => !d.children)
            .style("fill", d => color(d.data.filepath.split(".").slice(-1)[0]))

        cell.append("text")
            .attr("x", 4)
            .selectAll("tspan")
            .data((d) => d.data.filepath.split("/").slice(-1)[0])
            .enter().append("tspan")
            .attr("y", 13)
            .text(d => d)

        // Put it all together
        $('#loading_map').remove()
    }
})