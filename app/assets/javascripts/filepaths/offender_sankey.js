import $ from 'jquery'
import * as d3 from 'd3'
import _ from 'lodash'
import { ellipsizedFilepath } from '../global/dataToPrettyStrings'
import {howto} from "@d3/example-components"
import {howto} from "@d3/example-components"

export default function OffenderMap(){

  chart = SankeyChart({
    links : readcsv
  }, {
    nodeGroup: d => d.id.split(/\W/)[0],
    nodeAlign,
    linkColor,
    format: (f => d => '${f(d)} TWh')(d3.format(",.1~f")),
    width,
    height : 600
  })
    d3Sankey = require.alias({"d3-array": d3, "d3-shape": d3, "d3-sankey": "d3-sankey@0.12.3/dist/d3-sankey.min.js"})("d3-sankey")

    this.project_id = 0; //project_id 0 is "all" projects
    this.cutoff = 2; // number of fixes we need to actually show this. TODO make this configurable

    //reading in the data
    readcsv = FileAttachement("vhp.csv").csv({typed: true})

    function SankeyChart({
      nodes, // array of node objects
      links, // array of link objects
    },
    {
      format = ",",
      align = "justify",
      nodeID = d => d.id,
      nodeGroup,
      nodeGroups, // array of group objects
      nodeLabel, // given d, text to label the associated rect
      nodeTitle = d => '${d.id}\n${format(d.value)}',
      nodeAlign = align,
      nodeWidth = 15,
      nodePadding = 10,
      nodeLabelPadding = 6,
      nodeStroke = "CurrentColor",
      nodeStrokeWidth,
      nodeStrokeOpacity,
      nodeStrokeLinejoin,
      linkSource = ({source}) => source,
      linkTarget = ({target}) => target,
      linkValue = ({value}) => value,
      linkPath = d3.Sankey.sankeyLinkHorizontal(),
      linkTitle = d => '${d.source.id} â†’ ${d.target.id}\n${format(d.value)}',
      linkColor = "source-target",
      linkStrokeOpacity = 0.5,
      linkMixBlendMode = "multiply",
      colors = d3.schemeTableau10,
      width = 640,
      height = 400,
      marginTop = 5,
      marginRight = 1,
      marginBottom = 5,
      marginLeft = 1,
    } = {}) {
      if (typeof nodeAlign !== "function") nodeAlign = {
        left: d3Sankey.sankeyLeft,
        right: d3Sankey.sankeyRight,
        center: d3Sankey.sankeyCenter,
      }[nodeAlign] ?? d3Sankey.sankeyJustify;

      //computing values??

      const LS = d3.map(links, linkSource).map(intern);
      const LT = d3.map(links, linkTarget).map(intern);
      const LV = d3.map(links, linkValue);
      if (nodes == undefined) nodes = Array.from(d3.union(LS, LT), id => ({id}));

      const N = d3.map(nodes, nodeID).map(intern);
      const G = nodeGroup == null ? null : d3.map(nodes, nodeGroup).map(intern);

      //replacing the input nodes and links with mutable objects for the simulation

      nodes = d3.map(nodes, (_, i) => ({id: N[i]}));
      links = d3.map(links, (_, i) => ({source: LS[i], target: LT[i], value: LV[i]}));

      //ignoring group-based link color option if no groups are specified
      if (!G && ["source", "target", "source-target"].includes(linkColor)) linkColor = "CurrentColor";

      //computing default domains
      if (G && nodeGroups == undefined) nodeGroups = G;

      //constructing the color scales
      const color = nodeGroup == null ? null : d3.scaleOrdinal(nodeGroups, colors);

      //Computing sankey layout

      d3Sankey.sankey()
        .nodeID(({index: i}) => N[i])
        .nodeAlign(nodeAlign)
        .nodeWidth(nodeWidth)
        .nodePadding(nodePadding)
        .extent([[marginLeft, marginTop], [width - marginRight, height - marginBottom]])
        ({nodes, links});

        //computing titles and labels using layout nodes, to access aggregate values.

        if(typeof format !== "function") format = d3.format(format);
        const Tl = nodeLabel == undefined ? N : nodeLabel == null ? null : d3.map(nodes, nodeLabel);
        const Tt = nodeTitle == null ? null : d3.map(nodes, nodeTitle);
        const Lt = linkTitle == null ? null : d3.map(links, linkTitle);

        //unique identifier for clip path to avoid conflixts
        const uid = '0-${Math.random().toString(16).slice(2)}';

        const svg = d3.select("offender-map-svg")
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [0, 0, width, height])
            .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

        const node = svg.append("g")
            .attr("stroke", nodeStroke)
            .attr("stroke-width", nodeStrokeWidth)
            .attr("stroke-opacity", nodeStrokeOpacity)
            .attr("stroke-linejoin", nodeStrokeLinejoin)
          .selectAll("rect")
          .data(nodes)
          .join("rect")
            .attr("x", d => d.x0)
            .attr("y", d => d.y0)
            .attr("height", d => d.y1 - d.y0)
            .attr("width", d => d.x1 - d.x0)

        if (G) node.attr("fill", ({index: i}) => color(G[i]));
        if (Tt) node.append("title").text(({index: i}) => Tt[i]);
      
        const link = svg.append("g")
            .attr("fill", "none")
            .attr("stroke-opacity", linkStrokeOpacity)
          .selectAll("g")
          .data(links)
          .join("g")
            .style("mix-blend-mode", linkMixBlendMode);

        if (linkColor === "source-target") link.append("linearGradient")
            .attr("id", d => '${uid}-link-${d.index}')
            .attr("gradientUnits", "userSpaceOnUse")
            .attr("x1", d => d.source.x1)
            .attr("x2", d => d.target.x0)
            .call(gradient => gradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", ({source: {index: i}}) => color(G[i])))
            .call(gradient => gradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", ({target: {index: i}}) => color(G[i])));
        
        link.append("path")
            .attr("d", linkPath)
            .attr("stroke", linkColor === "source-target" ? ({index: i}) => 'url(#${uid}-link-${i}))'
                : linkColor === "source" ? ({source: {index: i}}) => color(G[i])
                : linkColor === "target" ? ({target: {index: i}}) => color(G[i])
                : linkColor)
            .attr("stroke-width", ({width}) => Math.max(1, width))
            .call(Lt ? path => path.append("title").text(({index: i}) => Lt[i]) : () => {});

        if (Tl) svg.append("g")
            .attr("font-family", "sans-serif")
            .attr("font-size", 10)
          .selectAll("text")
          .data(nodes)
          .join("text")
            .attr("x", d => d.x0 < width / 2 ? d.x1 + nodeLabelPadding : d.x0 - nodeLabelPadding)
            .attr("y", d => (d.y1 + d.y0) / 2)
            .attr("dy", "0.35em")
            .attr("text-anchor", d => d.x0 < width / 2 ? "start" : "end")
            .text(({index: i}) => Tl[i]);
        
        function intern(value) {
          return value !== nul && typeof value === "object" ? value.valueOf() : {value};
        }

        return Object.assign(svg.node(), {scales: {color}});
    }


}