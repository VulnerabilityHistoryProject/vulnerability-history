import $ from "jquery";
import { select, pointer, scaleLinear, scaleSqrt, arc } from "d3";
import * as d3 from "d3";
import _ from "lodash";
import { ellipsizedFilepath } from "../global/dataToPrettyStrings";

const cutoff = 2; // number of fixes we need to actually show this. TODO make this configurable
const max_color = "#F4083E";
const min_color = "#CCCCCC";
const cves_color_max = 15;
const churn_max = 500;
const upvotes_max = 30;
const color_scale = d3.interpolateRgb(min_color, max_color);
const heatColorScale = d3
  .scaleSequential(color_scale)
  .domain([0, cves_color_max]);
const churnColorScale = d3.scaleSequential(color_scale).domain([0, churn_max]);
const upvotesColorScale = d3
  .scaleSequential(color_scale)
  .domain([0, upvotes_max]);

//global variables, not well designed but first step in refactoring
var projectColors = [];
var allProjects = [];
var allOffenders = [];
var pressedKeys = [];
var tooltipRef = null;
var radius = null;
var gVar = null;
var xValue = null;
var yValue = null;
var arcValue = null;
var filePath = null;

//gear variables
var gear_open = false;
var first_select_complete = false;
var color_mode = "project";
var size_mode = "cves";

export default function OffenderMap(offenders, projects) {
  allOffenders = offenders;
  allProjects = projects;
  var project_id = 0; //project_id 0 is "all" projects
  initVisualDiv();
  var svg = initSVG();
  registerHandlers(svg);
  initLegends(svg);
  projectJSONToMap();
  prependProjectName();
  rebuild(project_id, svg);
}

const initSVG = function () {
  const width = 700; //internal coordinates
  const height = 700;
  radius = Math.min(width, height) / 2;
  var svg = select("#offender-map-svg");
  // // svg width and height NOT set for responsiveness here!!
  // // viewBox is the internal coordinate system and then this
  // // scales to fit its container
  addFilepathLink(svg);
  gVar = svg
    .append("g")
    .attr("transform", `translate(${width / 2}, ${height / 2})`);
  addHelpText("Click to zoom", 650, svg);
  addHelpText("Ctrl+Click leaf node to visit", 665, svg);
  addHelpText("Click center to go up", 680, svg);
  addToolTip(svg);

  //Added button listeners.
  document
    .getElementById("expandFilePath")
    .addEventListener("click", expandToolTip);

  return svg;
};

const expandToolTip = function () {
  var href = document.getElementById("hrefId");

  if (href !== null) {
    href.innerHTML = filePath;
  } else {
    document.getElementById("tooltipId").textContent = filePath;
  }
};

// e.g. Chromium's foo/bar.c --> chromium/foo/bar.c
const prependProjectName = function () {
  allOffenders = allOffenders.map(function (f) {
    f.filepath = `${f.subdomain}/${f.filepath}`;
    return f;
  });
};

// Draw the help text at the given y coordinate
const addHelpText = function (str, y, svg) {
  svg
    .append("text")
    .attr("x", 540)
    .attr("y", y)
    .attr("font-size", 15)
    .attr("style", "fill: #aaa")
    .html(str);
};

const addToolTip = function (svg) {
  tooltipRef = svg
    .append("text")
    .attr("x", 0)
    .attr("y", 710)
    .attr("font-size", 11)
    .attr("font-family", "Consolas, 'Liberation Mono', Courier, monospace")
    .attr("style", "fill: #000");
};

const registerHandlers = function (svg) {
  $("select.project-choice").on("change", (e) => {
    var project_id = $("select.project-choice option:selected").attr("value");
    rebuild(project_id, svg);
  });
};

const initLegends = function (svg) {
  initProjectLegend(svg);
  initCVESLegend(svg);
  initUpvotesLegend(svg);
  initChurnLegend(svg);
  initInsertionsLegend(svg);
  initDeletionsLegend(svg);
  initNetChurnLegend(svg);
};

const rebuild = function (project_id, svg) {
  const cluster = rebuildDataHierarchy(project_id);
  rebuildVisualization(cluster, svg);
};

// Convert from the JSON response from the API to a formatted needed for //
// D3's hierarchical clustering.
// 1. Filter out according to project & num_fixes cutoff
// 2. Prepend the project name to the filepath
// 2. Parentify - add parent directories to the data and keep it sorted
// 3. Clusterify - convert to D3's clustered hierarchy data structure,
// 4. Partition - append data structure with layout X's & Y's
const rebuildDataHierarchy = function (project_id) {
  const filtered = allOffenders.filter(
    //accept only filepaths
    (f) =>
      (f.project_id == project_id || project_id == 0) && f.num_fixes >= cutoff
  );
  const cluster = clusterify(parentify(filtered));
  var partition = d3.partition();
  partition(cluster);
  return cluster;
};

const setXValue = function () {
  return scaleLinear().range([0, 2 * Math.PI]);
};

const setYValue = function () {
  return scaleSqrt().range([0, radius]);
};

//due to how the paths are being tweened allot of paths end up with a zero value without being set to 0
const cleanPaths = function (d) {
  //if there are only 1 to 3 compnents of the path string it ends up with a zero value
  if ((arcValue(d).match(/,/g) || []).length > 2) {
    return arcValue(d);
  }

  //"M0,0Z will set the overall path to zero"
  return "M0,0Z";
};

const setArc = function () {
  return arc()
    .startAngle((d) => Math.max(0, Math.min(2 * Math.PI, xValue(d.x0))))
    .endAngle((d) => Math.max(0, Math.min(2 * Math.PI, xValue(d.x1))))
    .innerRadius((d) => Math.max(0, yValue(d.y0)))
    .outerRadius((d) => Math.max(0, yValue(d.y1)));
};

/*
    Given a D3 partition()'d cluster hierarchy, draw stuff partition() computed
    X's and Y's for us, but it's in its own coordinate space AND uses a
    traditional rectangle-based hierarchy. So we need to map those numbers to a
    circular pattern in our own coordinate system. Then do styling with colors
    and other visual fanciness.
    */
const rebuildVisualization = function (cluster, svg) {
  xValue = setXValue();
  yValue = setYValue();

  //from rectangles to divided circles
  arcValue = setArc();

  gVar.selectAll("path").remove(); // remove previous if there
  gVar
    .selectAll("path")
    .data(cluster.descendants())
    .enter()
    .append("path")
    .attr("d", arcValue)
    .style("stroke", "#fff")
    .style("stroke-width", "0.25px")
    .style("fill", (d) => computeColor(d, d.depth))
    .on("click", (event, d) => clicked(event, d, svg))
    .on("mouseover", (event, d) => mouseovered(event, d))
    .attr("transform", "scale(0.05)")
    .transition()
    .attr("transform", "scale(1.1)")
    .duration(200) //ms
    .transition()
    .attr("transform", "scale(1.0)")
    .duration(300); //ms
};

// D3's stratify method needs the parent directories, and sorted
// e.g. filepath: foo/bar/baz.c
//         ---converts too---
//     /
//     /foo
//     /foo/bar
//     /foo/bar/baz.c
// We also need to make sure this is all unique,
// (e.g. there's only one /foo), so we use hashes
const parentify = function (offenderList) {
  const parents = { "/": 0 }; // init with root directory, purple
  offenderList.forEach(function (entry) {
    let filepath = entry.filepath;
    while (filepath.indexOf("/") > 0) {
      filepath = filepath.substring(0, filepath.lastIndexOf("/"));
      parents[filepath] = entry.project_id;
    }
  });
  for (let key in parents) {
    offenderList.push({
      filepath: key,
      id: null, // there is no filepath ID for this, it's a directory!
      num_fixes: null, //init this to null - it'll be updated later
      project_id: parents[key],
    });
  }
  offenderList.sort(function (a, b) {
    // sort these alphabetically
    return a.filepath > b.filepath ? 1 : b.filepath > a.filepath ? -1 : 0;
  });
  return offenderList;
};

// Given filepath data with parents, generate a cluster hierarchy
// Also: add up the values of each parent
const clusterify = function (data) {
  const stratify = d3
    .stratify()
    .parentId(function (d) {
      if (d.filepath == "/") return null;
      if (d.filepath.indexOf("/") > 0) {
        // non-root file
        return d.filepath.substring(0, d.filepath.lastIndexOf("/"));
      } else {
        //root file
        return "/";
      }
    })
    .id(function (d) {
      return d.filepath;
    });
  let root = stratify(data);
  //root.sum((d) => this.resizeMap(d)); // extract and change
  root.sum(function (d) {
    return d.num_fixes;
  });
  return root;
};

// Ctrl+Click means we go to the page, the vulnerabilites table on that page
// Click means we zoom in
const clicked = function (event, d, svg) {
  let macPlatforms = ["Macintosh", "MacIntel", "NacPPC", "Mac68K"];

  const [pointerX, pointerY] = pointer(event);
  if (event.ctrlKey && d.data.slug !== undefined) {
    location.href = `/filepaths/${d.data.slug}#vulnerabilities`;
  }
  //check if Mac OS
  else if (
    macPlatforms.indexOf(navigator.userAgentData.platform) !== -1 &&
    handleMacCommandClick(event, d)
  ) {
    location.href = `/filepaths/${d.data.slug}#vulnerabilities`;
  } else {
    zoom(event, d, svg);
  }
};

//add pressed keys to array
$(document.body).on("keydown", function (event) {
  pressedKeys.push(event.originalEvent.keyCode);
});

//remove pressed keys from array
$(document.body).on("keyup", function (event) {
  var pos = pressedKeys.indexOf(event.originalEvent.keyCode);
  if (pos > 1) {
    pressedKeys.splice(pos, 1);
  }
});

//due to how js works with mac computers detecting command+click is browser dependent
const handleMacCommandClick = function (event, d) {
  // key code matching based on browsers and webkit versions
  const mozillaCommandKeyCode = 224;
  const operaCommandKeyCode = 17;
  const webKitGreaterTan525Left = 91;
  const webKitGreaterTan525Right = 93;

  //check for AppleWebKit and that its version is greater than 525
  if (
    navigator.userAgent.indexOf("AppleWebKit") !== -1 &&
    navigator.userAgent
      .substring(navigator.userAgent.indexOf("AppleWebKit") + 12)
      .split(" ")[0] > 525
  ) {
    //check pressed keys
    if (
      pressedKeys.includes[webKitGreaterTan525Left] ||
      pressedKeys.includes[webKitGreaterTan525Right]
    ) {
      return true;
    }
  }

  //check if Chrome, Safari, or Oprea
  if (
    navigator.userAgent.indexOf("Chrome") !== -1 ||
    navigator.userAgent.indexOf("Safari") ||
    navigator.userAgent.indexOf("OP") !== -1
  ) {
    //check pressed keys
    if (pressedKeys.includes[operaCommandKeyCode]) {
      return "true";
    }
  }
  //check if Firefox
  if (navigator.userAgent.indexOf("Firefox") > -1) {
    //check pressed keys
    if (pressedKeys.includes[mozillaCommandKeyCode]) {
      return "true";
    }
  }

  return false;
};

// Zooming is accomplished by changing how the xy's are interpolated
const zoom = function (event, d, svg) {
  svg
    .transition()
    .duration(650) // ms
    .attrTween("scale", function () {
      //const [pointerX, pointerY] = pointer(event);
      var xd = d3.interpolate(xValue.domain(), [d.x0, d.x1]),
        yd = d3.interpolate(yValue.domain(), [d.y0, 1]),
        yr = d3.interpolate(yValue.range(), [d.y0 ? 20 : 0, radius]);
      return function (t) {
        xValue.domain(xd(t));
        yValue.domain(yd(t)).range(yr(t));
        return arcValue(d);
      };
    })
    .selectAll("path")
    .attrTween("d", function (d) {
      return function () {
        return cleanPaths(d);
      };
    });
};

// Init a lookup table for project colors
const projectJSONToMap = function () {
  const reducer = function (pcMap, jsonRow) {
    pcMap[jsonRow.id] = jsonRow.bg_color;
    return pcMap;
  };
  projectColors = _.reduce(allProjects, reducer, { 0: "#F53663" });
};

// Actually use the lookup table.

const computeColor = function (d, _depth) {
  if (color_mode == "cves") {
    return heatColorScale(d.data.num_cves);
  } else if (color_mode == "upvotes") {
    return upvotesColorScale(d.data.upvotes);
  } else if (color_mode == "churn") {
    return churnColorScale(d.data.churn);
  } else if (color_mode == "insertions") {
    return churnColorScale(d.data.insertions);
  } else if (color_mode == "deletions") {
    return churnColorScale(d.data.deletions);
  } else if (color_mode == "net_churn") {
    return churnColorScale(d.data.net_churn);
  } else {
    return projectColors[d.data.project_id];
  }

  //return projectColors[project_id];
};

const mouseovered = function (event, d) {
  const [pointerX, pointerY] = pointer(event);
  filePath = d.data.filepath;
  var filePathButton = document.getElementById("expandFilePath");

  //display the button if the file path is ellipsized
  if (ellipsizedFilepath(d.data.filepath, 20, 75)[1].indexOf("...") > -1) {
    filePathButton.style.display = "block";
  } else {
    filePathButton.style.display = "none";
  }

  if (d.data.id) {
    //is this a filepath?
    tooltipRef
      .style("visibility", "visible")
      .style("opacity", "100")
      .style("top", pointerY + "px")
      .style("left", pointerX + "px")
      .attr("id", "tooltipId")
      .html(
        `<a href=/filepaths/${d.data.slug} id="hrefId">${
          ellipsizedFilepath(d.data.filepath, 20, 75)[1]
        }</a>`
      );
  } else {
    // or a directory?
    tooltipRef
      .style("visibility", "visible")
      .style("opacity", "100")
      .style("top", pointerY + "px")
      .style("left", pointerX + "px")
      .attr("id", "tooltipId")
      .html(ellipsizedFilepath(d.data.filepath, 20, 75)[1]);
  }
};
//gear code

// is gear select open
//this.gear_open = false;
//this.first_select_complete = false;
const toggleGearSelect = function () {
  // appends select element
  if (!gear_open && !first_select_complete) {
    gear_open = true;
    first_select_complete = true;
    let div = d3.select("#offenders_visual");
    let gearSelect = d3.select("#gearSelect");
    let changer1 = gearSelect.style("display", "none");
    let changer2 = div.append("div").attr("id", "gearMenu");
    let gearMenu = d3.select("#gearMenu");
    let changerColorText = gearMenu
      .append("h6")
      .html("Color Changer")
      .style("position", "absolute")
      .style("top", "7em")
      .style("right", "6.9em")
      .attr("id", "colorChangerText");
    let changer3 = gearMenu
      .append("select")
      .html(
        `
        <option value='project'>Project</option>
        <option value='cves'>Vulnerabilities</option>
        <option value='upvotes'>Upvotes</option>
        <option value='churn'>Fix Churn (Total)</option>
        <option value='insertions'>Fix Churn (Insertions)</option>
        <option value='deletions'>Fix Churn (Deletions)</option>
        <option value='net_churn'>Fix Churn (Net)</option>
      `
      )
      .attr("id", "colorChanger")
      .attr("size", "7")
      .style("width", "145px");
    $("#colorChanger").on("change", (e) => colorChanged(e.target.value));
    let changerSizeText = gearMenu
      .append("h6")
      .html("Size Changer")
      .style("position", "absolute")
      .style("top", "7em")
      .style("right", "-7em")
      .attr("id", "sizeChangerText");
    let changer4 = gearMenu
      .append("select")
      .html(
        `
        <option value='project'>Project</option>
        <option value='cves'>Vulnerabilities</option>
        <option value='upvotes'>Upvotes</option>
        <option value='churn'>Fix Churn (Total)</option>
        <option value='insertions'>Fix Churn (Insertions)</option>
        <option value='deletions'>Fix Churn (Deletions)</option>
        <option value='net_churn'>Fix Churn (Net)</option>
      `
      )
      .attr("id", "sizeChanger")
      .attr("size", "7")
      .style("width", "145px")
      .style("top", "2em")
      .style("right", "-12em");
    $("#sizeChanger").on("change", (e) => sizeChanged(e.target.value));
  }
  // makes select element reappear
  else if (!gear_open && first_select_complete) {
    gear_open = true;
    let gearSelect = d3.select("#gearSelect");
    let changer1 = gearSelect.style("display", "none");
    d3.select("#colorChangerText").style("display", "block");
    d3.select("#colorChanger").style("display", "block");
    $("#colorChanger").on("change", (e) => colorChanged(e.target.value));
    d3.select("#sizeChangerText").style("display", "block");
    d3.select("#sizeChanger").style("display", "block");
    $("#sizeChanger").on("change", (e) => sizeChanged(e.target.value));
  }
};

const initVisualDiv = function () {
  let div = d3.select("#offenders_visual");
  let changer = div
    .append("button")
    .html(
      `
      <i class="vhp-icon-gear"></i>
    `
    )
    .attr("id", "gearSelect")
    .style("position", "absolute")
    .style("top", "7.5em")
    .style("right", "6em")
    .style("font-size", "40px")
    .style("color", "#9E9E9E");
  $("#gearSelect").on("click", (e) => toggleGearSelect());
};

const sizeChanged = function (mode) {
  size_mode = mode;

  d3.select("#colorChanger").style("display", "none");

  d3.select("#colorChangerText").style("display", "none");

  d3.select("#sizeChanger").style("display", "none");

  d3.select("#sizeChangerText").style("display", "none");

  let gearSelect = d3.select("#gearSelect");
  let changer1 = gearSelect.style("display", "block");
  gear_open = false;

  rebuildSlow();
};

const rebuildSlow = function () {
  const cluster = rebuildDataHierarchy();
  rebuildVisualizationSlowly(cluster);
};

/*
  Given a D3 partition()'d cluster hierarchy, draw stuff partition() computed
  X's and Y's for us, but it's in its own coordinate space AND uses a
  traditional rectangle-based hierarchy. So we need to map those numbers to a
  circular pattern in our own coordinate system. Then do styling with colors
  and other visual fanciness.
  */
const rebuildVisualizationSlowly = function (cluster) {
  xValue = setXValue();
  yValue = setYValue();

  arcValue = setArc();

  const colorScale = d3.interpolateRgb("#774b70", "#ce6dbd");
  const cluster_depth = cluster.height;
  const color = d3.scaleSequential(colorScale).domain([0, cluster_depth]);

  gVar.selectAll("path").remove(); // remove previous if there
  gVar
    .selectAll("path")
    .data(cluster.descendants())
    .enter()
    .append("path")
    .attr("d", arcValue)
    .style("stroke", "#fff")
    .style("stroke-width", "0.25px")
    .style("fill", (d) => computeColor(d))
    .on("click", (event, d) => clicked(event, d, svg))
    .on("mouseover", (event, d) => mouseovered(event, d))
    .attr("transform", "scale(0.05)")
    .transition()
    .attr("transform", "scale(1.1)")
    .duration(1000) //ms
    .transition()
    .attr("transform", "scale(1.0)")
    .duration(1000); //ms
};

const initProjectLegend = function (svg) {
  const line_height = 17;
  let y = 700 - 2 * line_height;
  let projGroup = svg.append("g").attr("id", "project-legend");
  allProjects.forEach(function (p) {
    projGroup
      .append("text")
      .attr("x", 0)
      .attr("y", y)
      .attr("font-size", 15)
      .attr("font-weight", "bold")
      .style("fill", p.bg_color)
      .html(p.name);
    y -= line_height;
  });
};

const initCVESLegend = function (svg) {
  svg.append("defs").html(`
      <linearGradient id="CountGradient" x1="0" y1="1" x2="0" y2="0">
        <stop stop-color="${min_color}" offset="0%" />
        <stop stop-color="${max_color}" offset="100%" />
      </linearGradient>
    `);
  let newGroup = svg.append("g").attr("id", "cves-legend");
  newGroup.style("opacity", 0.0);
  newGroup
    .append("text")
    .attr("x", 50)
    .attr("y", 575)
    .style("font-size", 18)
    .style("font-weight", "bold")
    .style("fill", "#8a8a8a")
    .html(`${cves_color_max}+`);
  newGroup
    .append("rect")
    .attr("x", 46)
    .attr("y", 580)
    .attr("width", 30)
    .attr("height", 80)
    .style("fill", "url(#CountGradient)");
  newGroup
    .append("text")
    .attr("x", 55)
    .attr("y", 675)
    .style("font-size", 18)
    .style("font-weight", "bold")
    .style("fill", "#8a8a8a")
    .html("0");
  newGroup
    .append("text")
    .attr("x", 465)
    .attr("y", 88)
    .style("font-size", 15)
    .style("fill", "#8a8a8a")
    .html("Number of vulnerabilities fixed");
};

const initUpvotesLegend = function (svg) {
  svg.append("defs").html(`
      <linearGradient id="CountGradient" x1="0" y1="1" x2="0" y2="0">
        <stop stop-color="${min_color}" offset="0%" />
        <stop stop-color="${max_color}" offset="100%" />
      </linearGradient>
    `);
  let newGroup = svg.append("g").attr("id", "upvotes-legend");
  newGroup.style("opacity", 0.0);
  newGroup
    .append("text")
    .attr("x", 50)
    .attr("y", 575)
    .style("font-size", 18)
    .style("font-weight", "bold")
    .style("fill", "#8a8a8a")
    .html(`${upvotes_max}+`);
  newGroup
    .append("rect")
    .attr("x", 46)
    .attr("y", 580)
    .attr("width", 30)
    .attr("height", 80)
    .style("fill", "url(#CountGradient)");
  newGroup
    .append("text")
    .attr("x", 55)
    .attr("y", 675)
    .style("font-size", 18)
    .style("font-weight", "bold")
    .style("fill", "#8a8a8a")
    .html("0");
  newGroup
    .append("text")
    .attr("x", 500)
    .attr("y", 85)
    .style("font-size", 15)
    .style("fill", "#8a8a8a")
    .html("Number of user upvotes");
};

const initChurnLegend = function (svg) {
  svg.append("defs").html(`
      <linearGradient id="CountGradient" x1="0" y1="1" x2="0" y2="0">
        <stop stop-color="${min_color}" offset="0%" />
        <stop stop-color="${max_color}" offset="100%" />
      </linearGradient>
    `);
  let newGroup = svg.append("g").attr("id", "churn-legend");
  newGroup.style("opacity", 0.0);
  newGroup
    .append("text")
    .attr("x", 50)
    .attr("y", 575)
    .style("font-size", 18)
    .style("font-weight", "bold")
    .style("fill", "#8a8a8a")
    .html(`${churn_max}+`);
  newGroup
    .append("rect")
    .attr("x", 46)
    .attr("y", 580)
    .attr("width", 30)
    .attr("height", 80)
    .style("fill", "url(#CountGradient)");
  newGroup
    .append("text")
    .attr("x", 55)
    .attr("y", 675)
    .style("font-size", 18)
    .style("font-weight", "bold")
    .style("fill", "#8a8a8a")
    .html("0");
  newGroup
    .append("text")
    .attr("x", 500)
    .attr("y", 85)
    .style("font-size", 15)
    .style("fill", "#8a8a8a")
    .html("Number of total churns");
  newGroup
    .append("text")
    .attr("x", 500)
    .attr("y", 100)
    .style("font-size", 15)
    .style("fill", "#8a8a8a")
    .html("(Insertions + Deletions)");
};

const initInsertionsLegend = function (svg) {
  svg.append("defs").html(`
      <linearGradient id="CountGradient" x1="0" y1="1" x2="0" y2="0">
        <stop stop-color="${min_color}" offset="0%" />
        <stop stop-color="${max_color}" offset="100%" />
      </linearGradient>
    `);
  let newGroup = svg.append("g").attr("id", "insertions-legend");
  newGroup.style("opacity", 0.0);
  newGroup
    .append("text")
    .attr("x", 50)
    .attr("y", 575)
    .style("font-size", 18)
    .style("font-weight", "bold")
    .style("fill", "#8a8a8a")
    .html(`${churn_max}+`);
  newGroup
    .append("rect")
    .attr("x", 46)
    .attr("y", 580)
    .attr("width", 30)
    .attr("height", 80)
    .style("fill", "url(#CountGradient)");
  newGroup
    .append("text")
    .attr("x", 55)
    .attr("y", 675)
    .style("font-size", 18)
    .style("font-weight", "bold")
    .style("fill", "#8a8a8a")
    .html("0");
  newGroup
    .append("text")
    .attr("x", 500)
    .attr("y", 88)
    .style("font-size", 15)
    .style("fill", "#8a8a8a")
    .html("Number of insertions");
};

const initDeletionsLegend = function (svg) {
  svg.append("defs").html(`
      <linearGradient id="CountGradient" x1="0" y1="1" x2="0" y2="0">
        <stop stop-color="${min_color}" offset="0%" />
        <stop stop-color="${max_color}" offset="100%" />
      </linearGradient>
    `);
  let newGroup = svg.append("g").attr("id", "deletions-legend");
  newGroup.style("opacity", 0.0);
  newGroup
    .append("text")
    .attr("x", 50)
    .attr("y", 575)
    .style("font-size", 18)
    .style("font-weight", "bold")
    .style("fill", "#8a8a8a")
    .html(`${churn_max}+`);
  newGroup
    .append("rect")
    .attr("x", 46)
    .attr("y", 580)
    .attr("width", 30)
    .attr("height", 80)
    .style("fill", "url(#CountGradient)");
  newGroup
    .append("text")
    .attr("x", 55)
    .attr("y", 675)
    .style("font-size", 18)
    .style("font-weight", "bold")
    .style("fill", "#8a8a8a")
    .html("0");
  newGroup
    .append("text")
    .attr("x", 500)
    .attr("y", 88)
    .style("font-size", 15)
    .style("fill", "#8a8a8a")
    .html("Number of deletions");
};

const initNetChurnLegend = function (svg) {
  svg.append("defs").html(`
      <linearGradient id="CountGradient" x1="0" y1="1" x2="0" y2="0">
        <stop stop-color="${min_color}" offset="0%" />
        <stop stop-color="${max_color}" offset="100%" />
      </linearGradient>
    `);
  let newGroup = svg.append("g").attr("id", "net_churn-legend");
  newGroup.style("opacity", 0.0);
  newGroup
    .append("text")
    .attr("x", 50)
    .attr("y", 575)
    .style("font-size", 18)
    .style("font-weight", "bold")
    .style("fill", "#8a8a8a")
    .html(`${churn_max}+`);
  newGroup
    .append("rect")
    .attr("x", 46)
    .attr("y", 580)
    .attr("width", 30)
    .attr("height", 80)
    .style("fill", "url(#CountGradient)");
  newGroup
    .append("text")
    .attr("x", 55)
    .attr("y", 675)
    .style("font-size", 18)
    .style("font-weight", "bold")
    .style("fill", "#8a8a8a")
    .html("0");
  newGroup
    .append("text")
    .attr("x", 500)
    .attr("y", 85)
    .style("font-size", 15)
    .style("fill", "#8a8a8a")
    .html("Number of net churns");
  newGroup
    .append("text")
    .attr("x", 500)
    .attr("y", 100)
    .style("font-size", 15)
    .style("fill", "#8a8a8a")
    .html("(Insertions - Deletions)");
};

//still needs work to get functional
const resizeMap = function (data) {
  if (size_mode == "cves") {
    return data.num_cves;
  } else if (size_mode == "upvotes") {
    return data.upvotes;
  } else if (size_mode == "churn") {
    return data.churn;
  } else if (size_mode == "insertions") {
    return data.insertions;
  } else if (size_mode == "deletions") {
    return data.deletions;
  } else if (size_mode == "net_churn") {
    return data.net_churn;
  } else {
    return data.num_cves;
  }
  /*
  Given a D3 partition()'d cluster hierarchy, draw stuff partition() computed
  X's and Y's for us, but it's in its own coordinate space AND uses a
  traditional rectangle-based hierarchy. So we need to map those numbers to a
  circular pattern in our own coordinate system. Then do styling with colors
  and other visual fanciness.
  
  this.rebuildVisualization = function (cluster) {
    this.x = scaleLinear().range([0, 2 * Math.PI]);
    this.y = scaleSqrt().range([0, this.radius]);

    //from rectangles to divided circles
    this.arc = arc()
      .startAngle((d) => Math.max(0, Math.min(2 * Math.PI, this.x(d.x0))))
      .endAngle((d) => Math.max(0, Math.min(2 * Math.PI, this.x(d.x1))))
      .innerRadius((d) => Math.max(0, this.y(d.y0)))
      .outerRadius((d) => Math.max(0, this.y(d.y1)));

    const colorScale = d3.interpolateRgb("#774b70", "#ce6dbd");
    const cluster_depth = cluster.height;
    const color = d3.scaleSequential(colorScale).domain([0, cluster_depth]);

    this.g.selectAll("path").remove(); // remove previous if there
    this.g
      .selectAll("path")
      .data(cluster.descendants())
      .enter()
      .append("path")
      .attr("d", this.arc)
      .style("stroke", "#fff")
      .style("stroke-width", "0.25px")
      .style("fill", (d) => this.computeColor(d.data.project_id, d.depth))
      .on("click", (event, d) => this.clicked(event, d, this))
      .on("mouseover", (event, d) => this.mouseovered(event, d, this))
      .attr("transform", "scale(0.05)")
      .transition()
      .attr("transform", "scale(1.1)")
      .duration(200) //ms
      .transition()
      .attr("transform", "scale(1.0)")
      .duration(300); //ms
  }; */
};

const addFilepathLink = function (svg) {
  svg
    .append("text")
    .attr("x", 0)
    .attr("y", 15)
    .attr("font-size", 14)
    .attr("font-family", "Consolas, 'Liberation Mono', Courier, monospace")
    .attr("style", "fill: #000");
  svg
    .append("text")
    .attr("x", 0)
    .attr("y", 30)
    .attr("font-size", 14)
    .attr("font-family", "Consolas, 'Liberation Mono', Courier, monospace")
    .attr("style", "fill: #000");
};

const colorChanged = function (mode) {
  color_mode = mode;

  gVar
    .selectAll("path")
    .transition()
    .style("fill", (d) => computeColor(d))
    .duration(1200);

  d3.select("#colorChanger").style("display", "none");

  d3.select("#colorChangerText").style("display", "none");

  d3.select("#sizeChanger").style("display", "none");

  d3.select("#sizeChangerText").style("display", "none");

  let gearSelect = d3.select("#gearSelect");
  let changer1 = gearSelect.style("display", "block");
  gear_open = false;

  d3.select("#project-legend")
    .transition()
    .style("opacity", mode == "project" ? 1.0 : 0.0)
    .duration(1200);

  d3.select("#cves-legend")
    .transition()
    .style("opacity", mode == "cves" ? 1.0 : 0.0)
    .duration(1200);

  d3.select("#upvotes-legend")
    .transition()
    .style("opacity", mode == "upvotes" ? 1.0 : 0.0)
    .duration(1200);

  d3.select("#churn-legend")
    .transition()
    .style("opacity", mode == "churn" ? 1.0 : 0.0)
    .duration(1200);

  d3.select("#insertions-legend")
    .transition()
    .style("opacity", mode == "insertions" ? 1.0 : 0.0)
    .duration(1200);

  d3.select("#deletions-legend")
    .transition()
    .style("opacity", mode == "deletions" ? 1.0 : 0.0)
    .duration(1200);

  d3.select("#net_churn-legend")
    .transition()
    .style("opacity", mode == "net_churn" ? 1.0 : 0.0)
    .duration(1200);
};
