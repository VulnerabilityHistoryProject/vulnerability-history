
function OffenderMap(offenders){
    this.offenders = offenders;
    this.project_id = 0; //project_id 0 is "all" projects

    this.init = function() {
      this.initSVG();
      this.initTooltip();
      this.registerHandlers();
      this.rebuild();
    }

    this.initSVG = function(){
      width = 700
      height = 700
      this.radius = Math.min(width, height) / 2;
      this.svg = d3.select("#offenders_map")
                  .append("svg:svg")
                  // svg width and height NOT set for responsiveness here!!
                  // viewBox is the internal coordinate system and then this
                  // scales to fit its container
                  .attr("viewBox", `0 0 ${width} ${height}`)
                  .attr("preserveAspectRatio", "xMidYMid meet")
      this.g = this.svg.append('g')
          .attr('transform', `translate(${width / 2}, ${height / 2 })`);
    }

    this.initTooltip = function(){
        this.tooltip = d3.select("#offenders_map")
            .append("div")
            .style("position", "absolute")
            .style("visibility", "hidden")
            .style("background", "#eee")
            .style("color", "#333")
            .style("font-size", "12px")
            .style("text-align", "center")
            .style("padding", "10px");
    }

    this.registerHandlers = function() {
      $('select.project-choice').change((e) => {
        this.project_id = $("select.project-choice option:selected")
                             .attr('value');
        // project_id = e.target.dataset['project'];
        this.rebuild();
      });
    }

    this.rebuild = function() {
      cluster = this.rebuildDataHierarchy();
      this.rebuildVisualization(cluster);
    }

    // Convert from the JSON response from the API to a formatted needed for //
    // D3's hierarchical clustering.
    // 1. Filter out according to project, if necessary
    // 2. Parentify - add parent directories to the data and keep it sorted
    // 3. Clusterify - convert to D3's clustered hierarchy data structure,
    // 4. Partition - append data structure with layout X's & Y's
    this.rebuildDataHierarchy = function(){
      filtered = this.offenders.filter(
        f => (f.project_id == this.project_id || this.project_id == 0)
      );
      cluster = this.clusterify(this.parentify(filtered));
      var partition = d3.partition();
      partition(cluster);
      return cluster
    }

    /*
    Given a D3 partition()'d cluster hierarchy, draw stuff partition() computed
    X's and Y's for us, but it's in its own coordinate space AND uses a
    traditional rectangle-based hierarchy. So we need to map those numbers to a
    circular pattern in our own coordinate system. Then do styling with colors
    and other visual fanciness.
    */
    this.rebuildVisualization = function(cluster) {
      this.x = d3.scaleLinear().range([0, 2 * Math.PI]);
      this.y = d3.scaleSqrt().range([0, this.radius]);

      this.arc = d3.arc() //from rectangles to divided circles
        .startAngle(d => Math.max(0, Math.min(2 * Math.PI, this.x(d.x0))))
        .endAngle(d => Math.max(0, Math.min(2 * Math.PI, this.x(d.x1))))
        .innerRadius(d => Math.max(0, this.y(d.y0)))
        .outerRadius(d => Math.max(0, this.y(d.y1)));

      colorScale = d3.interpolateRgb('#774b70','#ce6dbd')
      cluster_depth = cluster.height;
      color = d3.scaleSequential(colorScale).domain([0,cluster_depth]);
      this.g.selectAll('path').remove(); // remove previous if there
      this.g.selectAll('path')
        .data(cluster.descendants())
        .enter().append('path')
        .attr("d", this.arc)
        .style('stroke', '#de9ed6')
        .style('stroke-width', '0.25px')
        .style("fill", d => color(d.depth))
        .on("click", d => this.clicked(d, this))
        .on("mouseover", d => this.mouseovered(d, this))
        .on("mouseout", d => this.mouseoutof(d, this))
        .attr("transform", "scale(0.05)")
        .transition().attr("transform", "scale(1.1)").duration(200) //ms
        .transition().attr("transform", "scale(1.0)").duration(300) //ms
        ;
    }

    // D3's stratify method needs the parent directories, and sorted
    // e.g. filepath: foo/bar/baz.c
    //         ---converts too---
    //     /
    //     /foo
    //     /foo/bar
    //     /foo/bar/baz.c
    // We also need to make sure this is all unique,
    // (e.g. there's only one /foo), so we use hashes
    this.parentify = function(offenderList) {
      parents = { '/' : ''}; // init with root directory
      offenderList.forEach(function(entry) {
        filepath = entry.filepath;
        while(filepath.indexOf('/') > 0) {
          filepath = filepath.substring(0, filepath.lastIndexOf('/'));
          parents[filepath] = parents[filepath] || ''; // Ruby ||=
        }
      });
      for(parent in parents) {
        offenderList.push({
          'filepath' : parent,
          'id' : null, // there is no filepath ID for this, it's a directory!
          'num_fixes' : null
        });
      }
      offenderList.sort(function(a,b){ // sort these alphabetically
        return (a.filepath > b.filepath) ? 1 :
                ((b.filepath > a.filepath) ? -1 : 0);
      });
      return offenderList;
    }

    // Given filepath data with parents, generate a cluster hierarchy
    // Also: add up the values of each parent
    this.clusterify = function(data){
      stratify = d3
        .stratify()
        .parentId(function (d) {
          if(d.filepath == '/') return null;
          if(d.filepath.indexOf('/') > 0) { // non-root file
            return d.filepath.substring(0, d.filepath.lastIndexOf('/'));
          } else { //root file
            return '/';
          }
        })
        .id(function (d) {
          return d.filepath;
        });
      let root = stratify(data);
      root.sum(function(d) { return d.num_fixes });
      return root;
    }

    // When we click on a particular path, we zoom in
    this.clicked = function(d, map) {
      map.svg.transition()
        .duration(750) // ms
        .tween("scale", function() {
          var xd = d3.interpolate(map.x.domain(), [d.x0, d.x1]),
              yd = d3.interpolate(map.y.domain(), [d.y0, 1]),
              yr = d3.interpolate(map.y.range(), [d.y0 ? 20 : 0, map.radius]);
          return function(t) { map.x.domain(xd(t)); map.y.domain(yd(t)).range(yr(t)); };
        })
        .selectAll("path")
        .attrTween("d", function(d) { return function() { return map.arc(d); }; });
    }

    this.mouseovered = function(d, self){
      if(d.data.id) { //is this a filepath?
          self.tooltip
              .style("visibility", "visible")
              .html(`<a href=/filepaths/${d.data.slug}>${d.data.filepath}</a>`)
                  // d3.select("#offenders_path")
                  //     .html(`<a href=/filepaths/${d.data.slug}>${d.data.filepath}</a>`));
      } else {  // or a directory?
          self.tooltip
              .style("visibility", "visible")
              .html(
                  d3.select("#offenders_path")
                      .html(d.data.filepath));
      }
    }

    this.mouseoutof = function(d, self){
        self.tooltip
            .style("visibility", "hidden");
    }

}
