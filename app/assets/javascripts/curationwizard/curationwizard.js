import $ from "jquery";
import Toastify from "toastify-js";
import "toastify-js/src/toastify";
const { CweManager } = require("cwe-sdk");
import "select2/dist/js/select2";
import { vhpMarkdown } from "../global/vhpMarkdown";

const parentFields = [];
const childFields = [];
let globalErrors = [];
let currentCVE = null;
function resetProgress() {
  clearProgress();
  window.location.reload();
}
function clearProgress() {
  localStorage.removeItem("VHPWizardStatus");
  console.log("Status Cleared");
}

function loadProgress() {
  let wizardStatus = localStorage.getItem("VHPWizardStatus");
  let wizardStatusArr = new Array();
  try {
    wizardStatusArr = JSON.parse(wizardStatus);
    if (wizardStatusArr != null) {
      //console.log("Successfully Loaded Curation Status", wizardStatusArr);
      populateYMLField(wizardStatusArr);
      wizardStatusArr.forEach((q)=>{
        if (q.fieldName === 'CVE') {
          currentCVE = q.fieldVal;
        }
      })
    } else {
      //console.log("Curation Status is empty. Start Fresh.");
      wizardStatusArr = [];
    }
  } catch (e) {
    clearProgress();
    alert(e); // error in the above string (in this case, yes)!
  }

  return wizardStatusArr;
}
function isValueValid(type, fieldName, fieldValue) {
  console.log(
    "attempt to validate " + fieldName + " " + fieldValue + " as " + type
  );
  const fieldLabel = getLabelFromName(fieldName);

  let errorMessage;

  switch (type) {
    case "input":
    case "textarea":
    case "string":
      if (typeof fieldValue !== "string") {
        errorMessage = "value for " + fieldLabel + " must be a string";
        globalErrors.push(errorMessage);
        //return false;
      }
      break;
    case "boolean":
      if (typeof fieldValue !== "boolean") {
        errorMessage = "value for " + fieldLabel + " must be a bool";
        globalErrors.push(errorMessage);
        //return false;
      }
      break;
    case "number":
      if (isNaN(fieldValue)) {
        errorMessage = "value for " + fieldLabel + " must be a number";
        globalErrors.push(errorMessage);
        //return false;
      }
      break;
    case "url":
      try {
        let urlToCheck = new URL(fieldValue);
      } catch (e) {
        if (e instanceof TypeError) {
          errorMessage = "value for " + fieldLabel + " must be a valid URL";
          globalErrors.push(errorMessage);
          //return false;
        } else {
          throw e;
        }
      }
      break;
    case "cve":
      const regex = new RegExp(/^CVE-\d{4}-\d{4,}$/);
      // Don't create entry if not valid format
      if (!regex.test(fieldValue)) {
        errorMessage = "value for " + fieldLabel + " must be a valid CVE";
        globalErrors.push(errorMessage);
      }
    default:
      console.log(
        "Field Was not validated due to type " +
          type +
          " not being defined, pass it for now."
      );
      return true;
  }
  if (globalErrors.length > 0) {
    console.log(
      fieldName +
        " was validated as " +
        type +
        " with value " +
        fieldValue +
        " and failed."
    );
    return false;
  }
  return true;
}
function getCurrentProject() {
  return document.querySelector("body").dataset.project;
}
function getLabelFromName(fieldName) {
  const project = getCurrentProject();
  const projectQuestions = JSON.parse(
    localStorage.getItem("questions-" + project)
  );
  let currentQuestion = projectQuestions.filter((q) => q.key === fieldName)[0];

  return currentQuestion.label;
}
function getConfigFromName(fieldName) {
  const project = getCurrentProject();
  const projectQuestions = JSON.parse(
    localStorage.getItem("questions-" + project)
  );
  let currentQuestion = projectQuestions.filter((q) => q.key === fieldName)[0];

  return currentQuestion;
}
function checkForSavedAnswer(fieldName) {
  const currentProgress = loadProgress();
  const project = getCurrentProject();
  const projectQuestions = JSON.parse(
    localStorage.getItem("questions-" + project)
  );
  let currentQuestion = projectQuestions.filter((q) => q.key == fieldName);

  let fieldValue = "";
  if (currentQuestion[0].type == "repeater") {
    fieldValue = [];
    fieldValue.push("");
  }
  if (currentQuestion[0].key == fieldName) {
    currentProgress.filter(function (savedQuestion) {
      if (savedQuestion.fieldName === fieldName) {
        fieldValue = savedQuestion.fieldVal;
        //console.log("Saved value for " + fieldName + " is " + fieldValue);
      }
    });
  }
  return fieldValue;
}
function populateYMLField(progress) {
  const yamlField = document.getElementById("YAMLOutput");
  yamlField.value = "";
  progress.forEach(function (savedQuestion) {
    yamlField.value +=
      savedQuestion.fieldName +
      ": " +
      JSON.stringify(savedQuestion.fieldVal) +
      "\r\n";
  });
}
function saveProgress(fieldName, fieldVal) {
  //alert(JSON.stringify(globalErrors));
  console.log("Saving " + fieldName, fieldVal);
  const project = getCurrentProject();
  let currentProgress = loadProgress();
  let questionDataToSave = { fieldName: fieldName, fieldVal: fieldVal };

  currentProgress.forEach(function (savedQuestion, index) {
    if (fieldName === savedQuestion.fieldName) {
      currentProgress[index].fieldVal = questionDataToSave.fieldVal;
      questionDataToSave = null;
    }
  });

  if (currentProgress == null) {
    try {
      var o = JSON.parse(currentProgress);
      if (o && typeof o === "object") {
        currentProgress = o;
      }
    } catch (e) {
      console.log("Improper Format, dropping progress");
      clearProgress();
      currentProgress = [];
    }
  }
  if (questionDataToSave) {
    currentProgress.push(questionDataToSave);
  }

  let newProgress = currentProgress;

  //console.log(newProgress);
  localStorage.setItem("VHPWizardStatus", JSON.stringify(newProgress));

  //console.log("New Progress: " + localStorage.getItem("VHPWizardStatus"));

  populateYMLField(currentProgress);

  Toastify({
    text: fieldName + " added to YAML.",
    duration: 3000,
    close: true,
    gravity: "top",
    position: "right",
    stopOnFocus: true,
    style: {
      background: "linear-gradient(to right, #00b09b, #96c93d)",
    },
    onClick: function () {
      $("#open-yaml").foundation(
        "open",
        event,
        $("button").data("toggle", "offCanvasYaml")
      );
    },
  }).showToast();
  CheckForChildrenToSave(fieldName);

  if (globalErrors.length == 0) {
    const projectQuestions = JSON.parse(
      localStorage.getItem("questions-" + project)
    );
    buildQuestion(projectQuestions, fieldName);
  } else {
    alert(globalErrors.join("\r\n"));
  }
}

//Notes storage
const curationNotesKey = "curation-notes";
const notesInput = document.getElementById("Notes");
if (notesInput) {
  const notesStorage = localStorage.getItem(curationNotesKey)
  if (notesStorage) {
    notesInput.value = notesStorage;
  }
  notesInput.addEventListener("keydown", (e)=>{
    localStorage.setItem(curationNotesKey, e.target.value);
  })
}
const clearNotes = document.getElementById("clear-notes");
if (clearNotes) {
  clearNotes.addEventListener("click", ()=>{
    notesInput.value = "";
    localStorage.removeItem(curationNotesKey);
  })
}

async function loadQuestions(project) {
  try {
    var questionsToLoad = await fetch(
      "curationwizard/questions?project=" + project
    )
      .then((response) => response.json())
      .then((data) => {
        localStorage.setItem("questions-" + project, JSON.stringify(data));

        data.forEach((q) => {
          if (!q.parentField) {
            parentFields.push(q);
          } else {
            let childField = {
              parentName: q.parentField,
              config: q,
            };
            childFields.push(childField);
          }
        });
        document.querySelector("body").dataset.project = project;
        buildQuestion(data);
        loadProgress(project);
      });
  } catch (error) {
    console.log(error);
  }
}

function saveQuestion(q, questionElement) {
  const project = getCurrentProject();
  const currentProgress = loadProgress();
  let fieldType = q.type;
  //some fields need special validation... set that here.
  let validationType = q.validationType ? q.validationType : q.type;
  let fieldName;
  let fieldVal;

  currentProgress.filter(function (savedQuestion) {
    if (savedQuestion.fieldName === q.key) {
      //console.log(savedQuestion);
    }
  });
  //console.log("Get Value for field name: " + q.key);
  switch (fieldType) {
    case "input":
    case "textarea":
      fieldName = questionElement.querySelector(
        "[data-fieldname='" + q.key + "']"
      ).dataset.fieldname;
      fieldVal = questionElement.querySelector(
        "[data-fieldname='" + q.key + "']"
      ).value;
      break;
    case "date":
      fieldName = questionElement.querySelector(
        "[data-fieldname='" + q.key + "']"
      ).dataset.fieldname;
      fieldVal = questionElement.querySelector(
        "[data-fieldname='" + q.key + "']"
      ).value;
      break;
    case "select":
    case "cwe-selector":
    case "cve-selector":
      fieldName = questionElement.querySelector("select").dataset.fieldname;
      fieldVal = questionElement.querySelector("select").value;
      if (fieldVal === "") {
        fieldVal = [];
      }
      break;
    case "json":
      fieldName = questionElement.querySelector(
        "[data-fieldname='" + q.key + "']"
      ).dataset.fieldname;
      fieldVal = parseField.json(fieldName);
      break;
    case "wysiwyg":
      fieldName = $(this).children("textarea").dataset.fieldname;
      fieldVal = wysiwygEditors.find((j) => j.id === $(module).data("uuid"))
        .editor.value;
      break;
    case "checkbox":
      fieldName = questionElement.querySelector(
        "[data-fieldname='" + q.key + "']"
      ).dataset.fieldname;
      fieldVal = parseField.checkbox(fieldName);
      break;
    case "radio":
      fieldName = $(this).find("input[type=radio]").dataset.fieldname;
      fieldVal = parseField.radio(fieldName);
      break;
    case "repeater":
      fieldName = questionElement.querySelector(
        "[data-fieldtype='repeater'] [data-fieldname]"
      ).dataset.fieldname;

      console.log("attempt to parse repeater: " + fieldName);
      fieldVal = parseField.repeater(fieldName);
      break;
  }
  if (
    q.required === true &&
    (typeof fieldVal === "undefined" || fieldVal == "")
  ) {
    alert("Field Is Required");
    return;
  }

  //Repeaters are validated separately. don't pass them in here, just save already validated values.
  if (fieldType != "repeater") {
    saveProgress(fieldName, fieldVal);
  } else {
    if (
      isValueValid(validationType, fieldName, fieldVal) &&
      fieldType != "repeater"
    ) {
      saveProgress(fieldName, fieldVal);
    }
  }
}
function getChildFields(fieldName) {
  //console.log("Checking For Children of " + fieldName + " to use....");
  var objChildFields = childFields;
  var childOfParent = objChildFields.filter(function (childField) {
    return childField.parentName == fieldName;
  });
  return childOfParent;
}
function CheckForChildrenToSave(fieldName) {
  //console.log("Checking For Children of " + fieldName + " to save....");
  var objChildFields = childFields;
  var childOfParent = objChildFields.filter(function (childField) {
    return childField.parentName === fieldName;
  });
  if (childOfParent.length > 0) {
    for (const key in childOfParent) {
      if (childOfParent.hasOwnProperty(key)) {
        let childConfig = childOfParent[key].config;
        let questionElement = document.querySelector(".question");
        saveQuestion(childConfig, questionElement);
      }
    }
  } else {
    //console.log("Children Not Found");
    //return false;
  }
}
function CheckForChildrenToBuild(fieldName) {
  //console.log("Checking For Children of " + fieldName + "....");
  let childOfParent = getChildFields(fieldName);
  let childFieldHTML = "";
  if (childOfParent.length > 0) {
    if (childOfParent[0].parentName === fieldName) {
      childFieldHTML +=
        '<div class="sub-fields" data-parent="' + fieldName + '">';
      for (const key in childOfParent) {
        if (childOfParent.hasOwnProperty(key)) {
          let childConfig = childOfParent[key].config;

          let fieldValue = checkForSavedAnswer(childConfig.key);
          //console.log("Child Field Config", childConfig);
          childFieldHTML +=
            '<div class="sub-field option-field" data-accepted-values="' +
            childConfig.acceptedValues +
            '" data-operator="' +
            childConfig.comparisonType.toUpperCase() +
            '" data-fieldtype="' +
            childConfig.type +
            '">';
          childFieldHTML += buildQuestionFromConfig(
            childConfig,
            "",
            fieldValue
          );
          childFieldHTML += "</div>";
        }
      }
      childFieldHTML += "</div>";
    }
    return childFieldHTML;
  } else {
    console.log("Children Not Found");
    return "";
  }
}
function buildRepeater(repeaterType = "input", questionElement, value = "") {
  if (repeaterType == "date") {
    repeaterType = "input";
  }
  let answers = questionElement.querySelectorAll(repeaterType);
  let repeatedFields = questionElement.querySelectorAll(".repeater-entry");

  let lastAnswer = answers[answers.length - 1];
  let lastRepeater = repeatedFields[repeatedFields.length - 1];
  let wrap = document.createElement("div");
  let removeButton = document.createElement("button");
  wrap.classList.add("repeater-entry");
  removeButton.classList.add("button");
  removeButton.classList.add("remove-entry");
  removeButton.innerText = "X";

  let entryLimit =
    questionElement.querySelectorAll(".addRepeater")[0].dataset.limit;
  let existingEntries = repeatedFields.length + 1;

  if (existingEntries < entryLimit) {
    let newField = lastAnswer.cloneNode(false);
    newField.value = value;
    wrap.appendChild(newField);
    wrap.appendChild(removeButton);
    if (repeatedFields.length > 0) {
      lastRepeater.after(wrap);
    } else {
      lastAnswer.after(wrap);
    }
  }

  removeButton.addEventListener(
    "click",
    function () {
      this.closest(".repeater-entry").remove();
    },
    false
  );
}
function buildQuestionFromConfig(q, fieldHTML = "") {
  let numericValidation = "";
  let isRequired = q.required === true ? "required " : " ";
  let repeaterEntryLimit = q.entryLimit ? q.entryLimit : 3;
  let value = checkForSavedAnswer(q.key);
  //console.log("Building field " + q.key, value);
  if (currentCVE) {
    fieldHTML += `<div style="text-align: right;">${currentCVE}</div>`;
  }
  
  switch (q.type) {
    case "string":
    case "input":
    case "number":
      fieldHTML +=
        "<label for='" +
        q.label.toString() +
        "'>" +
        q.label.toString() +
        (q.tooltipText != null
          ? '<i class="fa fa-question-circle" data-toggle="tooltip" data-position="right" title="' +
            q.tooltipText +
            '"></i>'
          : "") +
        '</label><input data-fieldname="' +
        q.key.toString() +
        '" ' +
        numericValidation +
        +isRequired +
        ' type="text" value="' +
        value +
        '" />';
      break;
    case "repeater":
      let repeaterType = q.repeaterType;
      fieldHTML +=
        "<label for='" +
        q.label.toString() +
        "'>" +
        q.label.toString() +
        (q.tooltipText != null
          ? '<i class="fa fa-question-circle" data-toggle="tooltip" data-position="right" title="' +
            q.tooltipText +
            '"></i>'
          : "") +
        "</label>";
      switch (repeaterType) {
        case "input":
          fieldHTML +=
            '<input data-fieldname="' +
            q.key.toString() +
            '" ' +
            numericValidation +
            isRequired +
            ' type="text" value="' +
            value +
            '" />';
          break;
        case "textarea":
          fieldHTML +=
            '<textarea data-fieldname="' +
            q.key.toString() +
            '" ' +
            isRequired +
            '">' +
            value +
            "</textarea>";
          break;
        case "date":
          fieldHTML +=
            '<input data-fieldname="' +
            q.key.toString() +
            '" ' +
            isRequired +
            ' type="date" value="' +
            value +
            '" />';
          break;
      }
      fieldHTML +=
        '<div class="clearfix"><button class="button float-right addRepeater" data-limit="' +
        repeaterEntryLimit +
        '">+ Add Entry</button></div>';
      break;
    case "date":
      fieldHTML +=
        "<label for='" +
        q.label.toString() +
        "'>" +
        q.label.toString() +
        (q.tooltipText != null
          ? '<i class="fa fa-question-circle" data-toggle="tooltip" data-position="right" title="' +
            q.tooltipText +
            '"></i>'
          : "") +
        '</label><input data-fieldname="' +
        q.key.toString() +
        '"' +
        isRequired +
        'type="date" value="' +
        value +
        '" />';
      break;

    case "json":
      fieldHTML +=
        "<label>" +
        q.label.toString() +
        " (JSON)" +
        (q.tooltipText != null
          ? '<i class="fa fa-question-circle" data-toggle="tooltip" data-position="right" title="' +
            q.tooltipText +
            '"></i>'
          : "") +
        "</label><textarea data-fieldname='" +
        q.key.toString() +
        "' " +
        numericValidation +
        " >" +
        JSON.stringify(value) +
        "</textarea>";
      break;

    case "textarea":
      fieldHTML +=
        "<label>" +
        q.label.toString() +
        (q.tooltipText != null
          ? '<i class="fa fa-question-circle" data-toggle="tooltip" data-position="right" title="' +
            q.tooltipText +
            '"></i>'
          : "") +
        "</label><textarea rows=8 data-fieldname='" +
        q.key.toString() +
        "'" +
        isRequired +
        ">" +
        value +
        "</textarea>";
      break;

    case "wysiwyg":
      fieldHTML +=
        "<label>" +
        q.label.toString() +
        (q.tooltipText != null
          ? '<i class="fa fa-question-circle" data-toggle="tooltip" data-position="right" title="' +
            q.tooltipText +
            '"></i>'
          : "") +
        '</label><textarea class="editor" data-fieldname="' +
        q.key.toString() +
        '"' +
        isRequired +
        ">" +
        value +
        "</textarea>";
      break;

    case "select":
      fieldHTML +=
        "<label>" +
        q.label.toString() +
        (q.tooltipText != null
          ? '<i class="fa fa-question-circle" data-toggle="tooltip" data-position="right" title="' +
            q.tooltipText +
            '"></i>'
          : "") +
        "</label>";
      fieldHTML +=
        '<select data-fieldname="' +
        q.key.toString() +
        '" ' +
        (q.SelectMultiple === true ? "multiple" : "") +
        isRequired +
        (q.AllowClear === true ? "data-allowclear='true' " : "") +
        (q.EnableCustomInput === true ? "data-enablecustominput" : "") +
        ">";

      if (q.SelectMultiple != true) {
        fieldHTML += `<option value="">Select One</option>`;
      }
      $.each(q.Options, function (k, v) {
        //console.log(k,v);
        fieldHTML +=
          '<option value="' +
          this.Value +
          '" ' +
          (this.Value.toString() === value ? "selected" : "") +
          ">" +
          this.Label +
          "</option>";
      });
      fieldHTML += "</select>";
      break;

    case "checkbox":
      var groupName = q.key.toString();
      var tooltipText = q.tooltipText;
      fieldHTML +=
        "<label style='display:none;'>" + q.label.toString() + "</label>";
      q.Options.forEach(function (option, index) {
        var defaultChecked = option.Value === value ? "checked" : "";
        fieldHTML += '<div class="form-check">';
        fieldHTML +=
          '<input type="checkbox" value="' +
          option.Value +
          '" aria-describedby="checkbox-single-desc" data-fieldname="' +
          groupName +
          '" ' +
          defaultChecked +
          "></input>";
        fieldHTML +=
          '<label for="checkbox-single">' + option.Label + "</label>";
        fieldHTML +=
          '<span id="checkbox-single-desc" class="visually-hidden">' +
          option.Label +
          "<span>";
        fieldHTML += "</div>";
      });
      break;

    case "radio":
      var groupName = q.key.toString();
      fieldHTML +=
        "<label>" +
        q.label.toString() +
        (q.tooltipText != null
          ? '<i class="fa fa-question-circle" data-toggle="tooltip" data-position="right" title="' +
            q.tooltipText +
            '"></i>'
          : "") +
        "</label>";
      $.each(q.Options, function (k, v) {
        fieldHTML += '<div class="form-check">';
        fieldHTML +=
          '<label class="form-check-label"><input class="form-check-input" data-fieldname="' +
          groupName +
          '" name="' +
          this.groupName +
          '" type="radio" value="' +
          this.Value +
          '">' +
          this.Name +
          "</label>";
        fieldHTML += "</div>";
      });
      break;
    case "cwe-selector":
      fieldHTML +=
        "<label>" +
        q.label.toString() +
        (q.tooltipText != null
          ? '<i class="fa fa-question-circle" data-toggle="tooltip" data-position="right" title="' +
            q.tooltipText +
            '"></i>'
          : "") +
        "</label>";
      fieldHTML +=
        '<div class="input-group"><span class="input-group-label" id="cwe-id-label">CWE:</span><select data-fieldname="' +
        q.key.toString() +
        '"' +
        isRequired +
        ' id="cwe-id"' +
        ' class="input-group-field" aria-describedby="cwe-id-label"><option value="">Please Select A CWE</option></select></div>';
      break;
    case "cve-selector":
      fieldHTML +=
        "<label>" +
        q.label.toString() +
        (q.tooltipText != null
          ? '<i class="fa fa-question-circle" data-toggle="tooltip" data-position="right" title="' +
            q.tooltipText +
            '"></i>'
          : "") +
        "</label>";
      fieldHTML +=
        '<select data-fieldname="' +
        q.key.toString() +
        '"' +
        isRequired +
        ' id="cve-id"' +
        ' aria-describedby="cve-id-label"></select>';
      break;
    default:
      fieldHTML +=
        '<label>Unknown field<small>(Unknown Field Type)</small></label><input data-fieldname="' +
        q.key.toString() +
        '" type="text" value="' +
        JSON.stringify(q) +
        '" />';
      break;
  }
  if (q.instructions) {
    fieldHTML += `
      <span class="description vhp-markdown">
        ${vhpMarkdown(q.instructions)}
      </span>
    `;
  }
  if (q.howToFind) {
    fieldHTML += `
      <h6 class="curation-subheader">How to Find</h6>
      <span class="description vhp-markdown">
        ${vhpMarkdown(q.howToFind)}
      </span>
    `;
  }
  fieldHTML += CheckForChildrenToBuild(q.key.toString());
  //console.log(fieldHTML);
  return fieldHTML;
}
function buildQuestion(questions, previousQuestion = null) {
  const project = getCurrentProject();
  let fieldHTML = "";
  let currentProgress = loadProgress();

  //console.log(parentFields, childFields);
  parentFields
    .filter((q) => q.previousQuestion == previousQuestion)
    .forEach((q) => {
      fieldHTML = buildQuestionFromConfig(q, fieldHTML);
      fieldHTML +=
        '<div class="button-group align-center question-actions"><button id="prevButton" class="button primary">Previous</button><button type="button" class="button primary" id="nextButton">Save &amp; Next</button></div>';

      document.getElementById("curationTool").setAttribute("class", "");
      document.getElementById("curationTool").innerHTML =
        "<div class='question' data-wrapperfor='" +
        q.key +
        "' data-fieldtype='" +
        q.type +
        "'>" +
        fieldHTML +
        "</div>";
      bindCVESelector(q);
      bindCweSelector(q);
      bindValidation(q);
      bindRepeater(q);
      bindConditionalLogic(q);
      setValuesOnRepeaters(q);

      document.getElementById("nextButton").addEventListener(
        "click",
        function () {
          let questionElement = this.closest(".question");
          globalErrors = [];
          saveQuestion(q, questionElement);
        },
        false
      );
      document.getElementById("prevButton").addEventListener(
        "click",
        function () {
          const projectQuestions = JSON.parse(
            localStorage.getItem("questions-" + project)
          );
          let prevQuestion = questions.filter(
            (pq) => pq.key == q.previousQuestion
          );

          buildQuestion(projectQuestions, prevQuestion[0].previousQuestion);
        },
        false
      );
      document.getElementById("resetButton").addEventListener(
        "click",
        function () {
          resetProgress();
        },
        false
      );
    });
}
function setConditionalToggle(event) {
  let fieldValue = event.target.value;
  let subFieldParent = event.target.dataset.fieldname;
  let subFields = document.querySelectorAll(
    "[data-parent='" + subFieldParent + "']>.sub-field"
  );
  event.stopPropagation();

  subFields.forEach(function (element, index) {
    let subfield = element;
    let operator = subfield.dataset.operator;
    let acceptedValuesList = subfield.dataset.acceptedValues;

    let acceptedValuesObj = [];
    if (acceptedValuesList.includes(",")) {
      acceptedValuesList = acceptedValuesList.split(",");
      acceptedValuesList.forEach(function (k, v) {
        acceptedValuesObj.push(acceptedValuesList[v]);
      });
    } else {
      acceptedValuesObj.push(acceptedValuesList);
    }
    switch (operator) {
      case "IN":
        console.log(
          subFieldParent,
          acceptedValuesObj,
          fieldValue,
          event.target.type,
          event.target.checked
        );
        if (
          acceptedValuesObj.includes(fieldValue.toString()) &&
          (event.target.type != "checkbox" ||
            (event.target.type == "checkbox" && event.target.checked === true))
        ) {
          let subfieldGroup = document.querySelector(
            "[data-parent='" + subFieldParent + "']"
          );
          subfieldGroup.style.display = "block";
        } else {
          let subfieldGroup = document.querySelector(
            "[data-parent='" + subFieldParent + "']"
          );
          subfieldGroup.style.display = "none";
        }
        break;
      case "NOT IN":
        if (
          !acceptedValuesObj.includes(fieldValue.toString()) &&
          (event.target.type != "checkbox" ||
            (event.target.type == "checkbox" && event.target.checked === false))
        ) {
          let subfieldGroup = document.querySelector(
            "[data-parent='" + subFieldParent + "']"
          );
          subfieldGroup.style.display = "block";
        } else {
          let subfieldGroup = document.querySelector(
            "[data-parent='" + subFieldParent + "']"
          );
          subfieldGroup.style.display = "none";
        }
        break;
    }
  });
}
function bindConditionalLogic(q) {
  if (childFields.length) {
    let parent = q;
    let parentField = document.querySelector(
      "[data-fieldname='" + parent.key + "']"
    );
    childFields.forEach(function (element, index) {
      //console.log("Parent To Validate: ", parent.key, childFields[index]);
      if (childFields[index].parentName == parent.key) {
        setTimeout(function () {
          parentField.dispatchEvent(new Event("input"));
          parentField.dispatchEvent(new Event("change"));
        }, 0);
      }
    });
    let children = getChildFields(parent.key);
    for (const key in children) {
      if (children.hasOwnProperty(key)) {
        let childConfig = children[key].config;
        let childField = document.querySelector(
          "[data-fieldname='" + childConfig.key + "']"
        );
        childField.addEventListener("input", setConditionalToggle);
        childField.addEventListener("change", setConditionalToggle);
        setTimeout(function () {
          childField.dispatchEvent(new Event("input"));
          childField.dispatchEvent(new Event("change"));
        }, 0);
      }
    }
    parentField.addEventListener("input", setConditionalToggle);
    parentField.addEventListener("change", setConditionalToggle);
  }
}
function bindRepeater(question) {
  if (question.type == "repeater") {
    let questionElement = document.querySelectorAll(".question")[0];
    let repeaterType = question.repeaterType;
    questionElement.querySelectorAll(".addRepeater")[0].addEventListener(
      "click",
      function () {
        buildRepeater(repeaterType, questionElement);
      },
      false
    );
  }
}
function bindValidation(question) {
  if (question.previousQuestion == null) {
    document.getElementById("prevButton").disabled = true;
  }
  //Add repeater events if repeater field
  let subfields = document.querySelectorAll(".sub-field");
  //console.log(subfields);
  subfields.forEach((field) => {
    const fieldType = field.dataset.fieldtype;
    if (fieldType === "repeater") {
      let repeaterType = question.repeaterType;
      console.log(field);
      field.querySelectorAll(".addRepeater")[0].addEventListener(
        "click",
        function () {
          let questionElement = this.closest(".sub-field");
          buildRepeater(repeaterType, questionElement);
        },
        false
      );
    }
  });
  //TODO: Dynamically determine "Last"
  if (question.isLast == true) {
    document.getElementById("nextButton").innerHTML = "Save and Show YAML";
    document.getElementById("nextButton").addEventListener(
      "click",
      function () {
        let questionElement = this.closest(".question");
        saveQuestion(question, questionElement);
        $("#open-yaml").trigger("click");
      },
      false
    );
  }
}
function setValuesOnRepeaters(question) {
  let questionElement = document.querySelector(".question");
  if (question.type == "repeater") {
    let answerArr = checkForSavedAnswer(question.key);
    let firstField = document.querySelector(
      "[data-fieldname='" + question.key + "']"
    );
    firstField.value = answerArr[0];
    answerArr.slice(1, answerArr.length).forEach((answer) => {
      buildRepeater(question.repeaterType, questionElement, answer);
    });
  } else {
    let children = getChildFields(question.key);
    for (const key in children) {
      if (children.hasOwnProperty(key)) {
        let childConfig = children[key].config;
        if (childConfig.type == "repeater") {
          let answerArr = checkForSavedAnswer(childConfig.key);
          let firstField = document.querySelector(
            "[data-fieldname='" + childConfig.key + "']"
          );
          firstField.value = answerArr[0];
          answerArr.slice(1, answerArr.length).forEach((answer) => {
            buildRepeater(childConfig.repeaterType, questionElement, answer);
          });
        }
      }
    }
  }
}
let parseField = {
  input: function (field) {
    return $(field).find("input").val();
  },
  date: function (field) {
    return $(field).find("input").val();
  },
  textArea: function (field) {
    return $(field).find("input").val();
  },
  number: function (field) {
    let result = $(field).find("input").val();

    if (isNaN(result)) {
      console.log("String: " + result, typeof result);
      return result;
    } else {
      return parseInt(result.valueOf());
    }

    return result;
  },
  select: function (field) {
    var result = $(field).find("select").val();
    var label = $(field).find("label").text();
    if ($(field).find("select").prop("required")) {
      if (result == null || result == "") {
        globalErrors.push(label + " cannot be empty");
      }
    }
    if (result == null) {
      return "";
    }
    if (typeof result == "string") {
      if (isNaN(result)) {
        return result;
      } else {
        return parseInt(result.valueOf());
      }
    } else if (typeof result == "object") {
      var objResult = [];
      $.each(result, function (k, v) {
        if (isNaN(v)) {
          objResult.push(v);
        } else {
          objResult.push(parseInt(v.valueOf()));
        }
      });
      return objResult;
    }
  },
  checkbox: function (fieldName) {
    let checkboxes = document.querySelectorAll(
      "[data-fieldname = '" + fieldName + "']"
    );
    let valuesToSave = [];
    checkboxes.forEach(function (field) {
      valuesToSave.push(field.checked);
    });
    return valuesToSave;
  },
  radio: function (field) {
    return $(field).find("input[type=radio]").is(":checked");
  },
  json: function (fieldName) {
    let jsonField = document.querySelector(
      "[data-fieldname = '" + fieldName + "']"
    );
    return JSON.parse(jsonField.value);
  },
  repeater: function (fieldName) {
    let config = getConfigFromName(fieldName);

    let repeaterFields = document.querySelectorAll(
      "[data-fieldname = '" + fieldName + "']"
    );
    let valuesToSave = [];
    repeaterFields.forEach(function (field) {
      console.log(field.value);
      if (isValueValid(config.validationType, fieldName, field.value)) {
        valuesToSave.push(field.value);
      }
    });
    console.log(valuesToSave);
    return valuesToSave;
  },
};

function bindCVESelector(q) {
  if (q.type !== "cve-selector") {
    return;
  }
  const project = getCurrentProject();
  $.ajax({
    url: "/api/vulnerabilities",
    dataType: "json",
  }).then((data) => {
    let cveNames = data
      .filter((entry) => entry.subdomain == project)
      .map((entry) => entry.cve)
      .sort();
    $("#cve-id")
      .select2({
        placeholder: {
          id: "-1",
          text: "--- Type or Select a CVE ---",
          selected: "selected",
        },
        allowClear: true,
        data: cveNames,
        tags: true,
      })
      .on("select2:select", function (evt) {
        const regex = new RegExp(/^CVE-\d{4}-\d{4,}$/);
        // Don't create entry if not valid format
        if (!regex.test(evt.params.data.text)) {
          alert("Entry is not in valid CVE Format: CVE-0000-0000");
          $(evt.target).val(null).trigger("change");
          return null;
        }
      });
    let value = checkForSavedAnswer(q.key);
    $("#cve-id").val(value).trigger("change");
  });
}
function bindCweSelector(q) {
  if (q.type !== "cwe-selector") {
    return;
  }
  const cweManager = new CweManager();
  const result = cweManager.isChildOf({ weaknessId: "117", parentId: "116" });

  //Software Development CWE Category Seeding
  const cweDictArray = Object.values(cweManager.cweDictionary);
  const sdc = [
    ["API/Function Errors", "1228"],
    ["Audit/Logging Errors", "1210"],
    ["Authentication Errors", "1211"],
    ["Authorization Errors", "1212"],
    ["Bad Coding Practices", "1006"],
    ["Behavioral Problems", "438"],
    ["Business Logic Errors", "840"],
    ["Communication Channel Errors", "417"],
    ["Complexity Issues", "1226"],
    ["Concurrency Issues", "557"],
    ["Credentials Management Errors", "255"],
    ["Cryptographic Issues", "310"],
    ["Key Management Errors", "320"],
    ["Data Integrity Issues", "1214"],
    ["Data Processing Errors", "19"],
    ["Data Neutralization Issues", "137"],
    ["Documentation Issues", "1225"],
    ["File Handling Issues", "1219"],
    ["Encapsulation Issues", "1227"],
    ["Error Conditions, Return Values, Status Codes", "389"],
    ["Expression Issues", "569"],
    ["Handler Errors", "429"],
    ["Information Management Errors", "199"],
    ["Initialization and Cleanup Errors", "452"],
    ["Data Validation Issues", "1215"],
    ["Lockout Mechanism Errors", "1216"],
    ["Memory Buffer Errors", "1218"],
    ["Numeric Errors", "189"],
    ["Permission Issues", "275"],
    ["Pointer Issues", "465"],
    ["Privilege Issues", "265"],
    ["Random Number Issues", "1213"],
    ["Resource Locking Problems", "411"],
    ["Resource Management Errors", "399"],
    ["Signal Errors", "387"],
    ["State Issues", "371"],
    ["String Errors", "133"],
    ["Type Errors", "136"],
    ["User Interface Security Issues", "355"],
    ["User Session Errors", "1217"],
  ];
  const softwareDevelopmentCategories = sdc.map((s, i) => {
    return {
      id: s[1],
      text: s[0],
      children: [],
    };
  });
  softwareDevelopmentCategories.push({
    id: "2000",
    text: "Uncategorized",
    children: [],
  });

  const softwareDevelopmentViews = softwareDevelopmentCategories.map((cat) => {
    cweDictArray.map((cwe) => {
      const cweId = cwe.attr["@_ID"];
      cweManager.cweMemberships.map((mem) => {
        if (mem.weaknessId == cweId) {
          if (mem.memberships.includes(cat.id)) {
            cat.children.push({
              id: cweId,
              text: `#${cwe.attr["@_ID"]}: ${cwe.attr["@_Name"]}`,
            });
          }
        }
      });
    });
    return cat;
  });

  cweDictArray.map((cwe) => {
    const cweId = cwe.attr["@_ID"];
    const inSdv = softwareDevelopmentViews.map(({ children }) => {
      const inChildren = children.forEach((c) => {
        if (c.id === cweId) {
          return true;
        } else {
          return false;
        }
      });
      if (!inChildren) {
        return false;
      } else {
        return true;
      }
    });
    if (!inSdv.includes(true)) {
      softwareDevelopmentCategories.map((sdc, i) => {
        if (sdc.id === "2000") {
          sdc.children.push({
            id: cweId,
            text: `#${cwe.attr["@_ID"]}: ${cwe.attr["@_Name"]}`,
          });
        }
      });
    }
  });

  $("#cwe-id").select2({
    placeholder: {
      id: "-1",
      text: "--- Type or Select a CWE ---",
      selected: "selected",
    },
    allowClear: true,
    data: softwareDevelopmentViews,
  });
  let value = checkForSavedAnswer(q.key);
  $("#cwe-id").val(value).trigger("change");
}
export default function curationWizard() {
  /* QUESTION PATH*/
  const projects = document.querySelectorAll("#curationTool .card");

  for (let i = 0; i < projects.length; i++) {
    projects[i].addEventListener(
      "click",
      async function () {
        const project = this.dataset.project;
        let questions = await loadQuestions(project);
        //console.log(questions);
      },
      false
    );
  }

  $("#open-menu").on("click", function () {
    setTimeout(function () {
      $("#YAMLOutput").trigger("focus");
    }, 1000);
  });

  $("#CopyYAML").on("click", function () {
    const yamlField = document.getElementById("YAMLOutput");
    const yamlOutput = yamlField.value;
    // Select the text field
    yamlField.select();
    yamlField.setSelectionRange(0, yamlOutput.length); // For mobile devices

    // Copy the text inside the text field
    navigator.clipboard.writeText(yamlOutput);
    Toastify({
      text: "YAML copied to clipboard",
      duration: 3000,
      close: true,
      gravity: "top", // `top` or `bottom`
      position: "right", // `left`, `center` or `right`
      stopOnFocus: true, // Prevents dismissing of toast on hover
      style: {
        background: "linear-gradient(to right, #00b09b, #96c93d)",
      },
      onClick: function () {}, // Callback after click
    }).showToast();
  });

  function downloadYml() {
    const yamlField = document.getElementById("YAMLOutput");
    const yamlOutput = yamlField.value;
    let fileName = "curation.yml";

    //Check if question is answered. if so, set it as the filename
    let cve = checkForSavedAnswer("CVE");
    if (cve) {
      fileName = cve + ".yml";
    }
    // It works on all HTML5 Ready browsers as it uses the download attribute of the <a> element:
    const element = document.createElement("a");

    //A blob is a data type that can store binary data
    // “type” is a MIME type
    // It can have a different value, based on a file you want to save
    const blob = new Blob([yamlOutput], { type: "plain/text" });
    //createObjectURL() static method creates a DOMString containing a URL representing the object given in the parameter.
    const fileUrl = URL.createObjectURL(blob);

    //setAttribute() Sets the value of an attribute on the specified element.
    element.setAttribute("href", fileUrl); //file location
    element.setAttribute("download", fileName); // file name
    element.style.display = "none";

    //use appendChild() method to move an element from one element to another
    document.body.appendChild(element);
    element.click();

    //The removeChild() method of the Node interface removes a child node from the DOM and returns the removed node
    document.body.removeChild(element);
  }
  $("#download").on("click", function () {
    downloadYml();
  });
}
