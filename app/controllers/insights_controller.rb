class InsightsController < ApplicationController




  # GET /insights
  # GET /insights/tag-trends
  def tag_trends
    @tags = Tag.map
  end

  # GET /api/insights/family-tag-links
  def family_tag_links_api
    permitted_params = ["bounty", "lifetime", "project", "language", "deps", "error of omission", "i18n", "environment_variables",
      "least_privilege", "origin", "specification", "complex_inputs", "frameworks_are_optional", "secure_by_default", "security_by_obscurity",
    "vouch", "serial_killer", "discovered_method", "native_wrappers", "sandbox", "yagni", "fix"]

    params.permit(:family1, :family2, :family3, :family4)

    if permitted_params.include?(params[:family1])
      family1 = params[:family1]
    else
      family1 = []
    end

    if permitted_params.include?(params[:family2])
      family2 = params[:family2]
    else
      family2 = []
    end

    if permitted_params.include?(params[:family3])
      family3 = params[:family3]
    else
      family3 = []
    end

    if permitted_params.include?(params[:family4])
      family4 = params[:family4]
    else
      family4 = []
    end

    query = <<~EOSQL
    SELECT
    (SELECT COUNT(t1.shortname)
      FROM tags as t1
      CROSS join tags as t2
      INNER join vulnerability_tags as vt1 on t1.id = vt1.tag_id
      INNER join vulnerability_tags as vt2 on t2.id = vt2.tag_id
      WHERE t1.family = ?
        AND t2.family = ?
        AND vt1.vulnerability_id = vt2.vulnerability_id) as firstLink,
    (SELECT COUNT(t1.shortname)
      FROM tags as t1
      CROSS join tags as t2
      INNER join vulnerability_tags as vt1 on t1.id = vt1.tag_id
      INNER join vulnerability_tags as vt2 on t2.id = vt2.tag_id
      WHERE t1.family = ?
        AND t2.family = ?
        AND vt1.vulnerability_id = vt2.vulnerability_id) as secondLink,
    (SELECT COUNT(t1.shortname)
      FROM tags as t1
      CROSS join tags as t2
      INNER join vulnerability_tags as vt1 on t1.id = vt1.tag_id
      INNER join vulnerability_tags as vt2 on t2.id = vt2.tag_id
      WHERE t1.family = ?
        AND t2.family = ?
        AND vt1.vulnerability_id = vt2.vulnerability_id) as thirdLink,
    (SELECT
      (SELECT COUNT(id) FROM vulnerabilities) -
      (SELECT count(Distinct vulnerability_id) from
        vulnerability_tags join tags on tags.id = vulnerability_tags.tag_id
        where tags.family = ?
        or tags.family = ?
        or tags.family = ?
        or tags.family = ?)
    ) as excludedVulnerabilities
    EOSQL

    #Runs SQL query and returns results, Empty if error or no results
    begin
      sanitizedQuery = ActiveRecord::Base.sanitize_sql([query, family1, family2, family2, family3, family3, family4, family1, family2, family3, family4])
      results = ActiveRecord::Base.connection.execute(sanitizedQuery)
    rescue
      results = []
    end

    render_json_for_api results

  end

	# GET /api/insights/tag-trends
	def tag_trends_api
    #Gets the list of tags from the database based on family

    permitted_params = ["bounty", "lifetime", "project", "language", "deps", "error of omission", "i18n", "environment_variables",
      "least_privilege", "origin", "specification", "complex_inputs", "frameworks_are_optional", "secure_by_default", "security_by_obscurity",
    "vouch", "serial_killer", "discovered_method", "native_wrappers", "sandbox", "yagni", "fix"]

    params.permit(:family1, :family2, :family3, :family4)

    if permitted_params.include?(params[:family1])
      family1 = params[:family1]
    else
      family1 = []
    end

    if permitted_params.include?(params[:family2])
      family2 = params[:family2]
    else
      family2 = []
    end

    if permitted_params.include?(params[:family3])
      family3 = params[:family3]
    else
      family3 = []
    end

    if permitted_params.include?(params[:family4])
      family4 = params[:family4]
    else
      family4 = []
    end

    query = <<~EOSQL
    SELECT t1.shortname as tag1,
        t2.shortname as tag2,
        t1.name as tag1Name,
        t2.name as tag2Name,
        t1.icon as tag1Icon,
        t2.icon as tag2Icon,
        t1.color as tag1Color,
        t2.color as tag2Color,
        count(*) as num_vals
        FROM tags as t1
        CROSS join tags as t2
        INNER join vulnerability_tags as vt1 on t1.id = vt1.tag_id
        INNER join vulnerability_tags as vt2 on t2.id = vt2.tag_id
    WHERE t1.family = ?
        AND t2.family = ?
        AND vt1.vulnerability_id = vt2.vulnerability_id
        GROUP BY t1.id, t2.id

    UNION

    SELECT t1.shortname as tag1,
      t2.shortname as tag2,
      t1.name as tag1Name,
      t2.name as tag2Name,
      t1.icon as tag1Icon,
      t2.icon as tag2Icon,
      t1.color as tag1Color,
      t2.color as tag2Color,
      count(*) as num_vals
      FROM tags as t1
      CROSS join tags as t2
      INNER join vulnerability_tags as vt1 on t1.id = vt1.tag_id
      INNER join vulnerability_tags as vt2 on t2.id = vt2.tag_id
    WHERE t1.family = ?
      AND t2.family = ?
      AND vt1.vulnerability_id = vt2.vulnerability_id
      GROUP BY t1.id, t2.id

    UNION

    SELECT t1.shortname as tag1,
      t2.shortname as tag2,
      t1.name as tag1Name,
      t2.name as tag2Name,
      t1.icon as tag1Icon,
      t2.icon as tag2Icon,
      t1.color as tag1Color,
      t2.color as tag2Color,
      count(*) as num_vals
      FROM tags as t1
      CROSS join tags as t2
      INNER join vulnerability_tags as vt1 on t1.id = vt1.tag_id
      INNER join vulnerability_tags as vt2 on t2.id = vt2.tag_id
    WHERE t1.family = ?
      AND t2.family = ?
      AND vt1.vulnerability_id = vt2.vulnerability_id
      GROUP BY t1.id, t2.id
    EOSQL

    #Runs SQL query and returns results, Empty if error or no results
    begin
      sanitizedQuery = ActiveRecord::Base.sanitize_sql([query, family1, family2, family2, family3, family3, family4])
      results = ActiveRecord::Base.connection.execute(sanitizedQuery)
    rescue
      results = []
    end

    dataForSankey = {}
    #total nodes
    nodes = []

    #add all of the first column for sankey diagram
    results.each do |result|
      node1 = {name: result['tag1'], displayName: result['tag1name'], icon: result['tag1icon'], color: result['tag1color']}
      unless nodes.include?(node1)
        nodes << node1
      end
    end

    #add all of the second column for sankey diagram
    results.each do |result|
      node2 = {name: result['tag2'], displayName: result['tag2name'], icon: result['tag2icon'], color: result['tag2color']}
      unless nodes.include?(node2)
        nodes << node2
      end
    end

    dataForSankey[:nodes] = nodes

    links = []

    results.each do |result|
      link = {source: result['tag1'], target: result['tag2'], value: result['num_vals']}
      unless links.include?(link)
        links << link
      end
    end

    dataForSankey[:links] = links

    render_json_for_api dataForSankey

  end
end

