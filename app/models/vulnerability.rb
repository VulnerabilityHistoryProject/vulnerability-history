class Vulnerability < ApplicationRecord
  has_many :vccs, foreign_key: 'vulnerability_id'
  has_many :fixes, foreign_key: 'vulnerability_id'
  has_many :vulnerability_tags, foreign_key: 'vulnerability_id'
  has_many :tags, through: :vulnerability_tags
  has_many :article_vulnerabilities, foreign_key: 'vulnerability_id'
  has_many :articles, through: :article_vulnerabilities
  has_many :events
  belongs_to :project

  def self.list_all(short_descriptions)
    @vs = Vulnerability.
      left_outer_joins(:vulnerability_tags).
      joins(:project).
      select("vulnerabilities.id as id").
      select("vulnerabilities.cve as cve").
      select("vulnerabilities.announced").
      select("vulnerabilities.upvotes").
      select("vulnerabilities.nickname").
      select("max(projects.name) AS project_name").
      select("max(projects.subdomain) AS subdomain").
      select("JSON_AGG(JSON_BUILD_OBJECT(
              'id', vulnerability_tags.tag_id,
              'importance', vulnerability_tags.importance
              ) ORDER BY importance DESC) AS tag_json").
      group('vulnerabilities.id').
      order('vulnerabilities.upvotes desc')

    if short_descriptions
      @vs.select('vulnerabilities.short_desc as short_desc')
    else
      @vs.select('vulnerabilities.description as description')
    end
  end

  def self.curated
    where(" notes -> 'curated' = 'true' OR notes -> 'curation_level' <> '0'")
  end

  def self.word_count
    wc_sql = <<~EOSQL
      SUM(ARRAY_LENGTH(REGEXP_SPLIT_TO_ARRAY(description, '\s'),1)) AS word_count
    EOSQL
    # reorder removes the ORDER BY
    word_counts = all.reorder(nil).group(:id).select(wc_sql)
    word_counts.map { |v| v.word_count }.sum
  end

  def tags_by_name
    tags.order(name: :asc).
         includes(:vulnerability_tags).
         select('
           tags.id,
           tags.name,
           tags.color,
           tags.icon,
           tags.shortname,
           vulnerability_tags.note
          ')
  end

  def self.sameCWE(cve, limit, offset)
    query = <<~EOSQL
        SELECT DISTINCT v2.cve, v2.description, v2.project_id, v2.upvotes, v2.nickname
          FROM vulnerabilities v1
          INNER JOIN vulnerability_tags vt1 ON v1.id = vt1.vulnerability_id
          INNER JOIN tags t1 ON vt1.tag_id = t1.id
          INNER JOIN vulnerability_tags vt2 ON vt1.tag_id = vt2.tag_id
          INNER JOIN vulnerabilities v2 ON vt2.vulnerability_id = v2.id
            WHERE v1.cve = ?
              AND v2.cve != ?
              AND starts_with(t1.shortname, 'cwe')
        ORDER BY v2.upvotes DESC
        LIMIT ?
        OFFSET ?
      EOSQL
      sanitizedQuery = ActiveRecord::Base.sanitize_sql([query, cve, cve, limit, offset])
      results = ActiveRecord::Base.connection.execute(sanitizedQuery);
  end

  def self.sameLessons(cve, limit, offset)
    query = <<~EOSQL
        SELECT DISTINCT v2.cve, v2.description, v2.project_id, v2.upvotes, v2.nickname
          FROM vulnerabilities v1
          INNER JOIN vulnerability_tags vt1 ON v1.id = vt1.vulnerability_id
          INNER JOIN tags t1 ON vt1.tag_id = t1.id
          INNER JOIN vulnerability_tags vt2 ON vt1.tag_id = vt2.tag_id
          INNER JOIN vulnerabilities v2 ON vt2.vulnerability_id = v2.id
            WHERE v1.cve = ?
              AND v2.cve != ?
              AND starts_with(t1.name, 'Lesson')
        ORDER BY v2.upvotes DESC
        LIMIT ?
        OFFSET ?
      EOSQL
      sanitizedQuery = ActiveRecord::Base.sanitize_sql([query, cve, cve, limit, offset])
      results = ActiveRecord::Base.connection.execute(sanitizedQuery);
  end

  def self.sameDirectory(cve, limit, offset)
    query = <<~EOSQL
      SELECT DISTINCT 
        v2.cve, 
        v2.description, 
        v2.project_id, 
        v2.upvotes, 
        v2.nickname,
        v2.id as related_vul_id
          FROM vulnerabilities AS v1
            INNER JOIN vulnerabilities AS v2 ON (v1.id <> v2.id AND v1.project_id = v2.project_id)
            INNER JOIN fixes AS f1 ON (f1.vulnerability_id = v1.id)
            INNER JOIN fixes AS f2 ON (f2.vulnerability_id = v2.id)
            INNER JOIN commits AS c1 ON c1.id = f1.commit_id
            INNER JOIN commits AS c2 ON c2.id = f2.commit_id
            INNER JOIN commit_filepaths AS cf1 ON cf1.commit_id = c1.id
            INNER JOIN commit_filepaths AS cf2 ON cf2.commit_id = c2.id
            INNER JOIN filepaths AS fp1 ON cf1.filepath_id = fp1.id
            INNER JOIN filepaths AS fp2 ON cf2.filepath_id = fp2.id
            WHERE fp1.dir = fp2.dir
                  AND fp1.is_code = TRUE
                  AND fp2.is_code = TRUE
                  AND fp1.project_id = fp2.project_id
              AND v1.cve = ?
          ORDER BY v2.upvotes DESC
          LIMIT ?
          OFFSET ?
      EOSQL
      sanitizedQuery = ActiveRecord::Base.sanitize_sql([query, cve, limit, offset])
      results = ActiveRecord::Base.connection.execute(sanitizedQuery);
  end
end
