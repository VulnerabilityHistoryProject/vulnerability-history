class Tag < ApplicationRecord
    has_many :vulnerability_tags, foreign_key: 'tag_id'
    has_many :vulnerabilities, through: :vulnerability_tags
    has_many :article_tags, foreign_key: 'tag_id'
    has_many :articles, through: :article_tags

    def self.map
      tag_query = Tag.select(:id, :name, :shortname, :color, :icon, :family)
      tag_map = tag_query.inject({}) do |map, tag|
        map[tag.id] = {
          'name' => tag.name,
          'shortname' => tag.shortname,
          'color' => tag.color,
          'icon' => tag.icon,
          'family' => tag.family,
        };
        map
      end
    end

    def self.lessons
      joins(:vulnerability_tags).where("name LIKE 'Lesson: %'")
    end

    def self.overlaps(arr_shortname)

      tag_query = <<~EOSQL
      SELECT vul.cve,
             vul.nickname,
             vul.upvotes,
             vul.project_id,
             vul.description,
             max(projects.subdomain) AS subdomain,
             max(projects.name) AS project_name,
             JSON_AGG(JSON_BUILD_OBJECT(
              'id', vt.tag_id,
              'importance', vt.importance
              ) ORDER BY importance DESC) AS tag_json
         FROM vulnerabilities AS vul
         JOIN vulnerability_tags AS vt ON vul.id = vt.vulnerability_id
         JOIN projects on vul.project_id = projects.id
         JOIN tags AS t on vt.tag_id = t.id
         GROUP BY vul.cve, vul.nickname, vul.upvotes, vul.project_id, vul.description
         HAVING array_agg(t.shortname)::text[] @> ARRAY[?]
        ORDER BY vul.upvotes
      EOSQL

      sanitizedQuery = ActiveRecord::Base.sanitize_sql([tag_query, arr_shortname])
      results = ActiveRecord::Base.connection.execute(sanitizedQuery);
      return results
      
    end
end
